### 活动用到的设计模式

责任链模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。

使用：活动一个项目不同的玩法，接到的消息一条一条接着处理

### 高并发的设计模式

reator：反应器设计模式(Reactor pattern)是一种为处理并发服务请求，并将请求提交到一个或者多个服务处理程序的事件设计模式。当客户端请求抵达后，服务处理程序使用多路分配策略，由一个非阻塞的线程来接收所有的请求，然后派发这些请求至相关的工作线程进行处理。对于高并发系统，常会使用Reactor模式，其代替了常用的多线程处理方式，节省系统的资源，提高系统的吞吐量。

### guava cache 

1、builder模式：模式主要是用一个内部类去实例化一个对象，避免一个类出现过多构造函数，而且构造函数如果出现默认参数的话，很容易出错。

https://www.cnblogs.com/begin1949/p/4930896.html

2、装饰模式

装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。

适配器模式的意义是要将一个接口转变成另一个接口，它的目的是通过改变接口来达到重复使用的目的。而装饰器模式不是要改变被装饰对象的接口，而是恰恰要保持原有的接口，但是增强原有对象的功能，或者改变原有对象的处理方式而提升性能。所以这两个模式设计的目的是不同的。

3、策略模式，使用那种缓存，策略模式：使用的就是面向对象的继承和多态机制，从而实现同一行为在不同场景下具备不同实现。

### EventBus

1、单例模式：一个类有且仅有一个实例，并且自行实例化向整个系统提供。

2、建造者模式：将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。

3、观察者模式：定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

### ThreadPoolExecutor

1、工厂方法-Exectors

2、模版方法-ThreadPoolExecutor.Worker

定义一个模板结构，将具体内容延迟到子类去实现。在不改变模板结构的前提下在子类中重新定义模板中的内容。模板方法模式是基于”继承“的；提高代码复用性：将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中；实现了反向控制：通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 & 符合“开闭原则”

3、策略-ThreadPoolExecutor中的四种拒绝策略

策略模式：使用的就是面向对象的继承和多态机制，从而实现同一行为在不同场景下具备不同实现。

4、命令-ThreadPoolExecutor.execute

将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。

