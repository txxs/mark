来源:https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-persistence.md
https://blog.csdn.net/zzm848166546/article/details/80360665

https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-persistence.md


redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？

redis 如果仅仅只是将数据缓存在内存里面，如果 redis 宕机了再重启，内存里的数据就全部都弄丢了啊。你必须得用 redis 的持久化机制，将数据写入内存的同时，异步的慢慢的将数据写入磁盘文件里，进行持久化。

如果 redis 宕机重启，自动从磁盘上加载之前持久化的一些数据就可以了，也许会丢失少许数据，但是至少不会将所有数据都弄丢。

这个其实一样，针对的都是 redis 的生产环境可能遇到的一些问题，就是 redis 要是挂了再重启，内存里的数据不就全丢了？能不能重启的时候把数据给恢复了？

### 面试题剖析
持久化主要是做灾难恢复、数据恢复，也可以归类到高可用的一个环节中去，比如你 redis 整个挂了，然后 redis 就不可用了，你要做的事情就是让 redis 变得可用，尽快变得可用。

重启 redis，尽快让它对外提供服务，如果没做数据备份，这时候 redis 启动了，也不可用啊，数据都没了。

很可能说，大量的请求过来，缓存全部无法命中，在 redis 里根本找不到数据，这个时候就死定了，出现缓存雪崩问题。所有请求没有在 redis 命中，就会去 mysql 数据库这种数据源头中去找，一下子 mysql 承接高并发，然后就挂了...

如果你把 redis 持久化做好，备份和恢复方案做到企业级的程度，那么即使你的 redis 故障了，也可以通过备份数据，快速恢复，一旦恢复立即对外提供服务。

### redis 持久化的两种方式
RDB：RDB 持久化机制，是对 redis 中的数据执行周期性的持久化。
AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。
通过 RDB 或 AOF，都可以将 redis 内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云等云服务。

如果 redis 挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动 redis，redis 就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。

如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。

#### RDB 优缺点
RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。

RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。

相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。

如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。

RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。

#### RDB 操作命令
采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。可以在配置文件中配置Redis进行快照保存的时机：

save [seconds] [changes]
意为在[seconds]秒内如果发生了[changes]次数据修改，则进行一次RDB快照保存，例如

save 60 100
会让Redis每60秒检查一次数据变更情况，如果发生了100次或以上的数据变更，则进行RDB快照保存。
可以配置多条save指令，让Redis执行多级的快照保存策略。
Redis默认开启RDB快照，默认的RDB策略如下：

save 900 1
save 300 10
save 60 10000
也可以通过BGSAVE命令手工触发RDB快照保存。


#### AOF 优缺点
AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次fsync操作，最多丢失 1 秒钟的数据。
AOF 日志文件以 append-only 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。
AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 rewrite log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。
AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据。
对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。
AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的。（如果实时写入，那么 QPS 会大降，redis 性能会大大降低）
以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 / merge / 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。
RDB 和 AOF 到底该如何选择
不要仅仅使用 RDB，因为那样会导致你丢失很多数据；
也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug；
redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。

#### AOF 操作命令
采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。

AOF默认是关闭的，如要开启，进行如下配置：

appendonly yes
AOF提供了三种fsync配置，always/everysec/no，通过配置项[appendfsync]指定：

appendfsync no：不进行fsync，将flush文件的时机交给OS决定，速度最快
appendfsync always：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢
appendfsync everysec：折中的做法，交由后台线程每秒fsync一次
随着AOF不断地记录写操作日志，必定会出现一些无用的日志，例如某个时间点执行了命令SET key1 "abc"，在之后某个时间点又执行了SET key1 "bcd"，那么第一条命令很显然是没有用的。大量的无用日志会让AOF文件过大，也会让数据恢复的时间过长。
所以Redis提供了AOF rewrite功能，可以重写AOF文件，只保留能够把数据恢复到最新状态的最小写操作集。
AOF rewrite可以通过BGREWRITEAOF命令触发，也可以配置Redis定期自动进行：

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
上面两行配置的含义是，Redis在每次AOF rewrite时，会记录完成rewrite后的AOF日志大小，当AOF日志大小在该基础上增长了100%后，自动进行AOF rewrite。同时如果增长的大小没有达到64mb，则不会进行rewrite。

原文地址
https://jianyuan.me/2018/11/17/redis-persistent-strategies/

Redis通常用来作为缓存服务器，其数据全部保存在内存里面。但是，是机器就会存在宕机的情况，一旦宕机，所有的内存数据就全部丢失了。因此，必须有一种机制来保证Redis的数据能能被持久化，以便在宕机时降低损失。

Redis为我们提供了两种持久化的策略，RDB和AOF。RDB是一种全量备份机制，其备份得到的是二进制内容，结构上十分紧凑；而AOF则是一种通过增量日志实现持续备份的机制，AOF记录的是对内存数据中进行了修改的操作指令，存储的文本内容。

### RDB原理：SAVE和BGSAVE
Redis有两个命令可以生成RDB snapshot，一个是SAVE，一个是BGSAVE。SAVE命令是以同步的方式创建snapshot，也就是说会造成阻塞，Redis在SAVE命令运行期间将不会响应其他的命令。而BGSAVE则是通过fork一个子进程，将备份的任务交给子进程去做，而父进程可以继续响应客户端的请求。

SAVE和BGSAVE的备份方式其实是一样的，区别只在于是否会阻塞服务，假设Redis中创建RDB的函数抽象是rdb_save，通过下面的伪代码来描述SAVE和BGSAVE的区别：

```
def SAVE():
    # SAVE，同步创建RDB
    rdb_save()

def BGSAVE():
    # fork子进程
    pid = fork()
    if pid == 0:
        # 子进程创建RDB文件
        rdb_save()
        # RDB备份完成，通知父进程
        signal_parent()
    else if pid > 0:
        # 父进程继续处理请求
        # 同时等待子进程通知
        handle_reqs_and_wait_signal()
    else:
        # fork子进程失败处理函数
        handle_fork_error()
```

可以看出SAVE和BGSAVE的区别仅仅在于执行rdb_save()的进程不一样。

由于BGSAVE的快照创建时在子进程中进行的，而父进程继续响应客户端的请求。如果在子进程备份过程中，父进程接收到了客户端的修改执行，如何来保证数据的一致性呢？Redis通过COW(Copy On Write)机制，对于读取请求，父进程直接读取共享内存就可以了，而在父进程要进行修改时，将要修改的数据页拷贝一份。当越来越多的页在BGSAVE备份过程中被修改，那么占用的内存会越来越多，但是理论上不会超过原数据内存的2倍(不考虑新数据的情况下)。由于子进程不会修改数据，所以子进程看到的内存在子进程被fork的时候就固定好了。

自动创建RDB快照
Redis可以根据配置，进行定时的快照创建。例如，我们可以在配置中加入如下配置：

```
save 900 1
save 300 10
save 60 10000
```
那么，Redis则会在满足下面任一条件的情况下，采用BGSAVE的方式创建RDB快照:

900秒内发生至少一次写
300秒内，至少发生10次写
60秒内，至少发生1万次写
Redis会在周期性操作函数serverCron中进行是否需要创建RDB的检查。serverCron的作用是Redis中对正在运行中的服务器进行维护，其中一项任务便是检查是否需要进行RDB快照的创建。

Redis中通过saveparams数据结构来存储自动快照的配置，其结构如下:
```
序号	seconds	changes
0	900	1
1	300	10
2	60	10000
```
同时，Redis中会保存上次创建备份的时间，以及上次备份之后对数据库写的次数:

lastsave	dirty ops
通过下面的伪代码，我们来了解serverCron是如何生成RDB快照的:

```
def serverCron:
    # ....
    # 遍历所有条件
    for saveparam in serer.saveparams:
        # 计算间隔
        interval = now() - server.lastsave
        # 脏数据和时间间隔同时满足
        if (server.dirty > saveparam.changes and \
            interval > saveparam.seconds):
            BGSAVE()
    
    ## ....
```

### AOF原理
除了RDB，Redis还提供了AOF(Append Only File)持久化功能。和RDB将Redis的内存全量转存的快照方式不同，AOF的工作机制是将客户端的每个写数据库的请求保存到文件，是一个持续增量的过程。

AOF实现
AOF持久化分三步走，命令追加，文件写入，文件同步。
命令追加
当AOF功能打开是，Redis会维护一个aof_buffer的缓冲区，用来存放未保存到AOF文件中的写数据库的命令。比如客户端执行了如下的命令:
```
redis> set message "hello world"
OK

redis> rpush books "redis in action" "netty in action"
(integer) 3
```
Redis服务器在执行完指令后，会按照Redis的协议格式，将命令添加到服务器aof_buffer的尾部。

文件写入与同步
Redis服务器进程其实就是一个时间循环，在一次循环中会处理文件事件以及时间事件。文件事件指的是接收网络请求和响应。而时间事件处理的是serverCron之类的定时任务。由于在文件事件处理时会将执行的写命令追加到aof_buffer缓冲区的尾部，所以服务器在结束时间循环之前，调用flushAppendOnlyFile函数来检查是否需要将缓冲区中的内容写入和保存到AOF文件中。

下面是时间循环的伪代码，在一次循环结束之前，flushAppendOnlyFile会被调用:

```
def evenloop():
    # 处理文件事件，将写数据库的请求写入
    # aof缓冲区
    processFileEvents()
    processTimeEvents()
    
    # 调用flushAppendOnlyFile检查是否需要
    # 将缓冲区文件写入aof文件
    flushAppendOnlyFile()
 ```

Redis可以通过配置appendfsync来选择flushAppendOnlyFile的行为:

appendfsync	flushAppendOnlyFile的行为
always	将aof缓冲区中的文件都刷入aof文件
everysec	将缓冲区中的内容写入到AOF文件，每秒钟执行一次同步文件操作，同步的操作由一个线程负责
no	将AOF缓冲区的内容写入AOF文件，但是不去进行同步操作，让操作系统来选择合适进行文件同步
在不配置appendfsync的情况下，Redis会使用everysec作为aof写入和同步的选项。至于三种选项的优劣，结合具体的场景进行选择:

策略	Pros	Cons
always	aof和内存内容一致，数据安全性最高	每次都要同步，效率最低
everysec	效率足够高，宕机丢失的最多1秒钟数据	宕机有可能丢一秒的数据
no	不会有额外的系统调用和开销，写入效率最高	缓冲区会积累一段时间才同步文件，宕机时会丢数据的概率较大
AOF重写
由于AOF是持续写日志的方式来进行备份的，当时间久了之后，AOF文件内容会越来越大。同时，在AOF中会存在很多无用的操作，比如过期了的key，元素全部被删除了的key等。

```
127.0.0.1:6379> rpush queue A
(integer) 1
127.0.0.1:6379> rpush queue hello
(integer) 2
127.0.0.1:6379> rpush queue day two one
(integer) 5
127.0.0.1:6379> lpop queue
"A"
127.0.0.1:6379> lpop queue
"hello"
```
AOF在保存上面这段指令执行需要保存5条记录。

为了解决Redis AOF空间膨胀的问题，Redis为AOF设计了AOF重写机制。在AOF重写会创建一个新的AOF文件来代替老的AOF文件，新的AOF保存的Redis状态和老的Redis一样，但是存储空间比老的AOF要小得多。因为AOF中不会保存任何冗余的命令。

虽然名字叫做AOF重写，但是整个重写过程中并不会对老的文件有任何的读操作。其实AOF重写做的事情是将内存中的key-value遍历一遍，将value读取出来，然后用一条等效的命令来记录对应的键值对，将这个心的命令写入新的AOF文件。

就比如刚才代码中的命令，这时候内存中的队列queue中存储的内容是”day”,”two”,”one”, 等效的命令就是:


rpush day two one
多以，在新的AOF文件中只需要这一条命令。

实际上，并不是所有的键值对重写之后都只有一条命令。如果一个键对应的值很多，如果只存一条命令，就需要把所有的Value都读到缓冲区，这很可能造成缓冲区溢出。所以Redis对list，hash，set，zset这些数据结构重写时，为了防止缓冲区溢出，如果数量超过一定的阈值，会使用多条记录来进行重写。

Redis提供了berewriteaof命令来调度后台AOF重写。后台AOF重写和后台RDB一样，都是通过子进程来实现的。在子进程进行AOF重写的过程中，父进程可以继续响应客户端的请求。那么如果在子进程重写AOF的过程中，父进程收到了写数据库的请求，就会导致AOF重写后的文件落后于父进程中的数据状态。为了解决这个问题，Redis设计重写AOF重写缓冲区，这个缓冲区在后台AOF重写启动的时候被激活，在子进程重写过程中父进程对内存的修改会将对应的命令写到AOF重写缓冲区。

子进程重写完成后，会发信号给父进程，父进程收到该信号后，会调用一个信号函数，这个信号函数会阻塞父进程，并将AOF重写缓冲区中的内容写到新的AOF文件中去，这样重写过的AOF文件就能包含重写过程中的修改了。整个重写过程之后最后的信号函数会阻塞，这样就将重写对服务器的影响降到了最低。





## 面试题
redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？

## 面试官心理分析
redis 如果仅仅只是将数据缓存在内存里面，如果 redis 宕机了再重启，内存里的数据就全部都弄丢了啊。你必须得用 redis 的持久化机制，将数据写入内存的同时，异步的慢慢的将数据写入磁盘文件里，进行持久化。

如果 redis 宕机重启，自动从磁盘上加载之前持久化的一些数据就可以了，也许会丢失少许数据，但是至少不会将所有数据都弄丢。

这个其实一样，针对的都是 redis 的生产环境可能遇到的一些问题，就是 redis 要是挂了再重启，内存里的数据不就全丢了？能不能重启的时候把数据给恢复了？

## 面试题剖析
持久化主要是做灾难恢复、数据恢复，也可以归类到高可用的一个环节中去，比如你 redis 整个挂了，然后 redis 就不可用了，你要做的事情就是让 redis 变得可用，尽快变得可用。

重启 redis，尽快让它对外提供服务，如果没做数据备份，这时候 redis 启动了，也不可用啊，数据都没了。

很可能说，大量的请求过来，缓存全部无法命中，在 redis 里根本找不到数据，这个时候就死定了，出现**缓存雪崩**问题。所有请求没有在 redis 命中，就会去 mysql 数据库这种数据源头中去找，一下子 mysql 承接高并发，然后就挂了...

如果你把 redis 持久化做好，备份和恢复方案做到企业级的程度，那么即使你的 redis 故障了，也可以通过备份数据，快速恢复，一旦恢复立即对外提供服务。

### redis 持久化的两种方式
- RDB：RDB 持久化机制，是对 redis 中的数据执行**周期性**的持久化。
- AOF：AOF 机制对每条写入命令作为日志，以 `append-only` 的模式写入一个日志文件中，在 redis 重启的时候，可以通过**回放** AOF 日志中的写入指令来重新构建整个数据集。

通过 RDB 或 AOF，都可以将 redis 内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云等云服务。

如果 redis 挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动 redis，redis 就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。

如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 **AOF** 来重新构建数据，因为 AOF 中的**数据更加完整**。

#### RDB 优缺点
- RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，**非常适合做冷备**，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。
- RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis **保持高性能**，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。
- 相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。

- 如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。
- RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。

#### AOF 优缺点
- AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次`fsync`操作，最多丢失 1 秒钟的数据。
- AOF 日志文件以 `append-only` 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。
- AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 `rewrite` log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。
- AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常**适合做灾难性的误删除的紧急恢复**。比如某人不小心用 `flushall` 命令清空了所有数据，只要这个时候后台 `rewrite` 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 `flushall` 命令给删了，然后再将该 `AOF` 文件放回去，就可以通过恢复机制，自动恢复所有数据。
- 对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。
- AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 `fsync` 一次日志文件，当然，每秒一次 `fsync`，性能也还是很高的。（如果实时写入，那么 QPS 会大降，redis 性能会大大降低）
- 以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 / merge / 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是**基于当时内存中的数据进行指令的重新构建**，这样健壮性会好很多。

另外一种更精致的解释：

- RDB 是一个紧凑压缩的二进制文件，代表 Redis 在某个时间点上的数据备份。非常适合备份，全量复制等场景。比如每6小时执行 bgsave 备份，并把 RDB 文件拷贝到远程机器或者文件系统中，用于灾难恢复。
- Redis 加载 RDB 恢复数据远远快于 AOF 的方式
- RDB 方式数据没办法做到实时持久化，而 AOF 方式可以做到。

### RDB 和 AOF 到底该如何选择
- 不要仅仅使用 RDB，因为那样会导致你丢失很多数据；
- 也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug；
- redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。

### AOF过程

原文地址：https://juejin.im/post/5d405370e51d4561fa2ebfe8

AOF 持久化功能的实现可以分为命令追加( append )、文件写入( write )、文件同步( sync )、文件重写(rewrite)和重启加载(load)。其流程如下：

- 所有的写命令会追加到 AOF 缓冲中。
- AOF 缓冲区根据对应的策略向硬盘进行同步操作。
- 随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。
- 当 Redis 重启时，可以加载 AOF 文件进行数据恢复。

命令追加：当AOF持久化功能处于打开状态时，Redis在执行完一个写命令之后，会以协议格式(也就是RESP，即Redis客户端和服务器交互的通信协议)将被执行的写命令追加到Redis 服务端维护的AOF缓冲区末尾。

文件写入和同步：Redis每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，判断是否需要将AOF缓存区中的内容写入和同步到AOF文件中。

AOF数据恢复：AOF文件里边包含了重建Redis数据所需的所有写命令，所以 Redis 只要读入并重新执行一遍 AOF 文件里边保存的写命令，就可以还原 Redis 关闭之前的状态。

### AOF重写

AOF 文件重写并不需要对现有的 AOF 文件进行任何读取、分析或者写入操作，而是通过读取服务器当前的数据库状态来实现的。首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是 AOF 重写功能的实现原理。

rewrite的触发机制主要有一下三个：

- 手动调用 bgrewriteaof 命令，如果当前有正在运行的 rewrite 子进程，则本次rewrite 会推迟执行，否则，直接触发一次 rewrite。
- 通过配置指令手动开启 AOF 功能，如果没有 RDB 子进程的情况下，会触发一次 rewrite，将当前数据库中的数据写入 rewrite 文件。
- 在 Redis 定时器中，如果有需要退出执行的 rewrite 并且没有正在运行的 RDB 或者 rewrite 子进程时，触发一次或者 AOF 文件大小已经到达配置的 rewrite 条件也会自动触发一次。

AOF 重写函数会进行大量的写入操作，调用该函数的线程将被长时间阻塞，所以 Redis 在子进程中执行 AOF 重写操作。

- 子进程进行 AOF 重写期间，Redis 进程可以继续处理客户端命令请求。
- 子进程带有父进程的内存数据拷贝副本，在不适用锁的情况下，也可以保证数据的安全性。

### RDB触发命令

原文地址：https://mp.weixin.qq.com/s/NpUV-7bvXTD3iu0_2aRssQ

- save ，该指令会阻塞当前 Redis 服务器，执行 save 指令期间，Redis 不能处理其他命令，直到 RDB 过程完成为止。

- bgsave，执行该命令时，Redis 会在后台异步执行快照操作，此时 Redis 仍然可以相应客户端请求。具体操作是 Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。Redis 只会在 fork 期间发生阻塞，但是一般时间都很短。但是如果 Redis 数据量特别大， fork 时间就会变长，而且占用内存会加倍，这一点需要特别注意。

### redis使用的协议

Redis基于RESP(Redis Serialization Protocol)协议来通信，并且通信方式是停等模型，也就说一次通信独占一个连接直到client读取到返回结果之后才能释放该连接让其他线程使用。

一般情况下，RESP是一种简单的请求-响应式协议。二般情况是：

- Redis支持管道，所以有可能一次发送多个命令，然后一起响应
- 如果Redis客户端订阅了Pub/Sub频道，那么协议就会变成一种推送协议，当服务器接收到新的数据时会自动推送给客户端





