原文地址：

https://blog.csdn.net/y4x5M0nivSrJaY3X92c/article/details/89325158

https://www.go2live.cn/nocate/%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%9C%9F%E5%AE%9E%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F-id-%E6%A1%88%E4%BE%8B%E7%9C%8B%E5%A6%82%E4%BD%95%E5%81%9A%E6%9E%B6%E6%9E%84.html

对于系统中的一组数据而言，必不可少地对应有唯一标识。简单的单体应用可以使用数据库的自增 ID 作为唯一标识。而在复杂的分布式系统中，就需要一些特定的策略去生成对应的分布式 ID。

常见的项目中 ID 会有以下两个特点：

1、全局唯一性。

2、趋势递增（对于使用 MySQL 的项目而言）。

因为一般 ID 会作为数据库的主键存储，而在 MySQL InnoDB 中使用的是聚簇索引，使用有序的 ID 可以保证写入性能。一般在分布式系统中，会有一个单独的服务来生成 ID。而这个服务则需要保证高可用性、高QPS 与安全性。另外生成的 ID 是不应该对外暴露的，如果非要对外展示，最好是无规则、不规律的编码。如果不依赖机器什么的话，而是依赖第三方，比如mysql,zk，或者redis就必须要保证高可用，或者做好降级策略


### UUID（机器的网卡+当前时间+一个随机数）

UUID (Universally Unique Identifier) 生成的是一个长度为 32 的 16 进制格式的字符串。UUID 有多个版本，各版本算法不同。但核心思想是一致的，基本上都是结合机器的网卡、当前时间、一个随机数来生成特定长度的字符串。

优点：性能好、高可扩展性：本地生成，无网络消耗，不需要考虑性能瓶颈。

缺点：

1、无法保证趋势递增。

2、UUID 过长，如果需要在数据库存储，作为主键建立索引效率低。

适用场景：不需要考虑空间占用，不需要生成有递增趋势，且不在 MySQL 中存储。

### 数据库

结合数据库维护一个Sequence表，每当需要为某个表的新纪录生成ID时就从Sequence表中取出对应的nextid,将其+1后更新到数据库中以备下次使用。
由于所有的插入都要访问该表，很容易造成性能瓶颈，且存在单点问题，如果该表所在的数据库失效，全部应用无法工作。
在高并发场景下，无法保证高性能。

### Snowflake

snowflake 是 Twitter 开源的一个 ID 生成算法。

1、首位符号位：因为 ID 一般为正数，该值为 0。

2、41 位时间戳（毫秒级）：

3、时间戳不是当前时间的时间戳，而是存储时间戳的差值（当前时间戳 - 起始时间戳（起始时间戳需要程序指定））理论上可以最多使用 (1 << 41) / (1000x60x60x24x365) = 69年。

4、10 位数据机器位：包括 5 位数据标识位和 5 位机器标识位，也就是说最多可以部署节点数为：1 << 10 = 1024。

5、12 位毫秒内的序列：同一节点、同一时刻最多生成 ID 数 1 << 12 = 4096。

6、最后生成结果为 64 位 Long 型数值。

优点：

1、趋势递增，且按照时间有序。

2、性能高、稳定性高、不依赖数据库等第三方系统。

3、可以按照自身业务特性灵活分配 bit 位。

缺点：依赖于机器时钟，时钟回拨会造成暂不可用或重复发号。

### 实战方案选型

对于分布式下的全局ID需要具备如下特点：

1、全局唯一，区别于单机唯一，需要保证集群中的每台机器生成的ID都是不一样的，不能存在重复

2、顺序性，生成的全局ID，需要能够有序递增

3、区间约束：生成的全局ID需要满足业务规则，如：每家店每天生成的ID区间在1-999

4、性能要求：需要考虑门店数量较大情况下（如超过1万家）并发访问带来的性能问题

以上，完成业务架构梳理后，接下来需要看下如何实现，这就涉及到了技术架构。

1、使用数据库：自增主键

2、使用Redis实现：incr命令

3、使用zookeeper实现：有序节点

4、使用mongoDB实现：ObjectId

5、使用业界流行的开源框架实现

Twitter开源的Snowflake方案

微信的seqsvr

百度的UidGenerator

美团的Leaf




