{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{448:function(e,t,s){\"use strict\";s.r(t);var r=s(13),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[s(\"p\",[e._v(\"原文地址：\")]),e._v(\" \"),s(\"p\",[e._v(\"https://blog.csdn.net/my_tiantian/article/details/84333716\")]),e._v(\" \"),s(\"h3\",{attrs:{id:\"内存碎片率高的原因\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#内存碎片率高的原因\"}},[e._v(\"#\")]),e._v(\" 内存碎片率高的原因\")]),e._v(\" \"),s(\"p\",[e._v(\"1、遇到变长key-value负载：存储的数据长短差异较大，频繁更新，redis的每个k-v对初始化的内存大小是最适合的，当修改的value改变的并且原来内存大小不适用的时候，就需要重新分配内存。重新分配之后，就会有一部分内存redis无法正常回收，一直占用着。\")]),e._v(\" \"),s(\"p\",[e._v(\"2、maxmemory限制导致key被回收删除\\nredis写入大量数据，这些数据的key和原来的数据很多不一致，数据超过maxmemory限制后redis会通过key的回收策略将部分旧数据淘汰，而被淘汰的数据本身占用的内存却没有被redis进程释放，导致redis内存的有效数据虽然没有超过最大内存，但是整个进程的内存在一直增长\\ninfo信息中的evicted_keys字段显示的是，因为maxmemory限制导致key被回收删除的数量\\nkey经常需要回收，会使客户端命令响应延迟时间增加，因为Redis不但要处理客户端过来的命令请求，还要频繁的回收满足条件的key\")]),e._v(\" \"),s(\"h3\",{attrs:{id:\"解决方法\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#解决方法\"}},[e._v(\"#\")]),e._v(\" 解决方法\")]),e._v(\" \"),s(\"p\",[e._v(\"1、限制内存交换： 如果内存碎片率低于1，Redis实例可能会把部分数据交换到硬盘上，应该增加可用物理内存或减少实Redis内存占用，设置maxmemory和回收策略可以避免强制内存交换\")]),e._v(\" \"),s(\"p\",[e._v(\"2、重启Redis服务器：如果内存碎片率超过1.5，重启Redis服务器可以让额外产生的内存碎片失效并重新作为新内存来使用，使操作系统恢复高效的内存管理。额外碎片的产生是由于Redis释放了内存块，但内存分配器并没有返回内存给操作系统\")]),e._v(\" \"),s(\"p\",[e._v(\"3、内存碎片清理：\")]),e._v(\" \"),s(\"p\",[e._v(\"A、Redis 4.0-RC3 以上版本，使用jemalloc作为内存分配器(默认的) 支持内存碎片清理支持在运行期进行自动内存碎片清理，设置自动清理 config set activedefrag yes，使用config rewrite 将redis内存中新配置刷新到配置文件\")]),e._v(\" \"),s(\"p\",[e._v(\"B、支持通过命令 memory purge 进行手动清理(与自动清理区域不同)\")])])}),[],!1,null,null,null);t.default=a.exports}}]);","extractedComments":[]}