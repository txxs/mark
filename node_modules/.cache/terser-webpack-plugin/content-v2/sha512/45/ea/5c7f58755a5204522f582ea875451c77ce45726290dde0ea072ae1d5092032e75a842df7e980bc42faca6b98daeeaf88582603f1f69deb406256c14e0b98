{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{436:function(t,e,s){\"use strict\";s.r(e);var a=s(13),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[s(\"p\",[t._v(\"原文地址：\")]),t._v(\" \"),s(\"p\",[t._v(\"https://www.javazhiyin.com/31557.html\")]),t._v(\" \"),s(\"p\",[t._v(\"总体是代理的方式实现的，proxy\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"如何实现客户端分片-应该就是这种\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何实现客户端分片-应该就是这种\"}},[t._v(\"#\")]),t._v(\" 如何实现客户端分片（应该就是这种）\")]),t._v(\" \"),s(\"p\",[t._v(\"客户端需要定制 JDBC 协议，在拿到待执行的 sql 后，解析 sql，根据查询条件判断是否存在分片字段。如果存在，再根据分片算法获取到对应的数据库实例和物理表名，重写 sql，然后找到对应的数据库 datasource 并获取物理连接，执行 sql，将结果集进行合并筛选后返回。如果没有分片字段，则需要查询所有的表，注意，即使存在分片字段，但是分片字段在一个范围内，可能也需要查询多个表，针对 select 以外的 sql 如果没有传分片字段建议直接抛出异常。\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"sql解析\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sql解析\"}},[t._v(\"#\")]),t._v(\" SQL解析\")]),t._v(\" \"),s(\"p\",[t._v(\"解析出 sql 类型，目前生成环境主要还是4中 sql 类型： SELECT DELETE UPDATE INSERT ，目前是直接解析 sql 是否以上面4个单词开头即可，不区分大小写。\")]),t._v(\" \"),s(\"h4\",{attrs:{id:\"insert\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#insert\"}},[t._v(\"#\")]),t._v(\" insert\")]),t._v(\" \"),s(\"p\",[t._v(\"类型需要区分，是否是批量插入，解析出 insert 插入的列的字段名称和对应的值，如果插入的列中不包含分片字段，将无法定位到具体插入到哪个物理表，此时应该抛出异常。\")]),t._v(\" \"),s(\"h4\",{attrs:{id:\"delete-和-update\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#delete-和-update\"}},[t._v(\"#\")]),t._v(\" delete 和 update\")]),t._v(\" \"),s(\"p\",[t._v(\"delete 和 update 都需要解析 where 后的条件，根据查询条件里的字段，尝试路由到指定的物理表，注意此时可能会出现 where 条件里面 分片字段可能是一个范围，或者分片字段存在多个限制。\")]),t._v(\" \"),s(\"h4\",{attrs:{id:\"select\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#select\"}},[t._v(\"#\")]),t._v(\" select\")]),t._v(\" \"),s(\"p\",[t._v(\"select 和其他类型不同的是，返回结果是一个 list，而其他三种 sql 直接返回状态和影响行数即可。同时 select 可能出现关联查询，以及针对查询结果进行筛选的操作，例如where 条件中除了普通的判断表达式，还可能存在 limit，order by，group by，having等，select 的结果中也可能包含聚合统计等信息，例如 sum，count，max，min，avg等，这些都需要解析出来方便后续结果集的处理，后续重新生成 sql 主要是替换逻辑表名为物理表名，并获取对应的数据库物理连接。\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"分片路由算法\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分片路由算法\"}},[t._v(\"#\")]),t._v(\" 分片路由算法\")]),t._v(\" \"),s(\"p\",[t._v(\"分片算法，主要通过一个表达式，从分片字段对应的值获取到分片结果，可以提供简单地EL表达式，就可以实现从值中截取某一段作为分表数据，也可以提供通用的一致性哈希算法的实现，应用方只需要在 xml 或者注解中配置即可，以下为一致性哈希在铜板街的实现。\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"结果合并\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#结果合并\"}},[t._v(\"#\")]),t._v(\" 结果合并\")]),t._v(\" \"),s(\"p\",[t._v(\"如果需要在多个物理表上执行查询，则需要对结果集进行合并处理，此处需要注意返回是一个迭代器 resultset。统计类 针对 sum count，max，min 只需要将每个结果集的返回结果在做一个 max 和min，count 和 sum 直接相加即可，针对 avg 需要通过上面改写的 sql 获取 sum 和count 然后相除计算平均值。例如分库算法用“用户id%64 分64个库” 分表算法也用 “用户id%64 分64张表”，总计 64 * 64 张表，最终数据都将落在 以下 64张表中 00库00表，01库01表… 63库63表， 其他 64 * 63张表则没有数据。这里可以推荐一个算法，分库用 用户ID/64 % 64 , 分表用 用户ID%64 测试1亿笔用户id发现分布均匀。\")])])}),[],!1,null,null,null);e.default=r.exports}}]);","extractedComments":[]}