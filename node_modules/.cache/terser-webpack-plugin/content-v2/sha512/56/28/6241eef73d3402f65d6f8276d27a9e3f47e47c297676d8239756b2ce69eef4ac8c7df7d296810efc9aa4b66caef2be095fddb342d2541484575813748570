{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[159],{546:function(n,t,r){\"use strict\";r.r(t);var e=r(13),a=Object(e.a)({},(function(){var n=this,t=n.$createElement,r=n._self._c||t;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[r(\"ul\",[r(\"li\",[r(\"a\",{attrs:{href:\"#%E4%BB%80%E4%B9%88%E6%98%AF-spring-%E6%A1%86%E6%9E%B6\"}},[n._v(\"什么是 Spring 框架?\")])]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"#%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84spring%E6%A8%A1%E5%9D%97\"}},[n._v(\"列举一些重要的Spring模块？\")])]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"#%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-spring-ioc-%E5%92%8C-aop-%E7%9A%84%E7%90%86%E8%A7%A3\"}},[n._v(\"谈谈自己对于 Spring IoC 和 AOP 的理解\")])]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"#spring-aop-%E5%92%8C-aspectj-aop-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"}},[n._v(\"Spring AOP 和 AspectJ AOP 有什么区别？\")])]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"#spring-%E4%B8%AD%E7%9A%84-bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B\"}},[n._v(\"Spring 中的 bean 的作用域有哪些?\")])]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"#spring-%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B-bean-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%90%97\"}},[n._v(\"Spring 中的单例 bean 的线程安全问题了解吗？\")])]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"#spring-%E4%B8%AD%E7%9A%84-bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"}},[n._v(\"Spring 中的 bean 生命周期?\")])]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"#%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-spring-mvc-%E4%BA%86%E8%A7%A3\"}},[n._v(\"说说自己对于 Spring MVC 了解?\")])]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"#springmvc-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97\"}},[n._v(\"SpringMVC 工作原理了解吗?\")])]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"#spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"}},[n._v(\"Spring 框架中用到了哪些设计模式？\")])]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"#component-%E5%92%8C-bean-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88\"}},[n._v(\"@Component 和 @Bean 的区别是什么？\")])]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"#%E5%B0%86%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%A3%B0%E6%98%8E%E4%B8%BAspring%E7%9A%84-bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B\"}},[n._v(\"将一个类声明为Spring的 bean 的注解有哪些?\")])]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"#spring-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D\"}},[n._v(\"Spring 管理事务的方式有几种？\")])]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"#spring-%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D\"}},[n._v(\"Spring 事务中的隔离级别有哪几种?\")])]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"#spring-%E4%BA%8B%E5%8A%A1%E4%B8%AD%E5%93%AA%E5%87%A0%E7%A7%8D%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA\"}},[n._v(\"Spring 事务中哪几种事务传播行为?\")])]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"#%E5%8F%82%E8%80%83\"}},[n._v(\"参考\")])])]),n._v(\" \"),r(\"p\",[n._v(\"这篇文章主要是想通过一些问题，加深大家对于 Spring 的理解，所以不会涉及太多的代码！这篇文章整理了挺长时间，下面的很多问题我自己在使用 Spring 的过程中也并没有注意，自己也是临时查阅了很多资料和书籍补上的。网上也有一些很多关于 Spring 常见问题/面试题整理的文章，我感觉大部分都是互相 copy，而且很多问题也不是很汗，有些回答也存在问题。所以，自己花了一周的业余时间整理了一下，希望对大家有帮助。\")]),n._v(\" \"),r(\"h2\",{attrs:{id:\"什么是-spring-框架\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是-spring-框架\"}},[n._v(\"#\")]),n._v(\" 什么是 Spring 框架?\")]),n._v(\" \"),r(\"p\",[n._v(\"Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。Spring 官网：\"),r(\"a\",{attrs:{href:\"https://spring.io/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"https://spring.io/\"),r(\"OutboundLink\")],1),n._v(\"。\")]),n._v(\" \"),r(\"p\",[n._v(\"我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。\")]),n._v(\" \"),r(\"p\",[n._v(\"Spring 官网列出的 Spring 的 6 个特征:\")]),n._v(\" \"),r(\"ul\",[r(\"li\",[r(\"strong\",[n._v(\"核心技术\")]),n._v(\" ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"测试\")]),n._v(\" ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"数据访问\")]),n._v(\" ：事务，DAO支持，JDBC，ORM，编组XML。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"Web支持\")]),n._v(\" : Spring MVC和Spring WebFlux Web框架。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"集成\")]),n._v(\" ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"语言\")]),n._v(\" ：Kotlin，Groovy，动态语言。\")])]),n._v(\" \"),r(\"h2\",{attrs:{id:\"列举一些重要的spring模块\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#列举一些重要的spring模块\"}},[n._v(\"#\")]),n._v(\" 列举一些重要的Spring模块？\")]),n._v(\" \"),r(\"p\",[n._v(\"下图对应的是 Spring4.x 版本。目前最新的5.x版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。\")]),n._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Spring%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9D%97.png\",alt:\"Spring主要模块\"}})]),n._v(\" \"),r(\"ul\",[r(\"li\",[r(\"strong\",[n._v(\"Spring Core：\")]),n._v(\" 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"Spring  Aspects\")]),n._v(\" ： 该模块为与AspectJ的集成提供支持。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"Spring AOP\")]),n._v(\" ：提供了面向切面的编程实现。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"Spring JDBC\")]),n._v(\" : Java数据库连接。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"Spring JMS\")]),n._v(\" ：Java消息服务。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"Spring ORM\")]),n._v(\" : 用于支持Hibernate等ORM工具。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"Spring Web\")]),n._v(\" : 为创建Web应用程序提供支持。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"Spring Test\")]),n._v(\" : 提供了对 JUnit 和 TestNG 测试的支持。\")])]),n._v(\" \"),r(\"h2\",{attrs:{id:\"谈谈自己对于-spring-ioc-和-aop-的理解\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#谈谈自己对于-spring-ioc-和-aop-的理解\"}},[n._v(\"#\")]),n._v(\" 谈谈自己对于 Spring IoC 和 AOP 的理解\")]),n._v(\" \"),r(\"h3\",{attrs:{id:\"ioc\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ioc\"}},[n._v(\"#\")]),n._v(\" IoC\")]),n._v(\" \"),r(\"p\",[n._v(\"IoC（Inverse of Control:控制反转）是一种\"),r(\"strong\",[n._v(\"设计思想\")]),n._v(\"，就是 \"),r(\"strong\",[n._v(\"将原本在程序中手动创建对象的控制权，交由Spring框架来管理。\")]),n._v(\"  IoC 在其他语言中也有应用，并非 Spirng 特有。 \"),r(\"strong\",[n._v(\"IoC 容器是 Spring 用来实现 IoC 的载体，  IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。\")])]),n._v(\" \"),r(\"p\",[n._v(\"将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。  \"),r(\"strong\",[n._v(\"IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。\")]),n._v(\" 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。\")]),n._v(\" \"),r(\"p\",[n._v(\"Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。\")]),n._v(\" \"),r(\"p\",[n._v(\"推荐阅读：https://www.zhihu.com/question/23277575/answer/169698662\")]),n._v(\" \"),r(\"p\",[r(\"strong\",[n._v(\"Spring IoC的初始化过程：\")]),n._v(\" \"),r(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/9/22/165fea36b569d4f4?w=709&h=56&f=png&s=4673\",alt:\"Spring IoC的初始化过程\"}})]),n._v(\" \"),r(\"p\",[n._v(\"IoC源码阅读\")]),n._v(\" \"),r(\"ul\",[r(\"li\",[n._v(\"https://javadoop.com/post/spring-ioc\")])]),n._v(\" \"),r(\"h3\",{attrs:{id:\"aop\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#aop\"}},[n._v(\"#\")]),n._v(\" AOP\")]),n._v(\" \"),r(\"p\",[n._v(\"AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，\"),r(\"strong\",[n._v(\"却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来\")]),n._v(\"，便于\"),r(\"strong\",[n._v(\"减少系统的重复代码\")]),n._v(\"，\"),r(\"strong\",[n._v(\"降低模块间的耦合度\")]),n._v(\"，并\"),r(\"strong\",[n._v(\"有利于未来的可拓展性和可维护性\")]),n._v(\"。\")]),n._v(\" \"),r(\"p\",[r(\"strong\",[n._v(\"Spring AOP就是基于动态代理的\")]),n._v(\"，如果要代理的对象，实现了某个接口，那么Spring AOP会使用\"),r(\"strong\",[n._v(\"JDK Proxy\")]),n._v(\"，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用\"),r(\"strong\",[n._v(\"Cglib\")]),n._v(\" ，这时候Spring AOP会使用 \"),r(\"strong\",[n._v(\"Cglib\")]),n._v(\" 生成一个被代理对象的子类来作为代理，如下图所示：\")]),n._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/SpringAOPProcess.jpg\",alt:\"SpringAOPProcess\"}})]),n._v(\" \"),r(\"p\",[n._v(\"当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。\")]),n._v(\" \"),r(\"p\",[n._v(\"使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。\")]),n._v(\" \"),r(\"h2\",{attrs:{id:\"spring-aop-和-aspectj-aop-有什么区别\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#spring-aop-和-aspectj-aop-有什么区别\"}},[n._v(\"#\")]),n._v(\" Spring AOP 和 AspectJ AOP 有什么区别？\")]),n._v(\" \"),r(\"p\",[r(\"strong\",[n._v(\"Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。\")]),n._v(\" Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。\")]),n._v(\" \"),r(\"p\",[n._v(\"Spring AOP 已经集成了 AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ  相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，\")]),n._v(\" \"),r(\"p\",[n._v(\"如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。\")]),n._v(\" \"),r(\"h2\",{attrs:{id:\"spring-中的-bean-的作用域有哪些\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#spring-中的-bean-的作用域有哪些\"}},[n._v(\"#\")]),n._v(\" Spring 中的 bean 的作用域有哪些?\")]),n._v(\" \"),r(\"ul\",[r(\"li\",[n._v(\"singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。\")]),n._v(\" \"),r(\"li\",[n._v(\"prototype : 每次请求都会创建一个新的 bean 实例。\")]),n._v(\" \"),r(\"li\",[n._v(\"request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。\")]),n._v(\" \"),r(\"li\",[n._v(\"session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。\")]),n._v(\" \"),r(\"li\",[n._v(\"global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话\")])]),n._v(\" \"),r(\"h2\",{attrs:{id:\"spring-中的单例-bean-的线程安全问题了解吗\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#spring-中的单例-bean-的线程安全问题了解吗\"}},[n._v(\"#\")]),n._v(\" Spring 中的单例 bean 的线程安全问题了解吗？\")]),n._v(\" \"),r(\"p\",[n._v(\"大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。\")]),n._v(\" \"),r(\"p\",[n._v(\"常见的有两种解决办法：\")]),n._v(\" \"),r(\"ol\",[r(\"li\",[r(\"p\",[n._v(\"在Bean对象中尽量避免定义可变的成员变量（不太现实）。\")])]),n._v(\" \"),r(\"li\",[r(\"p\",[n._v(\"在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。\")])])]),n._v(\" \"),r(\"h2\",{attrs:{id:\"spring-中的-bean-生命周期\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#spring-中的-bean-生命周期\"}},[n._v(\"#\")]),n._v(\" Spring 中的 bean 生命周期?\")]),n._v(\" \"),r(\"p\",[n._v(\"这部分网上有很多文章都讲到了，下面的内容整理自：\"),r(\"a\",{attrs:{href:\"https://yemengying.com/2016/07/14/spring-bean-life-cycle/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"https://yemengying.com/2016/07/14/spring-bean-life-cycle/\"),r(\"OutboundLink\")],1),n._v(\" ，除了这篇文章，再推荐一篇很不错的文章 ：\"),r(\"a\",{attrs:{href:\"https://www.cnblogs.com/zrtqsk/p/3735273.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"https://www.cnblogs.com/zrtqsk/p/3735273.html\"),r(\"OutboundLink\")],1),n._v(\" 。\")]),n._v(\" \"),r(\"ul\",[r(\"li\",[n._v(\"Bean 容器找到配置文件中 Spring Bean 的定义。\")]),n._v(\" \"),r(\"li\",[n._v(\"Bean 容器利用 Java Reflection API 创建一个Bean的实例。\")]),n._v(\" \"),r(\"li\",[n._v(\"如果涉及到一些属性值 利用 \"),r(\"code\",[n._v(\"set()\")]),n._v(\"方法设置一些属性值。\")]),n._v(\" \"),r(\"li\",[n._v(\"如果 Bean 实现了 \"),r(\"code\",[n._v(\"BeanNameAware\")]),n._v(\" 接口，调用 \"),r(\"code\",[n._v(\"setBeanName()\")]),n._v(\"方法，传入Bean的名字。\")]),n._v(\" \"),r(\"li\",[n._v(\"如果 Bean 实现了 \"),r(\"code\",[n._v(\"BeanClassLoaderAware\")]),n._v(\" 接口，调用 \"),r(\"code\",[n._v(\"setBeanClassLoader()\")]),n._v(\"方法，传入 \"),r(\"code\",[n._v(\"ClassLoader\")]),n._v(\"对象的实例。\")]),n._v(\" \"),r(\"li\",[n._v(\"如果Bean实现了 \"),r(\"code\",[n._v(\"BeanFactoryAware\")]),n._v(\" 接口，调用 \"),r(\"code\",[n._v(\"setBeanClassLoader()\")]),n._v(\"方法，传入 \"),r(\"code\",[n._v(\"ClassLoade\")]),n._v(\" r对象的实例。\")]),n._v(\" \"),r(\"li\",[n._v(\"与上面的类似，如果实现了其他 \"),r(\"code\",[n._v(\"*.Aware\")]),n._v(\"接口，就调用相应的方法。\")]),n._v(\" \"),r(\"li\",[n._v(\"如果有和加载这个 Bean 的 Spring 容器相关的 \"),r(\"code\",[n._v(\"BeanPostProcessor\")]),n._v(\" 对象，执行\"),r(\"code\",[n._v(\"postProcessBeforeInitialization()\")]),n._v(\" 方法\")]),n._v(\" \"),r(\"li\",[n._v(\"如果Bean实现了\"),r(\"code\",[n._v(\"InitializingBean\")]),n._v(\"接口，执行\"),r(\"code\",[n._v(\"afterPropertiesSet()\")]),n._v(\"方法。\")]),n._v(\" \"),r(\"li\",[n._v(\"如果 Bean 在配置文件中的定义包含  init-method 属性，执行指定的方法。\")]),n._v(\" \"),r(\"li\",[n._v(\"如果有和加载这个 Bean的 Spring 容器相关的 \"),r(\"code\",[n._v(\"BeanPostProcessor\")]),n._v(\" 对象，执行\"),r(\"code\",[n._v(\"postProcessAfterInitialization()\")]),n._v(\" 方法\")]),n._v(\" \"),r(\"li\",[n._v(\"当要销毁 Bean 的时候，如果 Bean 实现了 \"),r(\"code\",[n._v(\"DisposableBean\")]),n._v(\" 接口，执行 \"),r(\"code\",[n._v(\"destroy()\")]),n._v(\" 方法。\")]),n._v(\" \"),r(\"li\",[n._v(\"当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。\")])]),n._v(\" \"),r(\"p\",[n._v(\"图示：\")]),n._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/48376272.jpg\",alt:\"Spring Bean 生命周期\"}})]),n._v(\" \"),r(\"p\",[n._v(\"与之比较类似的中文版本:\")]),n._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/5496407.jpg\",alt:\"Spring Bean 生命周期\"}})]),n._v(\" \"),r(\"h2\",{attrs:{id:\"说说自己对于-spring-mvc-了解\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#说说自己对于-spring-mvc-了解\"}},[n._v(\"#\")]),n._v(\" 说说自己对于 Spring MVC 了解?\")]),n._v(\" \"),r(\"p\",[n._v(\"谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代。\")]),n._v(\" \"),r(\"ul\",[r(\"li\",[r(\"strong\",[n._v(\"Model1 时代\")]),n._v(\" : 很多学 Java 后端比较晚的朋友可能并没有接触过  Model1 模式下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层又是表现层。显而易见，这种模式存在很多问题。比如①将控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；②前端和后端相互依赖，难以进行测试并且开发效率极低；\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"Model2 时代\")]),n._v(\" ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View,）+Servlet（Controller）  ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。Model:系统涉及的数据，也就是 dao 和 bean。View：展示模型中的数据，只是用来展示。Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。\")])]),n._v(\" \"),r(\"p\",[n._v(\"Model2 模式下还存在很多问题，Model2的抽象和封装程度还远远不够，使用Model2进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。于是很多JavaWeb开发相关的 MVC 框架营运而生比如Struts2，但是 Struts2 比较笨重。随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。\")]),n._v(\" \"),r(\"p\",[n._v(\"MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。\")]),n._v(\" \"),r(\"p\",[r(\"strong\",[n._v(\"Spring MVC 的简单原理图如下：\")])]),n._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/60679444.jpg\",alt:\"\"}})]),n._v(\" \"),r(\"h2\",{attrs:{id:\"springmvc-工作原理了解吗\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#springmvc-工作原理了解吗\"}},[n._v(\"#\")]),n._v(\" SpringMVC 工作原理了解吗?\")]),n._v(\" \"),r(\"p\",[r(\"strong\",[n._v(\"原理如下图所示：\")]),n._v(\" \"),r(\"img\",{attrs:{src:\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/49790288.jpg\",alt:\"SpringMVC运行原理\"}})]),n._v(\" \"),r(\"p\",[n._v(\"上图的一个笔误的小问题：Spring MVC 的入口函数也就是前端控制器 \"),r(\"code\",[n._v(\"DispatcherServlet\")]),n._v(\" 的作用是接收请求，响应结果。\")]),n._v(\" \"),r(\"p\",[r(\"strong\",[n._v(\"流程说明（重要）：\")])]),n._v(\" \"),r(\"ol\",[r(\"li\",[n._v(\"客户端（浏览器）发送请求，直接请求到 \"),r(\"code\",[n._v(\"DispatcherServlet\")]),n._v(\"。\")]),n._v(\" \"),r(\"li\",[r(\"code\",[n._v(\"DispatcherServlet\")]),n._v(\" 根据请求信息调用 \"),r(\"code\",[n._v(\"HandlerMapping\")]),n._v(\"，解析请求对应的 \"),r(\"code\",[n._v(\"Handler\")]),n._v(\"。\")]),n._v(\" \"),r(\"li\",[n._v(\"解析到对应的 \"),r(\"code\",[n._v(\"Handler\")]),n._v(\"（也就是我们平常说的 \"),r(\"code\",[n._v(\"Controller\")]),n._v(\" 控制器）后，开始由 \"),r(\"code\",[n._v(\"HandlerAdapter\")]),n._v(\" 适配器处理。\")]),n._v(\" \"),r(\"li\",[r(\"code\",[n._v(\"HandlerAdapter\")]),n._v(\" 会根据 \"),r(\"code\",[n._v(\"Handler\")]),n._v(\"来调用真正的处理器开处理请求，并处理相应的业务逻辑。\")]),n._v(\" \"),r(\"li\",[n._v(\"处理器处理完业务后，会返回一个 \"),r(\"code\",[n._v(\"ModelAndView\")]),n._v(\" 对象，\"),r(\"code\",[n._v(\"Model\")]),n._v(\" 是返回的数据对象，\"),r(\"code\",[n._v(\"View\")]),n._v(\" 是个逻辑上的 \"),r(\"code\",[n._v(\"View\")]),n._v(\"。\")]),n._v(\" \"),r(\"li\",[r(\"code\",[n._v(\"ViewResolver\")]),n._v(\" 会根据逻辑 \"),r(\"code\",[n._v(\"View\")]),n._v(\" 查找实际的 \"),r(\"code\",[n._v(\"View\")]),n._v(\"。\")]),n._v(\" \"),r(\"li\",[r(\"code\",[n._v(\"DispaterServlet\")]),n._v(\" 把返回的 \"),r(\"code\",[n._v(\"Model\")]),n._v(\" 传给 \"),r(\"code\",[n._v(\"View\")]),n._v(\"（视图渲染）。\")]),n._v(\" \"),r(\"li\",[n._v(\"把 \"),r(\"code\",[n._v(\"View\")]),n._v(\" 返回给请求者（浏览器）\")])]),n._v(\" \"),r(\"h2\",{attrs:{id:\"spring-框架中用到了哪些设计模式\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#spring-框架中用到了哪些设计模式\"}},[n._v(\"#\")]),n._v(\" Spring 框架中用到了哪些设计模式？\")]),n._v(\" \"),r(\"p\",[n._v(\"关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章\"),r(\"a\",{attrs:{href:\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN#rd\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"《面试官:“谈谈Spring中都用到了那些设计模式?”。》\"),r(\"OutboundLink\")],1),n._v(\" 。\")]),n._v(\" \"),r(\"ul\",[r(\"li\",[r(\"strong\",[n._v(\"工厂设计模式\")]),n._v(\" : Spring使用工厂模式通过 \"),r(\"code\",[n._v(\"BeanFactory\")]),n._v(\"、\"),r(\"code\",[n._v(\"ApplicationContext\")]),n._v(\" 创建 bean 对象。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"代理设计模式\")]),n._v(\" : Spring AOP 功能的实现。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"单例设计模式\")]),n._v(\" : Spring 中的 Bean 默认都是单例的。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"模板方法模式\")]),n._v(\" : Spring 中 \"),r(\"code\",[n._v(\"jdbcTemplate\")]),n._v(\"、\"),r(\"code\",[n._v(\"hibernateTemplate\")]),n._v(\" 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"包装器设计模式\")]),n._v(\" : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"观察者模式:\")]),n._v(\" Spring 事件驱动模型就是观察者模式很经典的一个应用。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"适配器模式\")]),n._v(\" :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配\"),r(\"code\",[n._v(\"Controller\")]),n._v(\"。\")]),n._v(\" \"),r(\"li\",[n._v(\"......\")])]),n._v(\" \"),r(\"h2\",{attrs:{id:\"component-和-bean-的区别是什么\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#component-和-bean-的区别是什么\"}},[n._v(\"#\")]),n._v(\" @Component 和 @Bean 的区别是什么？\")]),n._v(\" \"),r(\"ol\",[r(\"li\",[n._v(\"作用对象不同: \"),r(\"code\",[n._v(\"@Component\")]),n._v(\" 注解作用于类，而\"),r(\"code\",[n._v(\"@Bean\")]),n._v(\"注解作用于方法。\")]),n._v(\" \"),r(\"li\",[r(\"code\",[n._v(\"@Component\")]),n._v(\"通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 \"),r(\"code\",[n._v(\"@ComponentScan\")]),n._v(\" 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。\"),r(\"code\",[n._v(\"@Bean\")]),n._v(\" 注解通常是我们在标有该注解的方法中定义产生这个 bean,\"),r(\"code\",[n._v(\"@Bean\")]),n._v(\"告诉了Spring这是某个类的示例，当我需要用它的时候还给我。\")]),n._v(\" \"),r(\"li\",[r(\"code\",[n._v(\"@Bean\")]),n._v(\" 注解比 \"),r(\"code\",[n._v(\"Component\")]),n._v(\" 注解的自定义性更强，而且很多地方我们只能通过 \"),r(\"code\",[n._v(\"@Bean\")]),n._v(\" 注解来注册bean。比如当我们引用第三方库中的类需要装配到 \"),r(\"code\",[n._v(\"Spring\")]),n._v(\"容器时，则只能通过 \"),r(\"code\",[n._v(\"@Bean\")]),n._v(\"来实现。\")])]),n._v(\" \"),r(\"p\",[r(\"code\",[n._v(\"@Bean\")]),n._v(\"注解使用示例：\")]),n._v(\" \"),r(\"div\",{staticClass:\"language-java line-numbers-mode\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[r(\"code\",[r(\"span\",{pre:!0,attrs:{class:\"token annotation punctuation\"}},[n._v(\"@Configuration\")]),n._v(\"\\n\"),r(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"public\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"class\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[n._v(\"AppConfig\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"{\")]),n._v(\"\\n    \"),r(\"span\",{pre:!0,attrs:{class:\"token annotation punctuation\"}},[n._v(\"@Bean\")]),n._v(\"\\n    \"),r(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"public\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[n._v(\"TransferService\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token function\"}},[n._v(\"transferService\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"(\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\")\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"{\")]),n._v(\"\\n        \"),r(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"return\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"new\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[n._v(\"TransferServiceImpl\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"(\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\")\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\";\")]),n._v(\"\\n    \"),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"}\")]),n._v(\"\\n\"),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"}\")]),n._v(\"\\n\")])]),n._v(\" \"),r(\"div\",{staticClass:\"line-numbers-wrapper\"},[r(\"span\",{staticClass:\"line-number\"},[n._v(\"1\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"2\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"3\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"4\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"5\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"6\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"7\")]),r(\"br\")])]),r(\"p\",[n._v(\"上面的代码相当于下面的 xml 配置\")]),n._v(\" \"),r(\"div\",{staticClass:\"language-xml line-numbers-mode\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-xml\"}},[r(\"code\",[r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"<\")]),n._v(\"beans\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\">\")])]),n._v(\"\\n    \"),r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"<\")]),n._v(\"bean\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token attr-name\"}},[n._v(\"id\")]),r(\"span\",{pre:!0,attrs:{class:\"token attr-value\"}},[r(\"span\",{pre:!0,attrs:{class:\"token punctuation attr-equals\"}},[n._v(\"=\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v('\"')]),n._v(\"transferService\"),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v('\"')])]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token attr-name\"}},[n._v(\"class\")]),r(\"span\",{pre:!0,attrs:{class:\"token attr-value\"}},[r(\"span\",{pre:!0,attrs:{class:\"token punctuation attr-equals\"}},[n._v(\"=\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v('\"')]),n._v(\"com.acme.TransferServiceImpl\"),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v('\"')])]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"/>\")])]),n._v(\"\\n\"),r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token tag\"}},[r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"</\")]),n._v(\"beans\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\">\")])]),n._v(\"\\n\")])]),n._v(\" \"),r(\"div\",{staticClass:\"line-numbers-wrapper\"},[r(\"span\",{staticClass:\"line-number\"},[n._v(\"1\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"2\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"3\")]),r(\"br\")])]),r(\"p\",[n._v(\"下面这个例子是通过 \"),r(\"code\",[n._v(\"@Component\")]),n._v(\" 无法实现的。\")]),n._v(\" \"),r(\"div\",{staticClass:\"language-java line-numbers-mode\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[r(\"code\",[r(\"span\",{pre:!0,attrs:{class:\"token annotation punctuation\"}},[n._v(\"@Bean\")]),n._v(\"\\n\"),r(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"public\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[n._v(\"OneService\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token function\"}},[n._v(\"getService\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"(\")]),n._v(\"status\"),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\")\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"{\")]),n._v(\"\\n    \"),r(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"case\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"(\")]),n._v(\"status\"),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\")\")]),n._v(\"  \"),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"{\")]),n._v(\"\\n        when \"),r(\"span\",{pre:!0,attrs:{class:\"token number\"}},[n._v(\"1\")]),r(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\":\")]),n._v(\"\\n                \"),r(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"return\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"new\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token function\"}},[n._v(\"serviceImpl1\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"(\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\")\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\";\")]),n._v(\"\\n        when \"),r(\"span\",{pre:!0,attrs:{class:\"token number\"}},[n._v(\"2\")]),r(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\":\")]),n._v(\"\\n                \"),r(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"return\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"new\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token function\"}},[n._v(\"serviceImpl2\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"(\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\")\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\";\")]),n._v(\"\\n        when \"),r(\"span\",{pre:!0,attrs:{class:\"token number\"}},[n._v(\"3\")]),r(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\":\")]),n._v(\"\\n                \"),r(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"return\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"new\")]),n._v(\" \"),r(\"span\",{pre:!0,attrs:{class:\"token function\"}},[n._v(\"serviceImpl3\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"(\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\")\")]),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\";\")]),n._v(\"\\n    \"),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"}\")]),n._v(\"\\n\"),r(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"}\")]),n._v(\"\\n\")])]),n._v(\" \"),r(\"div\",{staticClass:\"line-numbers-wrapper\"},[r(\"span\",{staticClass:\"line-number\"},[n._v(\"1\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"2\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"3\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"4\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"5\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"6\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"7\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"8\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"9\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"10\")]),r(\"br\"),r(\"span\",{staticClass:\"line-number\"},[n._v(\"11\")]),r(\"br\")])]),r(\"h2\",{attrs:{id:\"将一个类声明为spring的-bean-的注解有哪些\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#将一个类声明为spring的-bean-的注解有哪些\"}},[n._v(\"#\")]),n._v(\" 将一个类声明为Spring的 bean 的注解有哪些?\")]),n._v(\" \"),r(\"p\",[n._v(\"我们一般使用 \"),r(\"code\",[n._v(\"@Autowired\")]),n._v(\" 注解自动装配 bean，要想把类标识成可用于 \"),r(\"code\",[n._v(\"@Autowired\")]),n._v(\" 注解自动装配的 bean 的类,采用以下注解可实现：\")]),n._v(\" \"),r(\"ul\",[r(\"li\",[r(\"code\",[n._v(\"@Component\")]),n._v(\" ：通用的注解，可标注任意类为 \"),r(\"code\",[n._v(\"Spring\")]),n._v(\" 组件。如果一个Bean不知道属于哪个层，可以使用\"),r(\"code\",[n._v(\"@Component\")]),n._v(\" 注解标注。\")]),n._v(\" \"),r(\"li\",[r(\"code\",[n._v(\"@Repository\")]),n._v(\" : 对应持久层即 Dao 层，主要用于数据库相关操作。\")]),n._v(\" \"),r(\"li\",[r(\"code\",[n._v(\"@Service\")]),n._v(\" : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。\")]),n._v(\" \"),r(\"li\",[r(\"code\",[n._v(\"@Controller\")]),n._v(\" : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。\")])]),n._v(\" \"),r(\"h2\",{attrs:{id:\"spring-管理事务的方式有几种\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#spring-管理事务的方式有几种\"}},[n._v(\"#\")]),n._v(\" Spring 管理事务的方式有几种？\")]),n._v(\" \"),r(\"ol\",[r(\"li\",[n._v(\"编程式事务，在代码中硬编码。(不推荐使用)\")]),n._v(\" \"),r(\"li\",[n._v(\"声明式事务，在配置文件中配置（推荐使用）\")])]),n._v(\" \"),r(\"p\",[r(\"strong\",[n._v(\"声明式事务又分为两种：\")])]),n._v(\" \"),r(\"ol\",[r(\"li\",[n._v(\"基于XML的声明式事务\")]),n._v(\" \"),r(\"li\",[n._v(\"基于注解的声明式事务\")])]),n._v(\" \"),r(\"h2\",{attrs:{id:\"spring-事务中的隔离级别有哪几种\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#spring-事务中的隔离级别有哪几种\"}},[n._v(\"#\")]),n._v(\" Spring 事务中的隔离级别有哪几种?\")]),n._v(\" \"),r(\"p\",[r(\"strong\",[n._v(\"TransactionDefinition 接口中定义了五个表示隔离级别的常量：\")])]),n._v(\" \"),r(\"ul\",[r(\"li\",[r(\"strong\",[n._v(\"TransactionDefinition.ISOLATION_DEFAULT:\")]),n._v(\"  使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"TransactionDefinition.ISOLATION_READ_UNCOMMITTED:\")]),n._v(\" 最低的隔离级别，允许读取尚未提交的数据变更，\"),r(\"strong\",[n._v(\"可能会导致脏读、幻读或不可重复读\")])]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"TransactionDefinition.ISOLATION_READ_COMMITTED:\")]),n._v(\"   允许读取并发事务已经提交的数据，\"),r(\"strong\",[n._v(\"可以阻止脏读，但是幻读或不可重复读仍有可能发生\")])]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"TransactionDefinition.ISOLATION_REPEATABLE_READ:\")]),n._v(\"  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，\"),r(\"strong\",[n._v(\"可以阻止脏读和不可重复读，但幻读仍有可能发生。\")])]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"TransactionDefinition.ISOLATION_SERIALIZABLE:\")]),n._v(\"   最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，\"),r(\"strong\",[n._v(\"该级别可以防止脏读、不可重复读以及幻读\")]),n._v(\"。但是这将严重影响程序的性能。通常情况下也不会用到该级别。\")])]),n._v(\" \"),r(\"h2\",{attrs:{id:\"spring-事务中哪几种事务传播行为\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#spring-事务中哪几种事务传播行为\"}},[n._v(\"#\")]),n._v(\" Spring 事务中哪几种事务传播行为?\")]),n._v(\" \"),r(\"p\",[r(\"strong\",[n._v(\"支持当前事务的情况：\")])]),n._v(\" \"),r(\"ul\",[r(\"li\",[r(\"strong\",[n._v(\"TransactionDefinition.PROPAGATION_REQUIRED：\")]),n._v(\" 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"TransactionDefinition.PROPAGATION_SUPPORTS：\")]),n._v(\" 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"TransactionDefinition.PROPAGATION_MANDATORY：\")]),n._v(\" 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）\")])]),n._v(\" \"),r(\"p\",[r(\"strong\",[n._v(\"不支持当前事务的情况：\")])]),n._v(\" \"),r(\"ul\",[r(\"li\",[r(\"strong\",[n._v(\"TransactionDefinition.PROPAGATION_REQUIRES_NEW：\")]),n._v(\" 创建一个新的事务，如果当前存在事务，则把当前事务挂起。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"TransactionDefinition.PROPAGATION_NOT_SUPPORTED：\")]),n._v(\" 以非事务方式运行，如果当前存在事务，则把当前事务挂起。\")]),n._v(\" \"),r(\"li\",[r(\"strong\",[n._v(\"TransactionDefinition.PROPAGATION_NEVER：\")]),n._v(\" 以非事务方式运行，如果当前存在事务，则抛出异常。\")])]),n._v(\" \"),r(\"p\",[r(\"strong\",[n._v(\"其他情况：\")])]),n._v(\" \"),r(\"ul\",[r(\"li\",[r(\"strong\",[n._v(\"TransactionDefinition.PROPAGATION_NESTED：\")]),n._v(\" 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。\")])]),n._v(\" \"),r(\"h2\",{attrs:{id:\"参考\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#参考\"}},[n._v(\"#\")]),n._v(\" 参考\")]),n._v(\" \"),r(\"ul\",[r(\"li\",[n._v(\"《Spring 技术内幕》\")]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"http://www.cnblogs.com/wmyskxz/p/8820371.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"http://www.cnblogs.com/wmyskxz/p/8820371.html\"),r(\"OutboundLink\")],1)]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://www.journaldev.com/2696/spring-interview-questions-and-answers\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"https://www.journaldev.com/2696/spring-interview-questions-and-answers\"),r(\"OutboundLink\")],1)]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://www.edureka.co/blog/interview-questions/spring-interview-questions/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"https://www.edureka.co/blog/interview-questions/spring-interview-questions/\"),r(\"OutboundLink\")],1)]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/\"),r(\"OutboundLink\")],1)]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/\"),r(\"OutboundLink\")],1)]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired\"),r(\"OutboundLink\")],1)])]),n._v(\" \"),r(\"h3\",{attrs:{id:\"springaop-ioc实现原理\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#springaop-ioc实现原理\"}},[n._v(\"#\")]),n._v(\" SpringAOP,IOC实现原理\")]),n._v(\" \"),r(\"p\",[n._v(\"AOP实现原理、动态代理和静态代理、Spring IOC的初始化过程、IOC原理、自己实现怎么实现一个IOC容器？这些东西都是经常会被问到的。\")]),n._v(\" \"),r(\"p\",[n._v(\"推荐阅读：\")]),n._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[r(\"a\",{attrs:{href:\"http://www.coolblog.xyz/2018/01/18/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%9A%84-Spring-IOC-%E5%92%8C-AOP-%E4%B8%8A%E7%AF%87/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"自己动手实现的 Spring IOC 和 AOP - 上篇\"),r(\"OutboundLink\")],1)])]),n._v(\" \"),r(\"li\",[r(\"p\",[r(\"a\",{attrs:{href:\"http://www.coolblog.xyz/2018/01/18/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%9A%84-Spring-IOC-%E5%92%8C-AOP-%E4%B8%8B%E7%AF%87/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"自己动手实现的 Spring IOC 和 AOP - 下篇\"),r(\"OutboundLink\")],1)])])]),n._v(\" \"),r(\"h3\",{attrs:{id:\"aop-2\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#aop-2\"}},[n._v(\"#\")]),n._v(\" AOP\")]),n._v(\" \"),r(\"p\",[n._v(\"AOP思想的实现一般都是基于 \"),r(\"strong\",[n._v(\"代理模式\")]),n._v(\" ，在JAVA中一般采用JDK动态代理模式，但是我们都知道，\"),r(\"strong\",[n._v(\"JDK动态代理模式只能代理接口而不能代理类\")]),n._v(\"。因此，Spring AOP 会这样子来进行切换，因为Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理。\")]),n._v(\" \"),r(\"ul\",[r(\"li\",[n._v(\"如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；\")]),n._v(\" \"),r(\"li\",[n._v(\"如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类——不过这个选择过程对开发者完全透明、开发者也无需关心。\")])]),n._v(\" \"),r(\"p\",[n._v(\"推荐阅读：\")]),n._v(\" \"),r(\"ul\",[r(\"li\",[r(\"a\",{attrs:{href:\"http://www.cnblogs.com/puyangsky/p/6218925.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"静态代理、JDK动态代理、CGLIB动态代理讲解\"),r(\"OutboundLink\")],1),n._v(\" ：我们知道AOP思想的实现一般都是基于 \"),r(\"strong\",[n._v(\"代理模式\")]),n._v(\" ，所以在看下面的文章之前建议先了解一下静态代理以及JDK动态代理、CGLIB动态代理的实现方式。\")]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://juejin.im/post/5aa7818af265da23844040c6\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"Spring AOP 入门\"),r(\"OutboundLink\")],1),n._v(\" ：带你入门的一篇文章。这篇文章主要介绍了AOP中的基本概念：5种类型的通知（Before，After，After-returning，After-throwing，Around）；Spring中对AOP的支持：AOP思想的实现一般都是基于代理模式，在Java中一般采用JDK动态代理模式，Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理，\")]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://juejin.im/post/5a55af9e518825734d14813f\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"Spring AOP 基于AspectJ注解如何实现AOP\"),r(\"OutboundLink\")],1),n._v(\" ： \"),r(\"strong\",[n._v(\"AspectJ是一个AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器）\")]),n._v(\"，可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。Spring注意到AspectJ在AOP的实现方式上依赖于特殊编译器(ajc编译器)，因此Spring很机智回避了这点，转向采用动态代理技术的实现原理来构建Spring AOP的内部机制（动态织入），这是与AspectJ（静态织入）最根本的区别。\"),r(\"strong\",[n._v(\"Spring 只是使用了与 AspectJ 5 一样的注解，但仍然没有使用 AspectJ 的编译器，底层依是动态代理技术的实现，因此并不依赖于 AspectJ 的编译器\")]),n._v(\"。 Spring AOP虽然是使用了那一套注解，其实实现AOP的底层是使用了动态代理(JDK或者CGLib)来动态植入。至于AspectJ的静态植入，不是本文重点，所以只提一提。\")]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://www.imooc.com/learn/869\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"探秘Spring AOP（慕课网视频，很不错）\"),r(\"OutboundLink\")],1),n._v(\":慕课网视频，讲解的很不错，详细且深入\")]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://blog.csdn.net/fighterandknight/article/details/51209822\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"spring源码剖析（六）AOP实现原理剖析\"),r(\"OutboundLink\")],1),n._v(\" :通过源码分析Spring AOP的原理\")])]),n._v(\" \"),r(\"h3\",{attrs:{id:\"ioc-2\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ioc-2\"}},[n._v(\"#\")]),n._v(\" IOC\")]),n._v(\" \"),r(\"p\",[n._v(\"Spring IOC的初始化过程：\\n\"),r(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/5/22/16387903ee72c831?w=709&h=56&f=png&s=4673\",alt:\"Spring IOC的初始化过程\"}})]),n._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[r(\"a\",{attrs:{href:\"https://www.cnblogs.com/wang-meng/p/5597490.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"[Spring框架]Spring IOC的原理及详解。\"),r(\"OutboundLink\")],1)])]),n._v(\" \"),r(\"li\",[r(\"p\",[r(\"a\",{attrs:{href:\"https://yikun.github.io/2015/05/29/Spring-IOC%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"Spring IOC核心源码学习\"),r(\"OutboundLink\")],1),n._v(\" :比较简短，推荐阅读。\")])]),n._v(\" \"),r(\"li\",[r(\"p\",[r(\"a\",{attrs:{href:\"https://javadoop.com/post/spring-ioc\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"Spring IOC 容器源码分析\"),r(\"OutboundLink\")],1),n._v(\" :强烈推荐，内容详尽，而且便于阅读。\")])])]),n._v(\" \"),r(\"h2\",{attrs:{id:\"spring事务管理\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#spring事务管理\"}},[n._v(\"#\")]),n._v(\" Spring事务管理\")]),n._v(\" \"),r(\"ul\",[r(\"li\",[r(\"a\",{attrs:{href:\"https://juejin.im/post/5b00c52ef265da0b95276091\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"可能是最漂亮的Spring事务管理详解\"),r(\"OutboundLink\")],1)]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://juejin.im/post/5b010f27518825426539ba38\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"Spring编程式和声明式事务实例讲解\"),r(\"OutboundLink\")],1)])]),n._v(\" \"),r(\"h3\",{attrs:{id:\"spring单例与线程安全\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#spring单例与线程安全\"}},[n._v(\"#\")]),n._v(\" Spring单例与线程安全\")]),n._v(\" \"),r(\"ul\",[r(\"li\",[r(\"a\",{attrs:{href:\"http://www.cnblogs.com/chengxuyuanzhilu/p/6404991.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"Spring框架中的单例模式（源码解读）\"),r(\"OutboundLink\")],1),n._v(\":单例模式是一种常用的软件设计模式。通过单例模式可以保证系统中一个类只有一个实例。spring依赖注入时，使用了 多重判断加锁 的单例模式。\")])]),n._v(\" \"),r(\"h3\",{attrs:{id:\"spring源码阅读\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#spring源码阅读\"}},[n._v(\"#\")]),n._v(\" Spring源码阅读\")]),n._v(\" \"),r(\"p\",[n._v(\"阅读源码不仅可以加深我们对Spring设计思想的理解，提高自己的编码水平，还可以让自己在面试中如鱼得水。下面的是Github上的一个开源的Spring源码阅读，大家有时间可以看一下，当然你如果有时间也可以自己慢慢研究源码。\")]),n._v(\" \"),r(\"ul\",[r(\"li\",[r(\"a\",{attrs:{href:\"https://github.com/seaswalker/Spring/blob/master/note/Spring.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"spring-core\"),r(\"OutboundLink\")],1)]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://github.com/seaswalker/Spring/blob/master/note/spring-aop.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"spring-aop\"),r(\"OutboundLink\")],1)]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://github.com/seaswalker/Spring/blob/master/note/spring-context.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"spring-context\"),r(\"OutboundLink\")],1)]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://github.com/seaswalker/Spring/blob/master/note/spring-task.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"spring-task\"),r(\"OutboundLink\")],1)]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://github.com/seaswalker/Spring/blob/master/note/spring-transaction.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"spring-transaction\"),r(\"OutboundLink\")],1)]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://github.com/seaswalker/Spring/blob/master/note/spring-mvc.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"spring-mvc\"),r(\"OutboundLink\")],1)]),n._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://github.com/seaswalker/Spring/blob/master/note/guava-cache.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"guava-cache\"),r(\"OutboundLink\")],1)])])])}),[],!1,null,null,null);t.default=a.exports}}]);","extractedComments":[]}