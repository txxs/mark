{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[165],{540:function(a,t,v){\"use strict\";v.r(t);var e=v(13),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[v(\"p\",[a._v(\"原文地址：\")]),a._v(\" \"),v(\"p\",[a._v(\"https://blog.csdn.net/linjpg/article/details/80962453\")]),a._v(\" \"),v(\"p\",[a._v(\"IO\\tNIO\\n面向字节流\\t面向缓冲区\\n阻塞\\t基于Selector的非阻塞\\n无   选择器（多路复用）\")]),a._v(\" \"),v(\"h3\",{attrs:{id:\"面向流和面向缓冲区\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#面向流和面向缓冲区\"}},[a._v(\"#\")]),a._v(\" 面向流和面向缓冲区\")]),a._v(\" \"),v(\"p\",[a._v(\"这个概念和编程方法中的面向过程、面向对象类似。Java IO 是面向流的而Java NIO是面向缓冲区的。\")]),a._v(\" \"),v(\"p\",[a._v(\"在Java IO中读取数据和写入数据是面向流（Stream）的,这表示当我们从流中读取数据，写入数据时也将其写入流，流的含义在于没有缓存 ，就好像我们站在流水线前，所有的数据沿着流水线依次到达我们的面前，我们只能读取当前的数据（相当于我们拥有一个数据流的切面）。如果需要获取某个数据的前一项或后一项数据那就必须自己缓存数据，而不能直接从流中获取（因为面向流就意味着我们只有一个数据流的切面）\")]),a._v(\" \"),v(\"p\",[a._v(\"而在Java NIO中数据的读写是面向缓冲区（Buffer）的，读取时可以将整块的数据读取到缓冲区中，在写入时则可以将整个缓冲区中的数据一起写入。这就好像是将流水线传输变成了卡车运送，面向流的数据读写只提供了一个数据流切面，而面向缓冲区的IO则使我们能够看到数据的上下文，也就是说在缓冲区中获取某项数据的前一项数据或者是后一项数据十分方便。这种便利是有代价的，因为我们必须管理好缓冲区，这包括不能让新的数据覆盖了缓冲区中还没有被处理的有用数据；将缓冲区中的数据正确的分块,分清哪些被处理过哪些还没有等等。\")]),a._v(\" \"),v(\"p\",[a._v(\"Java NIO的IO模型与很多IO的本质更加一致！磁盘IO读写就是数据块读写; TCP/IP协议传输的也是数据包而不是数据流。但是很多系统提供的是却是面向流的系统API，例如套接字API是面向数据流的。\")]),a._v(\" \"),v(\"h3\",{attrs:{id:\"阻塞和非阻塞\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#阻塞和非阻塞\"}},[a._v(\"#\")]),a._v(\" 阻塞和非阻塞\")]),a._v(\" \"),v(\"p\",[a._v(\"Java IO是阻塞的，如果在一次读写数据调用时数据还没有准备好，或者目前不可写，那么读写操作就会被阻塞直到数据准备好或目标可写为止。Java NIO则是非阻塞的，每一次数据读写调用都会立即返回，并将目前可读（或可写）的内容写入缓冲区或者从缓冲区中输出，即使当前没有可用数据，调用仍然会立即返回并且不对缓冲区做任何操作。这就好像去超市买东西，如果超市中没有需要的商品或者数量还不够，那么Java IO会一直等直到超市中需要的商品数量足够了就将所有需要的商品带回来,Java NIO则不同，不论超市中有多少需要的商品，它都会立即买下可以买到的所有需要的商品并返回，甚至是没有需要的商品也会立即返回。\")]),a._v(\" \"),v(\"p\",[a._v(\"阻塞IO会使得线程将大量的时间浪费在等待IO上，这是非常不划算的，但是这种阻塞可以在数据可用时立即获取并处理数据，而非阻塞IO则必须通过重复的调用来获取全部数据。\")]),a._v(\" \"),v(\"p\",[a._v(\"Java NIO 使用Selector实现单线程管理多个Channel，通过 select 调用，可以获取已经准备好的Channel并进行相应的处理。\")]),a._v(\" \"),v(\"h3\",{attrs:{id:\"java-io-工作流程\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#java-io-工作流程\"}},[a._v(\"#\")]),a._v(\" Java IO 工作流程\")]),a._v(\" \"),v(\"p\",[a._v(\"由于Java IO是阻塞的，所以当面对多个流的读写时需要多个线程处理。例如在网络IO中，Server端使用一个线程监听一个端口，一旦某个连接被accept，创建新的线程来处理新建立的连接。\\n\"),v(\"img\",{attrs:{src:\"https://txxs.github.io/pic/tofuturejavaio/1-1.png\",alt:\"1\"}})]),a._v(\" \"),v(\"p\",[a._v(\"其中 read/write 是阻塞的。\")]),a._v(\" \"),v(\"h3\",{attrs:{id:\"java-nio-工作流程\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#java-nio-工作流程\"}},[a._v(\"#\")]),a._v(\" Java NIO 工作流程\")]),a._v(\" \"),v(\"p\",[a._v(\"Java NIO 提供 Selector 实现单个线程管理多个channel的功能。\\n\"),v(\"img\",{attrs:{src:\"https://txxs.github.io/pic/tofuturejavaio/1-2.png\",alt:\"1\"}})]),a._v(\" \"),v(\"p\",[a._v(\"其中select 调用可能是阻塞的，也可以是非阻塞的。但是read/write是非阻塞的！\")])])}),[],!1,null,null,null);t.default=r.exports}}]);","extractedComments":[]}