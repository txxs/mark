{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{459:function(s,e,t){\"use strict\";t.r(e);var a=t(13),n=Object(a.a)({},(function(){var s=this,e=s.$createElement,t=s._self._c||e;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[t(\"p\",[s._v(\"原文地址：\\nhttps://zhuanlan.zhihu.com/p/68146243\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"一、前言\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一、前言\"}},[s._v(\"#\")]),s._v(\" 一、前言\")]),s._v(\" \"),t(\"p\",[s._v(\"有时候我们需要知道线上的Redis的使用情况，尤其需要知道一些前缀的key值，让我们怎么去查看呢？并且通常情况下Redis里的数据都是海量的，那么我们访问Redis中的海量数据？如何避免事故产生！今天就给大家分享一个小知识点，希望大家轻喷。\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"二、事故产生\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二、事故产生\"}},[s._v(\"#\")]),s._v(\" 二、事故产生\")]),s._v(\" \"),t(\"p\",[s._v(\"因为我们的用户token缓存是采用了【user_token:userid】格式的key，保存用户的token的值。我们运维为了帮助开发小伙伴们查一下线上现在有多少登录用户。\")]),s._v(\" \"),t(\"p\",[s._v(\"直接用了keys user_token*方式进行查询，事故就此发生了。导致Redis不可用，假死。\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"三、分析原因\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#三、分析原因\"}},[s._v(\"#\")]),s._v(\" 三、分析原因\")]),s._v(\" \"),t(\"p\",[s._v(\"我们线上的登录用户有几百万，数据量比较多；keys算法是遍历算法，复杂度是O(n)，也就是数据越多，时间越高。 数据量达到几百万，keys这个指令就会导致 Redis 服务卡顿，因为 Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才可以继续。\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"四、解决方案\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#四、解决方案\"}},[s._v(\"#\")]),s._v(\" 四、解决方案\")]),s._v(\" \"),t(\"p\",[s._v(\"那我们如何去遍历大数据量呢？这个也是面试经常问的。我们可以采用Redis的另一个命令scan。我们看一下scan的特点：\")]),s._v(\" \"),t(\"p\",[s._v(\"复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程\\n提供 count 参数，不是结果数量，是Redis单次遍历字典槽位数量(约等于)\\n同 keys 一样，它也提供模式匹配功能;\\n服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;\\n返回的结果可能会有重复，需要客户端去重复，这点非常重要;\\n单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零\\n4.1、scan命令格式\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"SCAN cursor [MATCH pattern] [COUNT count]\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\")])]),t(\"p\",[s._v(\"4.2、命令解释\")]),s._v(\" \"),t(\"p\",[s._v(\"scan 游标 MATCH <返回和给定模式相匹配的元素> count 每次迭代所返回的元素数量\")]),s._v(\" \"),t(\"p\",[s._v(\"SCAN命令是增量的循环，每次调用只会返回一小部分的元素。所以不会让Redis假死；\\nSCAN命令返回的是一个游标，从0开始遍历，到0结束遍历；\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"五、总结\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#五、总结\"}},[s._v(\"#\")]),s._v(\" 五、总结\")]),s._v(\" \"),t(\"p\",[s._v(\"这个是面试经常会问到的，也是我们小伙伴在工作的过程经常用的，一般数据量不大的时候，不会有什么问题，但数据量多的时候，你的操作方式不对，你的绩效就会被扣哦。\")]),s._v(\" \"),t(\"p\",[s._v(\"另外一篇文章《Redis敢在线上做Keys正则匹配操作！你可以离职了！》，从正则匹配的角度介绍了Redis的一个错误用法，大家有兴趣的话也可以看一下！\")])])}),[],!1,null,null,null);e.default=n.exports}}]);","extractedComments":[]}