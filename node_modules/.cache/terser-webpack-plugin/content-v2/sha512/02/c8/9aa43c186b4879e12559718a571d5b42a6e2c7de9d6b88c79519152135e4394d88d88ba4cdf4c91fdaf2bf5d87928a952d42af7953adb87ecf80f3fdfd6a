{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{419:function(n,e,t){\"use strict\";t.r(e);var p=t(13),v=Object(p.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[t(\"p\",[n._v(\"原文地址：\")]),n._v(\" \"),t(\"p\",[n._v(\"https://lanjingling.github.io/2015/10/10/mysql-hangsuo/\")]),n._v(\" \"),t(\"p\",[n._v(\"https://zhuanlan.zhihu.com/p/58695491\")]),n._v(\" \"),t(\"p\",[n._v(\"InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。下面通过一些实际例子来加以说明.\")]),n._v(\" \"),t(\"p\",[n._v(\"1、在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁\")]),n._v(\" \"),t(\"p\",[n._v(\"1）InnoDB存储引擎的表在不使用索引时使用表锁例子\")]),n._v(\" \"),t(\"p\",[n._v(\"2）有了索引以后，在对索引字段查询时，使用的就是行级锁：\")]),n._v(\" \"),t(\"p\",[n._v(\"2、由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"select * from table where id = 1 和 id = 2 不会阻塞的\\n\")])]),n._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[n._v(\"1\")]),t(\"br\")])]),t(\"p\",[n._v(\"3、当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。\")]),n._v(\" \"),t(\"p\",[n._v(\"4、间隙锁（Next-Key锁）\")]),n._v(\" \"),t(\"p\",[n._v(\"当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。\")]),n._v(\" \"),t(\"p\",[n._v(\"举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：\\nSelect * from emp where empid > 100 for update;\\n是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。\\nInnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对锁机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况，在后续的章节中会做进一步介绍。\")]),n._v(\" \"),t(\"p\",[n._v(\"很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。\")]),n._v(\" \"),t(\"p\",[n._v(\"为什么表没有索引，表里所有的记录都会被锁住？\")]),n._v(\" \"),t(\"p\",[n._v(\"当表上没有创建索引的时候，InnoDB会为每一行创建一个隐藏的主键作为聚集索引。这个隐藏的主键是一个6个字节的列，该列的值会随着数据的插入自增。\")]),n._v(\" \"),t(\"p\",[n._v(\"当不通过索引检索数据的时候，MySQL会使用全表扫描，此时所有行的索引都会被锁定，行锁升级为表锁。\")])])}),[],!1,null,null,null);e.default=v.exports}}]);","extractedComments":[]}