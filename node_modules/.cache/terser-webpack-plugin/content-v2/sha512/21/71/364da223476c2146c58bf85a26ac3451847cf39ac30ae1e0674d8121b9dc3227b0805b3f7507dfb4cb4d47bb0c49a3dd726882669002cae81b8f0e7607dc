{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{422:function(s,v,_){\"use strict\";_.r(v);var t=_(13),a=Object(t.a)({},(function(){var s=this,v=s.$createElement,_=s._self._c||v;return _(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[_(\"p\",[s._v(\"原文地址：\")]),s._v(\" \"),_(\"p\",[s._v(\"https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/mysql-read-write-separation.md\")]),s._v(\" \"),_(\"p\",[_(\"strong\",[s._v(\"精华就是下边这句\")])]),s._v(\" \"),_(\"p\",[s._v(\"所以 MySQL 实际上在这一块有两个机制，一个是\"),_(\"strong\",[s._v(\"半同步复制（semi-sync）\")]),s._v(\"，用来解决主库数据丢失问题；一个是\"),_(\"strong\",[s._v(\"并行复制\")]),s._v(\"，用来解决主从同步延时问题。\\n所谓\"),_(\"strong\",[s._v(\"并行复制\")]),s._v(\"，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后\"),_(\"strong\",[s._v(\"并行重放不同库的日志\")]),s._v(\"，这是库级别的并行。\")]),s._v(\" \"),_(\"h2\",{attrs:{id:\"面试题\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#面试题\"}},[s._v(\"#\")]),s._v(\" 面试题\")]),s._v(\" \"),_(\"p\",[s._v(\"你们有没有做 MySQL 读写分离？如何实现 MySQL 的读写分离？MySQL 主从复制原理的是啥？如何解决 MySQL 主从同步的延时问题？\")]),s._v(\" \"),_(\"h2\",{attrs:{id:\"面试官心理分析\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#面试官心理分析\"}},[s._v(\"#\")]),s._v(\" 面试官心理分析\")]),s._v(\" \"),_(\"p\",[s._v(\"高并发这个阶段，肯定是需要做读写分离的，啥意思？因为实际上大部分的互联网公司，一些网站，或者是 app，其实都是读多写少。所以针对这个情况，就是写一个主库，但是主库挂多个从库，然后从多个从库来读，那不就可以支撑更高的读并发压力了吗？\")]),s._v(\" \"),_(\"h2\",{attrs:{id:\"面试题剖析\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#面试题剖析\"}},[s._v(\"#\")]),s._v(\" 面试题剖析\")]),s._v(\" \"),_(\"h3\",{attrs:{id:\"如何实现-mysql-的读写分离\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何实现-mysql-的读写分离\"}},[s._v(\"#\")]),s._v(\" 如何实现 MySQL 的读写分离？\")]),s._v(\" \"),_(\"p\",[s._v(\"其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。\")]),s._v(\" \"),_(\"h3\",{attrs:{id:\"mysql-主从复制原理的是啥\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-主从复制原理的是啥\"}},[s._v(\"#\")]),s._v(\" MySQL 主从复制原理的是啥？\")]),s._v(\" \"),_(\"p\",[s._v(\"主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。\")]),s._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"/images/mysql-master-slave.png\",alt:\"mysql-master-slave\"}})]),s._v(\" \"),_(\"p\",[s._v(\"这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是\"),_(\"strong\",[s._v(\"有延时\")]),s._v(\"的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。\")]),s._v(\" \"),_(\"p\",[s._v(\"而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。\")]),s._v(\" \"),_(\"p\",[s._v(\"所以 MySQL 实际上在这一块有两个机制，一个是\"),_(\"strong\",[s._v(\"半同步复制\")]),s._v(\"，用来解决主库数据丢失问题；一个是\"),_(\"strong\",[s._v(\"并行复制\")]),s._v(\"，用来解决主从同步延时问题。\")]),s._v(\" \"),_(\"p\",[s._v(\"这个所谓\"),_(\"strong\",[s._v(\"半同步复制\")]),s._v(\"，也叫 \"),_(\"code\",[s._v(\"semi-sync\")]),s._v(\" 复制，指的就是主库写入 binlog 日志之后，就会将\"),_(\"strong\",[s._v(\"强制\")]),s._v(\"此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到\"),_(\"strong\",[s._v(\"至少一个从库\")]),s._v(\"的 ack 之后才会认为写操作完成了。\")]),s._v(\" \"),_(\"p\",[s._v(\"所谓\"),_(\"strong\",[s._v(\"并行复制\")]),s._v(\"，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后\"),_(\"strong\",[s._v(\"并行重放不同库的日志\")]),s._v(\"，这是库级别的并行。\")]),s._v(\" \"),_(\"h3\",{attrs:{id:\"mysql-主从同步延时问题-精华\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-主从同步延时问题-精华\"}},[s._v(\"#\")]),s._v(\" MySQL 主从同步延时问题（精华）\")]),s._v(\" \"),_(\"p\",[s._v(\"以前线上确实处理过因为主从同步延时问题而导致的线上的 bug，属于小型的生产事故。\")]),s._v(\" \"),_(\"p\",[s._v(\"是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 2000/s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新。用户跟客服反馈，而客服就会反馈给我们。\")]),s._v(\" \"),_(\"p\",[s._v(\"我们通过 MySQL 命令：\")]),s._v(\" \"),_(\"div\",{staticClass:\"language-sql line-numbers-mode\"},[_(\"pre\",{pre:!0,attrs:{class:\"language-sql\"}},[_(\"code\",[_(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"show\")]),s._v(\" \"),_(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"status\")]),s._v(\"\\n\")])]),s._v(\" \"),_(\"div\",{staticClass:\"line-numbers-wrapper\"},[_(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),_(\"br\")])]),_(\"p\",[s._v(\"查看 \"),_(\"code\",[s._v(\"Seconds_Behind_Master\")]),s._v(\"，可以看到从库复制主库的数据落后了几 ms。\")]),s._v(\" \"),_(\"p\",[s._v(\"一般来说，如果主从延迟较为严重，有以下解决方案：\")]),s._v(\" \"),_(\"ul\",[_(\"li\",[s._v(\"分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。\")]),s._v(\" \"),_(\"li\",[s._v(\"打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。\")]),s._v(\" \"),_(\"li\",[s._v(\"重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。\")]),s._v(\" \"),_(\"li\",[s._v(\"如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询\"),_(\"strong\",[s._v(\"设置直连主库\")]),s._v(\"。\"),_(\"strong\",[s._v(\"不推荐\")]),s._v(\"这种方法，你要是这么搞，读写分离的意义就丧失了。\")])])])}),[],!1,null,null,null);v.default=a.exports}}]);","extractedComments":[]}