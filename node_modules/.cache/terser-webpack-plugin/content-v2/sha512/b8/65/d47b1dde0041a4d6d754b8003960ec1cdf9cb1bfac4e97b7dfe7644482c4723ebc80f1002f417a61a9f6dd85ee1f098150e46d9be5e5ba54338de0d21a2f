{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{441:function(e,s,r){\"use strict\";r.r(s);var t=r(13),a=Object(t.a)({},(function(){var e=this,s=e.$createElement,r=e._self._c||s;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[r(\"p\",[e._v(\"来源：\\nhttps://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-expiration-policies-and-lru.md\")]),e._v(\" \"),r(\"p\",[e._v(\"redis 的过期策略都有哪些？内存淘汰机制都有哪些？\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"面试官心理分析\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#面试官心理分析\"}},[e._v(\"#\")]),e._v(\" 面试官心理分析\")]),e._v(\" \"),r(\"p\",[e._v(\"如果你连这个问题都不知道，上来就懵了，回答不出来，那线上你写代码的时候，想当然的认为写进 redis 的数据就一定会存在，后面导致系统各种 bug，谁来负责？\")]),e._v(\" \"),r(\"p\",[e._v(\"常见的有两个问题：\")]),e._v(\" \"),r(\"h4\",{attrs:{id:\"往-redis-写入的数据怎么没了\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#往-redis-写入的数据怎么没了\"}},[e._v(\"#\")]),e._v(\" 往 redis 写入的数据怎么没了？\")]),e._v(\" \"),r(\"p\",[e._v(\"可能有同学会遇到，在生产环境的 redis 经常会丢掉一些数据，写进去了，过一会儿可能就没了。我的天，同学，你问这个问题就说明 redis 你就没用对啊。redis 是缓存，你给当存储了是吧？\")]),e._v(\" \"),r(\"p\",[e._v(\"啥叫缓存？用内存当缓存。内存是无限的吗，内存是很宝贵而且是有限的，磁盘是廉价而且是大量的。可能一台机器就几十个 G 的内存，但是可以有几个 T 的硬盘空间。redis 主要是基于内存来进行高性能、高并发的读写操作的。\")]),e._v(\" \"),r(\"p\",[e._v(\"那既然内存是有限的，比如 redis 就只能用 10G，你要是往里面写了 20G 的数据，会咋办？当然会干掉 10G 的数据，然后就保留 10G 的数据了。那干掉哪些数据？保留哪些数据？当然是干掉不常用的数据，保留常用的数据了。\")]),e._v(\" \"),r(\"p\",[e._v(\"数据明明过期了，怎么还占用着内存？\\n这是由 redis 的过期策略来决定。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"面试题剖析\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#面试题剖析\"}},[e._v(\"#\")]),e._v(\" 面试题剖析\")]),e._v(\" \"),r(\"h4\",{attrs:{id:\"redis-过期策略是-定期删除-惰性删除。\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis-过期策略是-定期删除-惰性删除。\"}},[e._v(\"#\")]),e._v(\" redis 过期策略是：定期删除+惰性删除。\")]),e._v(\" \"),r(\"p\",[e._v(\"所谓定期删除，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。\")]),e._v(\" \"),r(\"p\",[e._v(\"假设 redis 里放了 10w 个 key，都设置了过期时间，你每隔几百毫秒，就检查 10w 个 key，那 redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。注意，这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的灾难。实际上 redis 是每隔 100ms 随机抽取一些 key 来检查和删除的。\")]),e._v(\" \"),r(\"p\",[e._v(\"但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个 key 的时候，redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。\")]),e._v(\" \"),r(\"p\",[e._v(\"获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。\")]),e._v(\" \"),r(\"p\",[e._v(\"但是实际上这还是有问题的，如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？\")]),e._v(\" \"),r(\"p\",[e._v(\"答案是：走内存淘汰机制。\")]),e._v(\" \"),r(\"h4\",{attrs:{id:\"内存淘汰机制\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#内存淘汰机制\"}},[e._v(\"#\")]),e._v(\" 内存淘汰机制\")]),e._v(\" \"),r(\"p\",[e._v(\"redis 内存淘汰机制有以下几个：\")]),e._v(\" \"),r(\"p\",[e._v(\"noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。\\nallkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。\\nallkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。\\nvolatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。\\nvolatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。\\nvolatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。\")])])}),[],!1,null,null,null);s.default=a.exports}}]);","extractedComments":[]}