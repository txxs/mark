{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[195],{571:function(v,_,t){\"use strict\";t.r(_);var n=t(13),s=Object(n.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[t(\"p\",[v._v(\"使用多线程时，\"),t(\"strong\",[v._v(\"不是多线程能提升程序的执行速度\")]),v._v(\"，使用多线程是为了\"),t(\"strong\",[v._v(\"更好地利用 CPU 资源\")]),v._v(\"！\")]),v._v(\" \"),t(\"p\",[v._v(\"程序在执行时，多线程是 CPU 通过给每个线程\"),t(\"strong\",[v._v(\"分配 CPU 时间片来实现\")]),v._v(\"的，时间片是CPU分配给每个线程执行的时间，因时间片非常短，所以\"),t(\"strong\",[v._v(\"CPU 通过不停地切换线程执行\")]),v._v(\"。\")]),v._v(\" \"),t(\"p\",[v._v(\"线程\"),t(\"strong\",[v._v(\"不是越多就越好\")]),v._v(\"的，因为线程上下文切换是有\"),t(\"strong\",[v._v(\"性能损耗\")]),v._v(\"的，在使用多线程的同时需要考虑如何减少上下文切换\")]),v._v(\" \"),t(\"p\",[v._v(\"一般来说有以下几条经验\")]),v._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[v._v(\"无锁并发编程\")]),v._v(\"。多线程竞争时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的 ID 按照Hash取模分段，不同的线程处理不同段的数据\")]),v._v(\" \"),t(\"li\",[t(\"strong\",[v._v(\"CAS算法\")]),v._v(\"。Java 的 Atomic 包使用 CAS 算法来更新数据，\"),t(\"strong\",[v._v(\"而不需要加锁\")]),v._v(\"。\")]),v._v(\" \"),t(\"li\",[t(\"strong\",[v._v(\"控制线程数量\")]),v._v(\"。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态\")]),v._v(\" \"),t(\"li\",[t(\"strong\",[v._v(\"协程\")]),v._v(\"。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换\")]),v._v(\" \"),t(\"li\",[v._v(\"协程可以看成是用户态\"),t(\"strong\",[v._v(\"自管理的“线程”\")]),v._v(\"。\"),t(\"strong\",[v._v(\"不会参与\")]),v._v(\"CPU时间调度，没有均衡分配到时间。\"),t(\"strong\",[v._v(\"非抢占式\")]),v._v(\"的\")])]),v._v(\" \"),t(\"p\",[v._v(\"还可以考虑我们的应用是\"),t(\"strong\",[v._v(\"IO密集型的还是CPU密集型\")]),v._v(\"的。\")]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"如果是IO密集型的话，线程可以多一些。\")]),v._v(\" \"),t(\"li\",[v._v(\"如果是CPU密集型的话，线程不宜太多。\")])])])}),[],!1,null,null,null);_.default=s.exports}}]);","extractedComments":[]}