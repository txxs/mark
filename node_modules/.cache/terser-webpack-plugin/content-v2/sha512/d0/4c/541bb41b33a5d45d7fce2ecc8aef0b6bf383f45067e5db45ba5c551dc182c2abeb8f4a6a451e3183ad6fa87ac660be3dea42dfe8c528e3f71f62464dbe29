{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[177],{560:function(t,e,a){\"use strict\";a.r(e);var r=a(13),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"p\",[t._v(\"原文地址：\")]),t._v(\" \"),a(\"p\",[t._v(\"https://cloud.tencent.com/developer/article/1185162\")]),t._v(\" \"),a(\"p\",[t._v(\"https://www.jianshu.com/p/6f89fd5842bf\")]),t._v(\" \"),a(\"p\",[t._v(\"https://juejin.im/post/5cee52def265da1b6d4007a0\")]),t._v(\" \"),a(\"p\",[t._v(\"https://cloud.tencent.com/developer/article/1185162\")]),t._v(\" \"),a(\"p\",[t._v(\"https://my.oschina.net/u/943305/blog/1838872\")]),t._v(\" \"),a(\"p\",[t._v(\"Z Garbage Collector，即ZGC，是一个可伸缩的、低延迟的垃圾收集器，主要为了满足如下目标进行设计：\")]),t._v(\" \"),a(\"p\",[t._v(\"1、停顿时间不会超过10ms\")]),t._v(\" \"),a(\"p\",[t._v(\"2、停顿时间不会随着堆的增大而增大（不管多大的堆都能保持在10ms以下）\")]),t._v(\" \"),a(\"p\",[t._v(\"3、可支持几百M，甚至几T的堆大小（最大支持4T）\")]),t._v(\" \"),a(\"p\",[t._v(\"停顿时间在10ms以下，10ms其实是一个很保守的数据，在SPECjbb 2015基准测试，128G的大堆下最大停顿时间才1.68ms，远低于10ms，和G1算法相比，也感觉像是在虐菜。\")]),t._v(\" \"),a(\"p\",[t._v(\"总体印象\")]),t._v(\" \"),a(\"p\",[t._v(\"好，接下来，我们还是先对ZGC有个总体上的印象。\")]),t._v(\" \"),a(\"p\",[t._v(\"1、全新的垃圾回收器。“全新”指的是一点点从草稿然后搞出来，不是基于哪个来优化出来的。\")]),t._v(\" \"),a(\"p\",[t._v(\"2、使用了Load Barriors技术，而不是使用store Barriors。这是两种不同的技术。store barriors是hotspot里现存的好多垃圾回收器所用的技术。zgc中使用load barrior技术来跟踪堆的状态和对象的状态。\")]),t._v(\" \"),a(\"p\",[t._v(\"3、单代。它是一个只有一个generation的回收器。\")]),t._v(\" \"),a(\"p\",[t._v(\"4、Partial Compaction。也是基于部分压缩，这个和G1是一样的。\")]),t._v(\" \"),a(\"p\",[t._v(\"5、Region-Based GC。它有点像G1，都是基于region，但和G1不一样的是，zgc有更加灵活的region的size schema。这样我们就可以轻松的处理大对象的分配问题了。\")]),t._v(\" \"),a(\"p\",[t._v(\"6、Immediate Memory Reuse。zgc和G1一样，region们会被及时的清理和压缩和转移，可以让内存的复用更加的及时。\")]),t._v(\" \"),a(\"p\",[t._v(\"7、NUMA-aware。这是一种内存页合并的硬件技术。\")]),t._v(\" \"),a(\"p\",[t._v(\"8、Colored Object Pointers。\")]),t._v(\" \"),a(\"p\",[t._v(\"9、Concurrent。zgc一个非常重要的能力。就是并行和并发干几乎所有的事情。\")]),t._v(\" \"),a(\"p\",[t._v(\"现在我们了解了不同gc阶段的属性，让我们继续探讨ZGC的工作原理。 为了实现其目标，ZGC给Hotspot Garbage Collectors增加了两种新技术：着色指针和读屏障;而ZGC通过技术手段把stw的情况控制在仅有一次，就是第一次的初始标记才会发生，这样也就不难理解为什么GC停顿时间不随着堆增大而上升了，再大我也是通过并发的时间去回收了\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"着色指针\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#着色指针\"}},[t._v(\"#\")]),t._v(\" 着色指针\")]),t._v(\" \"),a(\"p\",[t._v(\"着色指针是一种将信息存储在指针（或使用Java术语引用）中的技术。因为在64位平台上（ZGC仅支持64位平台），指针可以处理更多的内存，因此可以使用一些位来存储状态。 ZGC将限制最大支持4Tb堆（42-bits），那么会剩下22位可用，它目前使用了4位： finalizable， remap， mark0和mark1。 我们稍后解释它们的用途。\\n着色指针的一个问题是，当您需要取消着色时，它需要额外的工作（因为需要屏蔽信息位）。 像SPARC这样的平台有内置硬件支持指针屏蔽所以不是问题，而对于x86平台来说，ZGC团队使用了简洁的多重映射技巧。\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"多重映射\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#多重映射\"}},[t._v(\"#\")]),t._v(\" 多重映射\")]),t._v(\" \"),a(\"p\",[t._v(\"要了解多重映射的工作原理，我们需要简要解释虚拟内存和物理内存之间的区别。 物理内存是系统可用的实际内存，通常是安装的DRAM芯片的容量。 虚拟内存是抽象的，这意味着应用程序对（通常是隔离的）物理内存有自己的视图。 操作系统负责维护虚拟内存和物理内存范围之间的映射，它通过使用页表和处理器的内存管理单元（MMU）和转换查找缓冲器（TLB）来实现这一点，后者转换应用程序请求的地址。\\n多重映射涉及将不同范围的虚拟内存映射到同一物理内存。 由于设计中只有一个remap，mark0和mark1在任何时间点都可以为1，因此可以使用三个映射来完成此操作。 ZGC源代码中有一个很好的图表可以说明这一点。\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"读屏障\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#读屏障\"}},[t._v(\"#\")]),t._v(\" 读屏障\")]),t._v(\" \"),a(\"p\",[t._v(\"读屏障是每当应用程序线程从堆加载引用时运行的代码片段（即访问对象上的非原生字段non-primitive field）：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- line-numbers-mode\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"void printName( Person person ) {\\n    String name = person.name;  // 这里触发读屏障\\n                                // 因为需要从heap读取引用 \\n                                // \\n    System.out.println(name);   // 这里没有直接触发读屏障\\n}\\n\")])]),t._v(\" \"),a(\"div\",{staticClass:\"line-numbers-wrapper\"},[a(\"span\",{staticClass:\"line-number\"},[t._v(\"1\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[t._v(\"2\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[t._v(\"3\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[t._v(\"4\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[t._v(\"5\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[t._v(\"6\")]),a(\"br\")])]),a(\"p\",[t._v(\"复制代码在上面的代码中，String name = person.name 访问了堆上的person引用，然后将引用加载到本地的name变量。此时触发读屏障。 Systemt.out那行不会直接触发读屏障，因为没有来自堆的引用加载（name是局部变量，因此没有从堆加载引用）。 但是System和out，或者println内部可能会触发其他读屏障。\\n这与其他GC使用的写屏障形成对比，例如G1。读屏障的工作是检查引用的状态，并在将引用（或者甚至是不同的引用）返回给应用程序之前执行一些工作。 在ZGC中，它通过测试加载的引用来执行此任务，以查看是否设置了某些位。 如果通过了测试，则不执行任何其他工作，如果失败，则在将引用返回给应用程序之前执行某些特定于阶段的任务。\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"标记\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#标记\"}},[t._v(\"#\")]),t._v(\" 标记\")]),t._v(\" \"),a(\"p\",[t._v(\"现在我们了解了这两种新技术是什么，让我们来看看ZG的GC循环。\\nGC循环的第一部分是标记。标记包括查找和标记运行中的应用程序可以访问的所有堆对象，换句话说，查找不是垃圾的对象。\\nZGC的标记分为三个阶段。 第一阶段是STW，其中GC roots被标记为活对象。 GC roots类似于局部变量，通过它可以访问堆上其他对象。 如果一个对象不能通过遍历从roots开始的对象图来访问，那么应用程序也就无法访问它，则该对象被认为是垃圾。从roots访问的对象集合称为Live集。GC roots标记步骤非常短，因为roots的总数通常比较小。\")]),t._v(\" \"),a(\"p\",[t._v(\"该阶段完成后，应用程序恢复执行，ZGC开始下一阶段，该阶段同时遍历对象图并标记所有可访问的对象。 在此阶段期间，读屏障针使用掩码测试所有已加载的引用，该掩码确定它们是否已标记或尚未标记，如果尚未标记引用，则将其添加到队列以进行标记。\\n在遍历完成之后，有一个最终的，时间很短的的Stop The World阶段，这个阶段处理一些边缘情况（我们现在将它忽略），该阶段完成之后标记阶段就完成了。\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"重定位\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#重定位\"}},[t._v(\"#\")]),t._v(\" 重定位\")]),t._v(\" \"),a(\"p\",[t._v(\"GC循环的下一个主要部分是重定位。重定位涉及移动活动对象以释放部分堆内存。 为什么要移动对象而不是填补空隙？ 有些GC实际是这样做的，但是它导致了一个不幸的后果，即分配内存变得更加昂贵，因为当需要分配内存时，内存分配器需要找到可以放置对象的空闲空间。 相比之下，如果可以释放大块内存，那么分配内存就很简单，只需要将指针递增新对象所需的内存大小即可。\\nZGC将堆分成许多页面，在此阶段开始时，它同时选择一组需要重定位活动对象的页面。选择重定位集后，会出现一个Stop The World暂停，其中ZGC重定位该集合中root对象，并将他们的引用映射到新位置。与之前的Stop The World步骤一样，此处涉及的暂停时间仅取决于root的数量以及重定位集的大小与对象的总活动集的比率，这通常相当小。所以不像很多收集器那样，暂停时间随堆增加而增加。\")])])}),[],!1,null,null,null);e.default=s.exports}}]);","extractedComments":[]}