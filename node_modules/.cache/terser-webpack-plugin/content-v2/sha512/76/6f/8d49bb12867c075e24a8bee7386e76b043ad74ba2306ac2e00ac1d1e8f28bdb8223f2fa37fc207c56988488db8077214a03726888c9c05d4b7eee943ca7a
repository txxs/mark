{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{441:function(s,p,e){\"use strict\";e.r(p);var t=e(13),i=Object(t.a)({},(function(){var s=this,p=s.$createElement,e=s._self._c||p;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[e(\"p\",[s._v(\"consul也使用了gossip协议\")]),s._v(\" \"),e(\"p\",[s._v(\"原文地址：\")]),s._v(\" \"),e(\"p\",[s._v(\"https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-cluster.md#%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E5%86%85%E9%83%A8%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6\")]),s._v(\" \"),e(\"p\",[s._v(\"https://segmentfault.com/p/1210000009708869/read\")]),s._v(\" \"),e(\"p\",[s._v(\"集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。\"),e(\"strong\",[s._v(\"这里说明一下redis采用的是Gossip协议的方式\")])]),s._v(\" \"),e(\"p\",[s._v(\"集中式是将集群元数据（节点信息、故障等等）几种存储在某个节点上。集中式元数据集中存储的一个典型代表，就是大数据领域的 storm。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于 zookeeper（分布式协调的中间件）对所有元数据进行存储维护。\")]),s._v(\" \"),e(\"p\",[s._v(\"redis 维护集群元数据采用另一个方式， gossip 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。\")]),s._v(\" \"),e(\"p\",[s._v(\"集中式的好处在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；不好在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。\")]),s._v(\" \"),e(\"p\",[s._v(\"gossip 好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。\")]),s._v(\" \"),e(\"h3\",{attrs:{id:\"gossip\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#gossip\"}},[s._v(\"#\")]),s._v(\" gossip\")]),s._v(\" \"),e(\"p\",[s._v(\"gossip 协议包含多种消息，包含 ping,pong,meet,fail 等等。\")]),s._v(\" \"),e(\"p\",[s._v(\"meet：某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信。\")]),s._v(\" \"),e(\"p\",[s._v(\"其实内部就是发送了一个 gossip meet 消息给新加入的节点，通知那个节点去加入我们的集群。\")]),s._v(\" \"),e(\"p\",[s._v(\"ping：每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据。\")]),s._v(\" \"),e(\"p\",[s._v(\"pong：返回 ping 和 meeet，包含自己的状态和其它信息，也用于信息广播和更新。\")]),s._v(\" \"),e(\"p\",[s._v(\"fail：某个节点判断另一个节点 fail 之后，就发送 fail 给其它节点，通知其它节点说，某个节点宕机啦。\")]),s._v(\" \"),e(\"p\",[s._v(\"ping 消息深入\")]),s._v(\" \"),e(\"p\",[s._v(\"ping 时要携带一些元数据，如果很频繁，可能会加重网络负担。\")]),s._v(\" \"),e(\"p\",[s._v(\"每个节点每秒会执行 10 次 ping，每次会选择 5 个最久没有通信的其它节点。当然如果发现某个节点通信延时达到了 cluster_node_timeout / 2，那么立即发送 ping，避免数据交换延时过长，落后的时间太长了。比如说，两个节点之间都 10 分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。所以 cluster_node_timeout 可以调节，如果调得比较大，那么会降低 ping 的频率。\")]),s._v(\" \"),e(\"p\",[s._v(\"每次 ping，会带上自己节点的信息，还有就是带上 1/10 其它节点的信息，发送出去，进行交换。至少包含 3 个其它节点的信息，最多包含 总节点数减 2 个其它节点的信息。\")]),s._v(\" \"),e(\"h3\",{attrs:{id:\"redis为什么用gossip\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis为什么用gossip\"}},[s._v(\"#\")]),s._v(\" redis为什么用gossip\")]),s._v(\" \"),e(\"p\",[s._v(\"主要是维护节点的信息，而不是数据的信息，实时性的要求没有那么高\")])])}),[],!1,null,null,null);p.default=i.exports}}]);","extractedComments":[]}