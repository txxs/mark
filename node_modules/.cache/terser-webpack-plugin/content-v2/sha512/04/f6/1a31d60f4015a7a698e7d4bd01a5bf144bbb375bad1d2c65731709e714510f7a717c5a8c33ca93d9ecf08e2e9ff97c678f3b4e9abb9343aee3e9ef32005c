{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{413:function(o,n,l){\"use strict\";l.r(n);var _=l(13),g=Object(_.a)({},(function(){var o=this,n=o.$createElement,l=o._self._c||n;return l(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":o.$parent.slotKey}},[l(\"h3\",{attrs:{id:\"mysql中的重做日志-redo-log-回滚日志-undo-log-以及二进制日志-binlog-的简单总结\"}},[l(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql中的重做日志-redo-log-回滚日志-undo-log-以及二进制日志-binlog-的简单总结\"}},[o._v(\"#\")]),o._v(\" MySQL中的重做日志（redo log），回滚日志（undo log），以及二进制日志（binlog）的简单总结\")]),o._v(\" \"),l(\"p\",[o._v(\"原文：https://www.cnblogs.com/wy123/p/8365234.html\")]),o._v(\" \"),l(\"p\",[o._v(\"MySQL中有六种日志文件，\\n分别是：重做日志（redo log）、回滚日志（undo log）、二进制日志（binlog）、错误日志（errorlog）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log）。\\n其中重做日志和回滚日志与事务操作息息相关，二进制日志也与事务操作有一定的关系，这三种日志，对理解MySQL中的事务操作有着重要的意义。\\n这里简单总结一下这三者具有一定相关性的日志。\")]),o._v(\" \"),l(\"p\",[o._v(\"重做日志（redo log）\\n作用：\\n　　确保事务的持久性。\\n　　防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。\\n内容：\\n　　物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。\\n什么时候产生：\\n　　事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。\\n什么时候释放：\\n　　当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。\\n其他：\\n　　很重要一点，redo log是什么时候写盘的？前面说了是在事物开始之后逐步写盘的。\\n　　之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，\\n　　原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。\\n　然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘\\n　　1，Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。\\n　　2，每个事务提交时会将重做日志刷新到重做日志文件。\\n　　3，当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件\")]),o._v(\" \"),l(\"p\",[o._v(\"回滚日志（undo log）\\n作用：\\n　　保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读\")]),o._v(\" \"),l(\"p\",[o._v(\"内容：\\n　　逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。\")]),o._v(\" \"),l(\"p\",[o._v(\"什么时候产生：\\n　　事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性\")]),o._v(\" \"),l(\"p\",[o._v(\"什么时候释放：\\n　　当事务提交之后，undo log并不能立马被删除，\\n　　而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。\")]),o._v(\" \"),l(\"p\",[o._v(\"二进制日志（binlog）：\\n作用：\\n　　1，用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。\\n　　2，用于数据库的基于时间点的还原。\\n内容：\\n　　逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。\\n　　但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）反向的信息，\\n　　也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。\\n　　在使用mysqlbinlog解析binlog之后一些都会真相大白。\\n　　因此可以基于binlog做到类似于oracle的闪回功能，其实都是依赖于binlog中的日志记录。\")]),o._v(\" \"),l(\"p\",[o._v(\"什么时候产生：\\n　　事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。\\n　　这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。\\n　　因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。\\n　　这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。\")]),o._v(\" \"),l(\"p\",[o._v(\"https://www.cnblogs.com/wjoyxt/p/4806262.html\")]),o._v(\" \"),l(\"p\",[o._v(\"什么是binlog\")]),o._v(\" \"),l(\"p\",[o._v(\"binlog日志用于记录所有更新且提交了数据或者已经潜在更新提交了数据（例如，没有匹配任何行的一个DELETE）的所有语句。语句以“事件”的形式保存，它描述数据更改。\")]),o._v(\" \"),l(\"p\",[o._v(\"binlog作用\")]),o._v(\" \"),l(\"p\",[o._v(\"1.恢复使能够最大可能地更新数据库，因为二进制日志包含备份后进行的所有更新。\\n2.在主复制服务器上记录所有将发送给从服务器的语句。\")]),o._v(\" \"),l(\"p\",[o._v(\"binlog 主要参数\")]),o._v(\" \"),l(\"p\",[o._v(\"log_bin\\n设置此参数表示启用binlog功能，并指定路径名称\")]),o._v(\" \"),l(\"p\",[o._v(\"innodb_flush_log_at_trx_commit = N：\")]),o._v(\" \"),l(\"p\",[o._v(\"N=0  – 每隔一秒，把事务日志缓存区的数据写到日志文件中，以及把日志文件的数据刷新到磁盘上；\")]),o._v(\" \"),l(\"p\",[o._v(\"N=1  – 每个事务提交时候，把事务日志从缓存区写到日志文件中，并且刷新日志文件的数据到磁盘上；\")]),o._v(\" \"),l(\"p\",[o._v(\"N=2  – 每事务提交的时候，把事务日志数据从缓存区写到日志文件中；每隔一秒，刷新一次日志文件，但不一定刷新到磁盘上，而是取决于操作系统的调度；\")]),o._v(\" \"),l(\"p\",[o._v(\"sync_binlog =  N：\")]),o._v(\" \"),l(\"p\",[o._v(\"N>0  — 每向二进制日志文件写入N条SQL或N个事务后，则把二进制日志文件的数据刷新到磁盘上；\")]),o._v(\" \"),l(\"p\",[o._v(\"N=0  — 不主动刷新二进制日志文件的数据到磁盘上，而是由操作系统决定；\")]),o._v(\" \"),l(\"p\",[o._v(\"推荐配置组合：\")]),o._v(\" \"),l(\"p\",[o._v(\"N=1,1  — 适合数据安全性要求非常高，而且磁盘IO写能力足够支持业务，比如充值消费系统；\")]),o._v(\" \"),l(\"p\",[o._v(\"N=1,0  — 适合数据安全性要求高，磁盘IO写能力支持业务不富余，允许备库落后或无复制；\")]),o._v(\" \"),l(\"p\",[o._v(\"N=2,0或2,m(0<m<100)  — 适合数据安全性有要求，允许丢失一点事务日志，复制架构的延迟也能接受；\")]),o._v(\" \"),l(\"p\",[o._v(\"N=0,0  — 磁盘IO写能力有限，无复制或允许复制延迟稍微长点能接受，例如：日志性登记业务；\")]),o._v(\" \"),l(\"p\",[o._v(\"Undo Log\")]),o._v(\" \"),l(\"p\",[o._v(\"Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用UndoLog来实现多版本并发控制(简称：MVCC)。\\n-事务的原子性(Atomicity)\\n事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。\")]),o._v(\" \"),l(\"p\",[o._v(\"-原理\\nUndo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。\\n然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用UndoLog中的备份将数据恢复到事务开始之前的状态。\\n除了可以保证事务的原子性，Undo Log也可以用来辅助完成事务的持久化。\")]),o._v(\" \"),l(\"p\",[o._v(\"-事务的持久性(Durability)\\n事务一旦完成，该事务对数据库所做的所有修改都会持久的保存到数据库中。为了保证持久性，数据库系统会将修改后的数据完全的记录到持久的存储上。\")]),o._v(\" \"),l(\"p\",[o._v(\"-用Undo Log\")]),o._v(\" \"),l(\"p\",[o._v(\"实现原子性和持久化的事务的简化过程\")]),o._v(\" \"),l(\"p\",[o._v(\"假设有A、B两个数据，值分别为1,2。\\nA.事务开始.\\nB.记录A=1到undolog.\\nC.修改A=3.\\nD.记录B=2到undolog.\\nE.修改B=4.\\nF.将undolog写到磁盘。\\nG.将数据写到磁盘。\\nH.事务提交\\n这里有一个隐含的前提条件：‘数据都是先读到内存中，然后修改内存中的数据，最后将数据写回磁盘’。\\n之所以能同时保证原子性和持久化，是因为以下特点：\\nA.更新数据前记录Undo log。\\nB.为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。\\nC.Undo log\\n必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的，可以用来回滚事务。\")]),o._v(\" \"),l(\"p\",[o._v(\"D.如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。\")]),o._v(\" \"),l(\"p\",[o._v(\"缺陷：每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。\\n如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即\")]),o._v(\" \"),l(\"p\",[o._v(\"Redo log\\n记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，\\n但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。\")]),o._v(\" \"),l(\"p\",[o._v(\"首先介绍下Innodb redo log是什么，为什么需要记录redo log，以及redo log的作用都有哪些。这些作为常识，只是为了本文完整。\")]),o._v(\" \"),l(\"p\",[o._v(\"InnoDB有buffer pool（简称bp）。bp是数据库页面的缓存，对InnoDB的任何修改操作都会首先在bp的page上进行，然后这样的页面将被标记为dirty并被放到专门的flush list上，后续将由master thread或专门的刷脏线程阶段性的将这些页面写入磁盘（disk or ssd）。这样的好处是避免每次写操作都操作磁盘导致大量的随机IO，阶段性的刷脏可以将多次对页面的修改merge成一次IO操作，同时异步写入也降低了访问的时延。然而，如果在dirty page还未刷入磁盘时，server非正常关闭，这些修改操作将会丢失，如果写入操作正在进行，甚至会由于损坏数据文件导致数据库不可用。为了避免上述问题的发生，Innodb将所有对页面的修改操作写入一个专门的文件，并在数据库启动时从此文件进行恢复操作，这个文件就是redo log file。这样的技术推迟了bp页面的刷新，从而提升了数据库的吞吐，有效的降低了访问时延。带来的问题是额外的写redo log操作的开销（顺序IO，当然很快），以及数据库启动时恢复操作所需的时间。\")]),o._v(\" \"),l(\"p\",[o._v(\"-Undo+Redo\\n事务的简化过程\\n假设有A、B两个数据，值分别为1,2.\\nA.事务开始.\\nB.记录A=1到undolog.\\nC.修改A=3.\\nD.记录A=3到redolog.\\nE.记录B=2到undolog.\\nF.修改B=4.\\nG.记录B=4到redolog.\\nH.将redolog写入磁盘。\\nI.事务提交\")]),o._v(\" \"),l(\"p\",[o._v(\"-Undo+Redo\\n事务的特点\\nA.为了保证持久性，必须在事务提交前将RedoLog持久化。\\nB.数据不需要在事务提交前写入磁盘，而是缓存在内存中。\\nC.RedoLog保证事务的持久性。\\nD.UndoLog保证事务的原子性。\\nE.有一个隐含的特点，数据必须要晚于redolog写入持久存\")])])}),[],!1,null,null,null);n.default=g.exports}}]);","extractedComments":[]}