{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[164],{550:function(e,v,t){\"use strict\";t.r(v);var a=t(13),o=Object(a.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[t(\"p\",[e._v(\"原文地址：\")]),e._v(\" \"),t(\"p\",[e._v(\"https://juejin.im/entry/598da7d16fb9a03c42431ed3\")]),e._v(\" \"),t(\"p\",[e._v(\"https://segmentfault.com/a/1190000012976683\")]),e._v(\" \"),t(\"p\",[e._v(\"这里先给出BIO、NIO、AIO的基本定义与类比描述：\")]),e._v(\" \"),t(\"p\",[e._v(\"BIO （Blocking I/O）：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。这里使用那个经典的烧开水例子，这里假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是， 叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做。\")]),e._v(\" \"),t(\"p\",[e._v(\"NIO （New I/O）：同时支持阻塞与非阻塞模式，但这里我们以其同步非阻塞I/O模式来说明，那么什么叫做同步非阻塞？如果还拿烧开水来说，NIO的做法是叫一个线程不断的轮询每个水壶的状态，看看是否有水壶的状态发生了改变，从而进行下一步的操作。\")]),e._v(\" \"),t(\"p\",[e._v(\"AIO （ Asynchronous I/O）：异步非阻塞I/O模型。异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。对应到烧开水中就是，为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。\")]),e._v(\" \"),t(\"p\",[e._v(\"进程中的IO调用步骤大致可以分为以下四步：\")]),e._v(\" \"),t(\"p\",[e._v(\"1、进程向操作系统请求数据 ;\")]),e._v(\" \"),t(\"p\",[e._v(\"2、操作系统把外部数据加载到内核的缓冲区中;\")]),e._v(\" \"),t(\"p\",[e._v(\"3、操作系统把内核的缓冲区拷贝到进程的缓冲区 ;\")]),e._v(\" \"),t(\"p\",[e._v(\"4、进程获得数据完成自己的功能 ;\")]),e._v(\" \"),t(\"p\",[t(\"strong\",[e._v(\"当操作系统在把外部数据放到进程缓冲区的这段时间（即上述的第二，三步），如果应用进程是挂起等待的，那么就是同步IO，反之，就是异步IO，也就是AIO 。\")])]),e._v(\" \"),t(\"h3\",{attrs:{id:\"bio-blocking-i-o-同步阻塞i-o\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#bio-blocking-i-o-同步阻塞i-o\"}},[e._v(\"#\")]),e._v(\" BIO（Blocking I/O）同步阻塞I/O\")]),e._v(\" \"),t(\"p\",[e._v(\"这是最基本与简单的I/O操作方式，其根本特性是做完一件事再去做另一件事，一件事一定要等前一件事做完，这很符合程序员传统的顺序来开发思想，因此BIO模型程序开发起来较为简单，易于把握。\")]),e._v(\" \"),t(\"p\",[e._v(\"但是BIO如果需要同时做很多事情（例如同时读很多文件，处理很多tcp请求等），就需要系统创建很多线程来完成对应的工作，因为BIO模型下一个线程同时只能做一个工作，如果线程在执行过程中依赖于需要等待的资源，那么该线程会长期处于阻塞状态，我们知道在整个操作系统中，线程是系统执行的基本单位，在BIO模型下的线程 阻塞就会导致系统线程的切换，从而对整个系统性能造成一定的影响。当然如果我们只需要创建少量可控的线程，那么采用BIO模型也是很好的选择，但如果在需要考虑高并发的web或者tcp服务器中采用BIO模型就无法应对了，如果系统开辟成千上万的线程，那么CPU的执行时机都会浪费在线程的切换中，使得线程的执行效率大大降低。此外，关于线程这里说一句题外话，在系统开发中线程的生命周期一定要准确控制，在需要一定规模并发的情形下，尽量使用线程池来确保线程创建数目在一个合理的范围之内，切莫编写线程数量创建上限的代码。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"nio-new-i-o-同步非阻塞i-o\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#nio-new-i-o-同步非阻塞i-o\"}},[e._v(\"#\")]),e._v(\" NIO (New I/O) 同步非阻塞I/O\")]),e._v(\" \"),t(\"p\",[e._v(\"关于NIO，国内有很多技术博客将英文翻译成No-Blocking I/O，非阻塞I/O模型 ，当然这样就与BIO形成了鲜明的特性对比。NIO本身是基于事件驱动的思想来实现的，其目的就是解决BIO的大并发问题，在BIO模型中，如果需要并发处理多个I/O请求，那就需要多线程来支持，NIO使用了多路复用器机制，以socket使用来说，多路复用器通过不断轮询各个连接的状态，只有在socket有流可读或者可写时，应用程序才需要去处理它，在线程的使用上，就不需要一个连接就必须使用一个处理线程了，而是只是有效请求时（确实需要进行I/O处理时），才会使用一个线程去处理，这样就避免了BIO模型下大量线程处于阻塞等待状态的情景。\")]),e._v(\" \"),t(\"p\",[e._v(\"相对于BIO的流，NIO抽象出了新的通道（Channel）作为输入输出的通道，并且提供了缓存（Buffer）的支持，在进行读操作时，需要使用Buffer分配空间，然后将数据从Channel中读入Buffer中，对于Channel的写操作，也需要现将数据写入Buffer，然后将Buffer写入Channel中。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"aio-asynchronous-i-o-异步非阻塞i-o\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#aio-asynchronous-i-o-异步非阻塞i-o\"}},[e._v(\"#\")]),e._v(\" AIO (Asynchronous I/O) 异步非阻塞I/O\")]),e._v(\" \"),t(\"p\",[e._v(\"Java AIO就是Java作为对异步IO提供支持的NIO.2 ，Java NIO2 (JSR 203)定义了更多的 New I/O APIs， 提案2003提出，直到2011年才发布， 最终在JDK 7中才实现。JSR 203除了提供更多的文件系统操作API(包括可插拔的自定义的文件系统)， 还提供了对socket和文件的异步 I/O操作。 同时实现了JSR-51提案中的socket channel全部功能,包括对绑定， option配置的支持以及多播multicast的实现。\")]),e._v(\" \"),t(\"p\",[e._v(\"从编程模式上来看AIO相对于NIO的区别在于，NIO需要使用者线程不停的轮询IO对象，来确定是否有数据准备好可以读了，而AIO则是在数据准备好之后，才会通知数据使用者，这样使用者就不需要不停地轮询了。当然AIO的异步特性并不是Java实现的伪异步，而是使用了系统底层API的支持，在Unix系统下，采用了epoll IO模型，而windows便是使用了IOCP模型。关于Java AIO，本篇只做一个抛砖引玉的介绍，如果你在实际工作中用到了，那么可以参考Netty在高并发下使用AIO的相关技术。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"_1-io-nio-aio区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-io-nio-aio区别\"}},[e._v(\"#\")]),e._v(\" 1 IO，NIO，AIO区别\")]),e._v(\" \"),t(\"p\",[e._v(\"IO 阻塞同步通信模式，客户端和服务器连接需要三次握手，使用简单，但吞吐量小\")]),e._v(\" \"),t(\"p\",[e._v(\"NIO 非阻塞同步通信模式，客户端与服务器通过Channel连接，采用多路复用器轮询注册的Channel。提高吞吐量和可靠性。\")]),e._v(\" \"),t(\"p\",[e._v(\"AIO 非阻塞异步通信模式，NIO的升级版，采用异步通道实现异步通信，其read和write方法均是异步方法。\")]),e._v(\" \"),t(\"p\",[e._v(\"1 BIO模型中通过Socket和ServerSocket完成套接字通道实现。阻塞，同步，连接耗时。\")]),e._v(\" \"),t(\"p\",[e._v(\"2 NIO模型中通过SocketChannel和ServerSocketChannel完成套接字通道实现。非阻塞/阻塞，同步，避免TCP建立连接使用三次握手带来的开销。\")]),e._v(\" \"),t(\"p\",[e._v(\"3 AIO模型中通过AsynchronousSocketChannel和AsynchronousServerSocketChannel完成套接字通道实现。非阻塞，异步。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"stock通信的伪代码实现流程\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#stock通信的伪代码实现流程\"}},[e._v(\"#\")]),e._v(\" Stock通信的伪代码实现流程\")]),e._v(\" \"),t(\"p\",[e._v(\"服务器绑定端口：server = new ServerSocket(PORT)\")]),e._v(\" \"),t(\"p\",[e._v(\"服务器阻塞监听：socket = server.accept()\")]),e._v(\" \"),t(\"p\",[e._v(\"服务器开启线程：new Thread(Handle handle)\")]),e._v(\" \"),t(\"p\",[e._v(\"服务器读写数据：BufferedReader PrintWriter\")]),e._v(\" \"),t(\"p\",[e._v(\"客户端绑定IP和PORT：new Socket(IP_ADDRESS, PORT)\")]),e._v(\" \"),t(\"p\",[e._v(\"客户端传输接收数据：BufferedReader PrintWriter\")])])}),[],!1,null,null,null);v.default=o.exports}}]);","extractedComments":[]}