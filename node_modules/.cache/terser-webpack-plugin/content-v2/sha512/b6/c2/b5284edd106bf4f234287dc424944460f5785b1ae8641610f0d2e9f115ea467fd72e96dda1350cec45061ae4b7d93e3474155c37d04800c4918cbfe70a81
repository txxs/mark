{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{489:function(t,v,_){\"use strict\";_.r(v);var a=_(13),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[_(\"p\",[t._v(\"原文地址\")]),t._v(\" \"),_(\"p\",[t._v(\"https://www.jdon.com/DistributedSystems.html\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"如何架构分布式系统\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何架构分布式系统\"}},[t._v(\"#\")]),t._v(\" 如何架构分布式系统\")]),t._v(\" \"),_(\"p\",[t._v(\"适用于分布式系统架构的最常见的一个术语是SOA(面向服务架构)。SOA可以避免不愉快的CORBA(公共对象请求代理体系结构)，通过WS - *标准，一套松散耦合的Web服务完成独立的小功能，并且彼此独立，他们是一个有弹性的分布式系统的基础。对比上一代，服务是新流程，他们是正确的抽象层次系统中的离散功能。\")]),t._v(\" \"),_(\"p\",[t._v(\"构建面向服务架构的第一步是确定每个函数功能如何构成整体业务目标，将这些业务映射到离散的服务，且具有独立的断层边界、扩展性和数据负载量。确定为每个服务时，您必须考虑下列事项：\")]),t._v(\" \"),_(\"p\",[t._v(\"1、地理. 系统是全球还是地区单独运行？\")]),t._v(\" \"),_(\"p\",[t._v(\"2、数据隔离. 这个系统提供一个单个或多租户模型？\")]),t._v(\" \"),_(\"p\",[t._v(\"3、SLAs. 可用性 延迟 吞吐量 一致性和冗余性都必须定义。\")]),t._v(\" \"),_(\"p\",[t._v(\"4、安全. IAAA (身份identity, 验证authentication, 授权authorization, 和 审核audit), 数据的保密性和隐私性都必须考虑\")]),t._v(\" \"),_(\"p\",[t._v(\"5、可用性跟踪. 了解系统的使用是每天系统的日常运作，如容量规划。也可能用于执行计费系统的使用和/或治理(配额/速度限制)。\")]),t._v(\" \"),_(\"p\",[t._v(\"6、部署和配置管理. 系统是如何部署更新?\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"分布式系统的模型抽象\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分布式系统的模型抽象\"}},[t._v(\"#\")]),t._v(\" 分布式系统的模型抽象\")]),t._v(\" \"),_(\"p\",[t._v(\"1、系统模型（异步/同步）\")]),t._v(\" \"),_(\"p\",[t._v(\"2、失效模型（崩溃故障，分区）\")]),t._v(\" \"),_(\"p\",[t._v(\"3、一致性模型（强，最终）\")]),t._v(\" \"),_(\"p\",[t._v(\"通常，我们最熟悉的模式（例如，一个分布式系统上实现共享内存抽象）是太昂贵了。一个分布式系统越弱势越能保证其中元素有更大的行动自由，从而焕发潜在的更大的性能- 但它也可能导致很难管理。这就需要我们有极大智慧，不能以牺牲性能换来管理的方便性。因此，试图将分布式系统看成一个统一的单一系统的思维会阻碍分布式系统的扩展。\")]),t._v(\" \"),_(\"p\",[t._v(\"分布式系统遵循CAP定律，在高一致性 高可用性和分区容错性之间三选二：\")]),t._v(\" \"),_(\"p\",[t._v(\"1、CA (consistency高一致性 + availability高可用性). 使用2pc 两阶段事务提交来保证。其缺点无法实现分区容错性，一旦某个操作失败，整个系统就出错，无法容忍(水至清则无鱼)。\")]),t._v(\" \"),_(\"p\",[t._v(\"2、CP (consistency高一致性 + partition tolerance分区容错性). 使用Paxos来保证，可用性降低。\")]),t._v(\" \"),_(\"p\",[t._v(\"3、AP (availability高可用性 + partition tolerance分区容错性). 使用Gossip等实现最终一致性，如Dynamo.\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"分布式系统的设计技巧-分区和复制\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分布式系统的设计技巧-分区和复制\"}},[t._v(\"#\")]),t._v(\" 分布式系统的设计技巧：分区和复制\")]),t._v(\" \"),_(\"p\",[t._v(\"对于一个数据集有两种设计方式：\")]),t._v(\" \"),_(\"p\",[t._v(\"1、分区：它可以被分割在多个节点，以允许更多的并行处理。有更好的性能，但是容错能力低。\")]),t._v(\" \"),_(\"p\",[t._v(\"2、复制：它也可以被复制或缓存在不同的节点上，以减少在客户端和服务器之间的距离，更强的容错能力，但是复制消耗性能。关键是复制数据之间的一致性。弱一致性提供更低的延迟和更高的可用性。\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"分布式系统的设计技巧-时钟和顺序\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分布式系统的设计技巧-时钟和顺序\"}},[t._v(\"#\")]),t._v(\" 分布式系统的设计技巧：时钟和顺序\")]),t._v(\" \"),_(\"p\",[t._v(\"分布式系统针对计算和存储的策略是不同的，对于数据的存储主要是分区和复制，而对于计算主要是保证事件的顺序，因为分布式计算任务是由事件驱动的，比如Storm等等。那么事件的顺序代表了业务逻辑的顺序，事件有时是树形嵌套事件，可靠性就是必须保证一个树形集合所有事件都得到网站执行是一个事务原子的。参考流式大数据处理模式。\")]),t._v(\" \"),_(\"p\",[t._v(\"原文地址\")]),t._v(\" \"),_(\"p\",[t._v(\"https://www.jdon.com/DistributedSystems.html\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"如何架构分布式系统-2\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何架构分布式系统-2\"}},[t._v(\"#\")]),t._v(\" 如何架构分布式系统\")]),t._v(\" \"),_(\"p\",[t._v(\"适用于分布式系统架构的最常见的一个术语是SOA(面向服务架构)。SOA可以避免不愉快的CORBA(公共对象请求代理体系结构)，通过WS - *标准，一套松散耦合的Web服务完成独立的小功能，并且彼此独立，他们是一个有弹性的分布式系统的基础。对比上一代，服务是新流程，他们是正确的抽象层次系统中的离散功能。\")]),t._v(\" \"),_(\"p\",[t._v(\"构建面向服务架构的第一步是确定每个函数功能如何构成整体业务目标，将这些业务映射到离散的服务，且具有独立的断层边界、扩展性和数据负载量。确定为每个服务时，您必须考虑下列事项：\")]),t._v(\" \"),_(\"p\",[t._v(\"1、地理. 系统是全球还是地区单独运行？\")]),t._v(\" \"),_(\"p\",[t._v(\"2、数据隔离. 这个系统提供一个单个或多租户模型？\")]),t._v(\" \"),_(\"p\",[t._v(\"3、SLAs. 可用性 延迟 吞吐量 一致性和冗余性都必须定义。\")]),t._v(\" \"),_(\"p\",[t._v(\"4、安全. IAAA (身份identity, 验证authentication, 授权authorization, 和 审核audit), 数据的保密性和隐私性都必须考虑\")]),t._v(\" \"),_(\"p\",[t._v(\"5、可用性跟踪. 了解系统的使用是每天系统的日常运作，如容量规划。也可能用于执行计费系统的使用和/或治理(配额/速度限制)。\")]),t._v(\" \"),_(\"p\",[t._v(\"6、部署和配置管理. 系统是如何部署更新?\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"分布式系统的模型抽象-2\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分布式系统的模型抽象-2\"}},[t._v(\"#\")]),t._v(\" 分布式系统的模型抽象\")]),t._v(\" \"),_(\"p\",[t._v(\"1、系统模型（异步/同步）\")]),t._v(\" \"),_(\"p\",[t._v(\"2、失效模型（崩溃故障，分区）\")]),t._v(\" \"),_(\"p\",[t._v(\"3、一致性模型（强，最终）\")]),t._v(\" \"),_(\"p\",[t._v(\"通常，我们最熟悉的模式（例如，一个分布式系统上实现共享内存抽象）是太昂贵了。一个分布式系统越弱势越能保证其中元素有更大的行动自由，从而焕发潜在的更大的性能- 但它也可能导致很难管理。这就需要我们有极大智慧，不能以牺牲性能换来管理的方便性。因此，试图将分布式系统看成一个统一的单一系统的思维会阻碍分布式系统的扩展。\")]),t._v(\" \"),_(\"p\",[t._v(\"分布式系统遵循CAP定律，在高一致性 高可用性和分区容错性之间三选二：\")]),t._v(\" \"),_(\"p\",[t._v(\"1、CA (consistency高一致性 + availability高可用性). 使用2pc 两阶段事务提交来保证。其缺点无法实现分区容错性，一旦某个操作失败，整个系统就出错，无法容忍(水至清则无鱼)。\")]),t._v(\" \"),_(\"p\",[t._v(\"2、CP (consistency高一致性 + partition tolerance分区容错性). 使用Paxos来保证，可用性降低。\")]),t._v(\" \"),_(\"p\",[t._v(\"3、AP (availability高可用性 + partition tolerance分区容错性). 使用Gossip等实现最终一致性，如Dynamo.\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"分布式系统的设计技巧-分区和复制-2\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分布式系统的设计技巧-分区和复制-2\"}},[t._v(\"#\")]),t._v(\" 分布式系统的设计技巧：分区和复制\")]),t._v(\" \"),_(\"p\",[t._v(\"对于一个数据集有两种设计方式：\")]),t._v(\" \"),_(\"p\",[t._v(\"1、分区：它可以被分割在多个节点，以允许更多的并行处理。有更好的性能，但是容错能力低。\")]),t._v(\" \"),_(\"p\",[t._v(\"2、复制：它也可以被复制或缓存在不同的节点上，以减少在客户端和服务器之间的距离，更强的容错能力，但是复制消耗性能。关键是复制数据之间的一致性。弱一致性提供更低的延迟和更高的可用性。\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"分布式系统的设计技巧-时钟和顺序-2\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分布式系统的设计技巧-时钟和顺序-2\"}},[t._v(\"#\")]),t._v(\" 分布式系统的设计技巧：时钟和顺序\")]),t._v(\" \"),_(\"p\",[t._v(\"分布式系统针对计算和存储的策略是不同的，对于数据的存储主要是分区和复制，而对于计算主要是保证事件的顺序，因为分布式计算任务是由事件驱动的，比如Storm等等。那么事件的顺序代表了业务逻辑的顺序，事件有时是树形嵌套事件，可靠性就是必须保证一个树形集合所有事件都得到网站执行是一个事务原子的。参考流式大数据处理模式。\")])])}),[],!1,null,null,null);v.default=s.exports}}]);","extractedComments":[]}