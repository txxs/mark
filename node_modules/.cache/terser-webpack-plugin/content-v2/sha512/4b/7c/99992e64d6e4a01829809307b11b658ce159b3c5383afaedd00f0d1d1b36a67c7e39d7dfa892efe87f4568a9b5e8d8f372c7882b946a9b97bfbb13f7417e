{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[178],{567:function(t,v,_){\"use strict\";_.r(v);var r=_(13),e=Object(r.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[_(\"p\",[_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d31382a2d77079070.jpg\",alt:\"\"}})]),t._v(\" \"),_(\"h1\",{attrs:{id:\"前言\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#前言\"}},[t._v(\"#\")]),t._v(\" 前言\")]),t._v(\" \"),_(\"p\",[t._v(\"到了年底果然都不太平，最近又收到了运维报警：表示有些服务器负载非常高，让我们定位问题。\")]),t._v(\" \"),_(\"p\",[t._v(\"还真是想什么来什么，前些天还故意把某些服务器的负载提高（\"),_(\"a\",{attrs:{href:\"https://crossoverjie.top/2018/12/12/java-senior/java-memary-allocation/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"没错，老板让我写个 BUG！\"),_(\"OutboundLink\")],1),t._v(\"），不过还好是不同的环境互相没有影响。\")]),t._v(\" \"),_(\"h1\",{attrs:{id:\"定位问题\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#定位问题\"}},[t._v(\"#\")]),t._v(\" 定位问题\")]),t._v(\" \"),_(\"p\",[t._v(\"拿到问题后首先去服务器上看了看，发现运行的只有我们的 Java 应用。于是先用 \"),_(\"code\",[t._v(\"ps\")]),t._v(\" 命令拿到了应用的 \"),_(\"code\",[t._v(\"PID\")]),t._v(\"。\")]),t._v(\" \"),_(\"p\",[t._v(\"接着使用 \"),_(\"code\",[t._v(\"top -Hp pid\")]),t._v(\" 将这个进程的线程显示出来。输入大写的 P 可以将线程按照 CPU 使用比例排序，于是得到以下结果。\")]),t._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d31382b1d3df15468.jpg\",alt:\"\"}})]),t._v(\" \"),_(\"p\",[t._v(\"果然某些线程的 CPU 使用率非常高。\")]),t._v(\" \"),_(\"p\",[t._v(\"为了方便定位问题我立马使用 \"),_(\"code\",[t._v(\"jstack pid > pid.log\")]),t._v(\" 将线程栈 \"),_(\"code\",[t._v(\"dump\")]),t._v(\" 到日志文件中。\")]),t._v(\" \"),_(\"p\",[t._v(\"我在上面 100% 的线程中随机选了一个 \"),_(\"code\",[t._v(\"pid=194283\")]),t._v(\" 转换为 16 进制（2f6eb）后在线程快照中查询：\")]),t._v(\" \"),_(\"blockquote\",[_(\"p\",[t._v(\"因为线程快照中线程 ID 都是16进制存放。\")])]),t._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d31382bb08a129414.jpg\",alt:\"\"}})]),t._v(\" \"),_(\"p\",[t._v(\"发现这是 \"),_(\"code\",[t._v(\"Disruptor\")]),t._v(\" 的一个堆栈，前段时间正好解决过一个由于 Disruptor 队列引起的一次 \"),_(\"a\",{attrs:{href:\"\"}},[t._v(\"OOM\")]),t._v(\"：\"),_(\"a\",{attrs:{href:\"https://crossoverjie.top/2018/08/29/java-senior/OOM-Disruptor/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"强如 Disruptor 也发生内存溢出？\"),_(\"OutboundLink\")],1)]),t._v(\" \"),_(\"p\",[t._v(\"没想到又来一出。\")]),t._v(\" \"),_(\"p\",[t._v(\"为了更加直观的查看线程的状态信息，我将快照信息上传到专门分析的平台上。\")]),t._v(\" \"),_(\"p\",[_(\"a\",{attrs:{href:\"http://fastthread.io/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"http://fastthread.io/\"),_(\"OutboundLink\")],1)]),t._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d31382fbe13e22162.jpg\",alt:\"\"}})]),t._v(\" \"),_(\"p\",[t._v(\"其中有一项菜单展示了所有消耗 CPU 的线程，我仔细看了下发现几乎都是和上面的堆栈一样。\")]),t._v(\" \"),_(\"p\",[t._v(\"也就是说都是 \"),_(\"code\",[t._v(\"Disruptor\")]),t._v(\" 队列的堆栈，同时都在执行 \"),_(\"code\",[t._v(\"java.lang.Thread.yield\")]),t._v(\" 函数。\")]),t._v(\" \"),_(\"p\",[t._v(\"众所周知 \"),_(\"code\",[t._v(\"yield\")]),t._v(\" 函数会让当前线程让出 \"),_(\"code\",[t._v(\"CPU\")]),t._v(\" 资源，再让其他线程来竞争。\")]),t._v(\" \"),_(\"p\",[t._v(\"根据刚才的线程快照发现处于 \"),_(\"code\",[t._v(\"RUNNABLE\")]),t._v(\" 状态并且都在执行 \"),_(\"code\",[t._v(\"yield\")]),t._v(\" 函数的线程大概有 30几个。\")]),t._v(\" \"),_(\"p\",[t._v(\"因此初步判断为大量线程执行 \"),_(\"code\",[t._v(\"yield\")]),t._v(\" 函数之后互相竞争导致 CPU 使用率增高，而通过对堆栈发现是和使用 \"),_(\"code\",[t._v(\"Disruptor\")]),t._v(\" 有关。\")]),t._v(\" \"),_(\"h1\",{attrs:{id:\"解决问题\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#解决问题\"}},[t._v(\"#\")]),t._v(\" 解决问题\")]),t._v(\" \"),_(\"p\",[t._v(\"而后我查看了代码，发现是根据每一个业务场景在内部都会使用 2 个 \"),_(\"code\",[t._v(\"Disruptor\")]),t._v(\" 队列来解耦。\")]),t._v(\" \"),_(\"p\",[t._v(\"假设现在有 7 个业务类型，那就等于是创建 \"),_(\"code\",[t._v(\"2*7=14\")]),t._v(\" 个 \"),_(\"code\",[t._v(\"Disruptor\")]),t._v(\" 队列，同时每个队列有一个消费者，也就是总共有 14 个消费者（生产环境更多）。\")]),t._v(\" \"),_(\"p\",[t._v(\"同时发现配置的消费等待策略为 \"),_(\"code\",[t._v(\"YieldingWaitStrategy\")]),t._v(\" 这种等待策略确实会执行 yield 来让出 CPU。\")]),t._v(\" \"),_(\"p\",[t._v(\"代码如下：\")]),t._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d31383063b5729406.jpg\",alt:\"\"}})]),t._v(\" \"),_(\"blockquote\",[_(\"p\",[t._v(\"初步看来和这个等待策略有很大的关系。\")])]),t._v(\" \"),_(\"h2\",{attrs:{id:\"本地模拟\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#本地模拟\"}},[t._v(\"#\")]),t._v(\" 本地模拟\")]),t._v(\" \"),_(\"p\",[t._v(\"为了验证，我在本地创建了 15 个 \"),_(\"code\",[t._v(\"Disruptor\")]),t._v(\" 队列同时结合监控观察 CPU 的使用情况。\")]),t._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d313830e683e59146.jpg\",alt:\"\"}}),t._v(\" \"),_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d3138364092a60230.jpg\",alt:\"\"}})]),t._v(\" \"),_(\"p\",[t._v(\"创建了 15 个 \"),_(\"code\",[t._v(\"Disruptor\")]),t._v(\" 队列，同时每个队列都用线程池来往 \"),_(\"code\",[t._v(\"Disruptor队列\")]),t._v(\" 里面发送 100W 条数据。\")]),t._v(\" \"),_(\"p\",[t._v(\"消费程序仅仅只是打印一下。\")]),t._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d313836ac8a448151.jpg\",alt:\"\"}})]),t._v(\" \"),_(\"p\",[t._v(\"跑了一段时间发现 CPU 使用率确实很高。\")]),t._v(\" \"),_(\"hr\"),t._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d31383d664cb51737.jpg\",alt:\"\"}})]),t._v(\" \"),_(\"p\",[t._v(\"同时 \"),_(\"code\",[t._v(\"dump\")]),t._v(\" 线程发现和生产的现象也是一致的：消费线程都处于 \"),_(\"code\",[t._v(\"RUNNABLE\")]),t._v(\" 状态，同时都在执行 \"),_(\"code\",[t._v(\"yield\")]),t._v(\"。\")]),t._v(\" \"),_(\"p\",[t._v(\"通过查询 \"),_(\"code\",[t._v(\"Disruptor\")]),t._v(\" 官方文档发现：\")]),t._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d31383e10f0327921.jpg\",alt:\"\"}})]),t._v(\" \"),_(\"blockquote\",[_(\"p\",[t._v(\"YieldingWaitStrategy 是一种充分压榨 CPU 的策略，使用\"),_(\"code\",[t._v(\"自旋 + yield\")]),t._v(\"的方式来提高性能。\\n当消费线程（Event Handler threads）的数量小于 CPU 核心数时推荐使用该策略。\")])]),t._v(\" \"),_(\"hr\"),t._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d31383fd2dc594576.jpg\",alt:\"\"}})]),t._v(\" \"),_(\"p\",[t._v(\"同时查阅到其他的等待策略 \"),_(\"code\",[t._v(\"BlockingWaitStrategy\")]),t._v(\" （也是默认的策略），它使用的是锁的机制，对 CPU 的使用率不高。\")]),t._v(\" \"),_(\"p\",[t._v(\"于是在和之前同样的条件下将等待策略换为 \"),_(\"code\",[t._v(\"BlockingWaitStrategy\")]),t._v(\"。\")]),t._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d31384097d6190496.jpg\",alt:\"\"}})]),t._v(\" \"),_(\"hr\"),t._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d3138411411e73544.jpg\",alt:\"\"}}),t._v(\" \"),_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d313841d679b99195.jpg\",alt:\"\"}})]),t._v(\" \"),_(\"p\",[t._v(\"和刚才的 CPU 对比会发现到后面使用率的会有明显的降低；同时 dump 线程后会发现大部分线程都处于 waiting 状态。\")]),t._v(\" \"),_(\"h2\",{attrs:{id:\"优化解决\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#优化解决\"}},[t._v(\"#\")]),t._v(\" 优化解决\")]),t._v(\" \"),_(\"p\",[t._v(\"看样子将等待策略换为 \"),_(\"code\",[t._v(\"BlockingWaitStrategy\")]),t._v(\" 可以减缓 CPU 的使用，\")]),t._v(\" \"),_(\"p\",[t._v(\"但留意到官方对 \"),_(\"code\",[t._v(\"YieldingWaitStrategy\")]),t._v(\" 的描述里谈道：\\n当消费线程（Event Handler threads）的数量小于 CPU 核心数时推荐使用该策略。\")]),t._v(\" \"),_(\"p\",[t._v(\"而现有的使用场景很明显消费线程数已经大大的超过了核心 CPU 数了，因为我的使用方式是一个 \"),_(\"code\",[t._v(\"Disruptor\")]),t._v(\" 队列一个消费者，所以我将队列调整为只有 1 个再试试(策略依然是 \"),_(\"code\",[t._v(\"YieldingWaitStrategy\")]),t._v(\")。\")]),t._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d313842427b798742.jpg\",alt:\"\"}})]),t._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d3138669071113680.jpg\",alt:\"\"}})]),t._v(\" \"),_(\"p\",[t._v(\"跑了一分钟，发现 CPU 的使用率一直都比较平稳而且不高。\")]),t._v(\" \"),_(\"h1\",{attrs:{id:\"总结\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#总结\"}},[t._v(\"#\")]),t._v(\" 总结\")]),t._v(\" \"),_(\"p\",[t._v(\"所以排查到此可以有一个结论了，想要根本解决这个问题需要将我们现有的业务拆分；现在是一个应用里同时处理了 N 个业务，每个业务都会使用好几个 \"),_(\"code\",[t._v(\"Disruptor\")]),t._v(\" 队列。\")]),t._v(\" \"),_(\"p\",[t._v(\"由于是在一台服务器上运行，所以 CPU 资源都是共享的，这就会导致 CPU 的使用率居高不下。\")]),t._v(\" \"),_(\"p\",[t._v(\"所以我们的调整方式如下：\")]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"为了快速缓解这个问题，先将等待策略换为 \"),_(\"code\",[t._v(\"BlockingWaitStrategy\")]),t._v(\"，可以有效降低 CPU 的使用率（业务上也还能接受）。\")]),t._v(\" \"),_(\"li\",[t._v(\"第二步就需要将应用拆分（上文模拟的一个 \"),_(\"code\",[t._v(\"Disruptor\")]),t._v(\" 队列），一个应用处理一种业务类型；然后分别单独部署，这样也可以互相隔离互不影响。\")])]),t._v(\" \"),_(\"p\",[t._v(\"当然还有其他的一些优化，因为这也是一个老系统了，这次 dump 线程居然发现创建了 800+ 的线程。\")]),t._v(\" \"),_(\"p\",[t._v(\"创建线程池的方式也是核心线程数、最大线程数是一样的，导致一些空闲的线程也得不到回收；这样会有很多无意义的资源消耗。\")]),t._v(\" \"),_(\"p\",[t._v(\"所以也会结合业务将创建线程池的方式调整一下，将线程数降下来，尽量的物尽其用。\")]),t._v(\" \"),_(\"p\",[t._v(\"本文的演示代码已上传至 GitHub：\")]),t._v(\" \"),_(\"p\",[_(\"a\",{attrs:{href:\"https://github.com/crossoverJie/JCSprout/tree/master/src/main/java/com/crossoverjie/disruptor\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"https://github.com/crossoverJie/JCSprout\"),_(\"OutboundLink\")],1)]),t._v(\" \"),_(\"p\",[_(\"strong\",[t._v(\"你的点赞与分享是对我最大的支持\")])]),t._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://i.loli.net/2019/07/19/5d313848b169269048.jpg\",alt:\"\"}})])])}),[],!1,null,null,null);v.default=e.exports}}]);","extractedComments":[]}