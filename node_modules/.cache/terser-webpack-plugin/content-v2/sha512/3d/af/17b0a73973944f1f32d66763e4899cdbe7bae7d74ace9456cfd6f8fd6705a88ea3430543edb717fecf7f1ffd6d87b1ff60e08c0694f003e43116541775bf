{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{419:function(e,t,v){\"use strict\";v.r(t);var _=v(13),n=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[v(\"p\",[e._v(\"原文地址:\")]),e._v(\" \"),v(\"p\",[e._v(\"https://juejin.im/post/5c68a4056fb9a049e063e0ab\")]),e._v(\" \"),v(\"p\",[e._v(\"https://www.cnblogs.com/dongqingswt/p/3460440.html（这篇相对更好）\")]),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"mysql的innodb采用的是行锁，而且采用了多版本并发控制来提高读操作的性能。\")])]),e._v(\" \"),v(\"h3\",{attrs:{id:\"什么是mvcc\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是mvcc\"}},[e._v(\"#\")]),e._v(\" 什么是MVCC\")]),e._v(\" \"),v(\"p\",[e._v(\"MVCC，Multi-Version Concurrency Control，多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问；在编程语言中实现事务内存。\")]),e._v(\" \"),v(\"p\",[e._v(\"如果有人从数据库中读数据的同时，有另外的人写入数据，有可能读数据的人会看到『半写』或者不一致的数据。有很多种方法来解决这个问题，叫做并发控制方法。最简单的方法，通过加锁，让所有的读者等待写者工作完成，但是这样效率会很差。MVCC 使用了一种不同的手段，每个连接到数据库的读者，在某个瞬间看到的是数据库的一个快照，写者写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于其他的读者来说是不可见的。\")]),e._v(\" \"),v(\"p\",[e._v(\"当一个 MVCC 数据库需要更一个一条数据记录的时候，它不会直接用新数据覆盖旧数据，而是将旧数据标记为过时（obsolete）并在别处增加新版本的数据。这样就会有存储多个版本的数据，但是只有一个是最新的。这种方式允许读者读取在他读之前已经存在的数据，即使这些在读的过程中半路被别人修改、删除了，也对先前正在读的用户没有影响。**这种多版本的方式避免了填充删除操作在内存和磁盘存储结构造成的空洞的开销，但是需要系统周期性整理（sweep through）以真实删除老的、过时的数据。**对于面向文档的数据库（Document-oriented database，也即半结构化数据库）来说，这种方式允许系统将整个文档写到磁盘的一块连续区域上，当需要更新的时候，>直接重写一个版本，而不是对文档的某些比特位、分片切除，或者维护一个链式的、非连续的数据库结构。\")]),e._v(\" \"),v(\"p\",[e._v(\"MVCC 提供了时点（point in time）一致性视图。MVCC 并发控制下的读事务一般使用时间戳或者事务 ID去标记当前读的数据库的状态（版本），读取这个版本的数据。读、写事务相互隔离，不需要加锁。读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据。\")]),e._v(\" \"),v(\"p\",[e._v(\"一句话总结就是：\")]),e._v(\" \"),v(\"p\",[e._v(\"MVCC(Multiversion concurrency control) 就是 同一份数据临时保留多版本的一种方式，进而实现并发控制\")]),e._v(\" \"),v(\"h3\",{attrs:{id:\"具体原理\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#具体原理\"}},[e._v(\"#\")]),e._v(\" 具体原理\")]),e._v(\" \"),v(\"p\",[e._v(\"** 什么是多版本并发控制呢 ？其实就是在每一行记录的后面增加两个隐藏列，记录创建版本号和删除版本号**\")]),e._v(\" \"),v(\"p\",[e._v(\"而每一个事务在启动的时候，都有一个唯一的递增的版本号。\")]),e._v(\" \"),v(\"p\",[e._v(\"1、在插入操作时 ： 记录的创建版本号就是事务版本号。\")]),e._v(\" \"),v(\"p\",[e._v(\"比如我插入一条记录, 事务id 假设是1 ，那么记录如下：也就是说，创建版本号就是事务版本号。\")]),e._v(\" \"),v(\"p\",[e._v(\"id　　\\tname　　\\tcreate version　　\\tdelete version\")]),e._v(\" \"),v(\"p\",[e._v(\"1\\ttest　　\\t1\")]),e._v(\" \"),v(\"p\",[e._v(\"2、在更新操作的时候，采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新的记录的方式。\")]),e._v(\" \"),v(\"p\",[e._v(\"比如，针对上面那行记录，事务Id为2 要把name字段更新\")]),e._v(\" \"),v(\"p\",[e._v(\"update table set name= 'new_value' where id=1;\")]),e._v(\" \"),v(\"p\",[e._v(\"id　　　　\\tname　　\\tcreate version　　\\tdelete version\")]),e._v(\" \"),v(\"p\",[e._v(\"1　　\\ttest　　\\t1\\t2　　　　　　\\n　　\\n1　　\\tnew_value　　\\t2\")]),e._v(\" \"),v(\"p\",[e._v(\"3、删除操作的时候，就把事务版本号作为删除版本号。比如\")]),e._v(\" \"),v(\"p\",[e._v(\"delete from table where id=1;\")]),e._v(\" \"),v(\"p\",[e._v(\"id　　\\tname　　\\tcreate version　　\\tdelete version\\n　　\\n1\\tnew_value\\t2\\t3\")]),e._v(\" \"),v(\"p\",[e._v(\"4、查询操作：\")]),e._v(\" \"),v(\"p\",[e._v(\"从上面的描述可以看到，在查询时要符合以下两个条件的记录才能被事务查询出来：\")]),e._v(\" \"),v(\"ol\",[v(\"li\",[v(\"p\",[e._v(\"删除版本号 大于 当前事务版本号，就是说删除操作是在当前事务启动之后做的。\")])]),e._v(\" \"),v(\"li\",[v(\"p\",[e._v(\"创建版本号 小于或者等于 当前事务版本号 ，就是说记录创建是在事务中（等于的情况）或者事务启动之前。\")])])]),e._v(\" \"),v(\"p\",[e._v(\"这样就保证了各个事务互不影响。从这里也可以体会到一种提高系统性能的思路，就是：\")]),e._v(\" \"),v(\"p\",[e._v(\"通过版本号来减少锁的争用。\")]),e._v(\" \"),v(\"p\",[e._v(\"另外，\"),v(\"strong\",[e._v(\"只有read-committed和 repeatable-read 两种事务隔离级别才能使用mVcc，read-uncommited由于是读到未提交的，所以不存在版本的问题，而serializable 则会对所有读取的行加锁。\")])])])}),[],!1,null,null,null);t.default=n.exports}}]);","extractedComments":[]}