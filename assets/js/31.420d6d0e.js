(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{408:function(n,t,e){"use strict";e.r(t);var a=e(13),s=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h3",{attrs:{id:"行锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#行锁"}},[n._v("#")]),n._v(" 行锁")]),n._v(" "),e("p",[n._v("InnoDB行锁是通过索引上的索引项来实现的。InnoDB这种行锁实现特点意味者："),e("strong",[n._v("只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁！")])]),n._v(" "),e("p",[n._v("InnoDB实现了以下两种类型的行锁。\n共享锁（s）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br")])]),e("p",[n._v("排他锁（Ｘ）：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("SELECT * FROM table_name WHERE ... FOR UPDATE\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br")])]),e("p",[n._v("另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。\n意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。\n意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。")]),n._v(" "),e("h3",{attrs:{id:"表锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#表锁"}},[n._v("#")]),n._v(" 表锁")]),n._v(" "),e("p",[n._v("对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个另特殊事务中，也可以考虑使用表级锁。")]),n._v(" "),e("p",[n._v("第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。")]),n._v(" "),e("p",[n._v("第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。\n当然，应用中这两种事务不能太多，否则，就应该考虑使用ＭyISAＭ表。\n在InnoDB下 ，使用表锁要注意以下两点。")]),n._v(" "),e("p",[n._v("（１）使用LOCK TALBES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层ＭySQL Server负责的，仅当autocommit=0、innodb_table_lock=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，ＭySQL Server才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁；否则，InnoDB将无法自动检测并处理这种死锁。")]),n._v(" "),e("p",[n._v("（２）在用LOCAK TABLES对InnoDB锁时要注意，要将AUTOCOMMIT设为0，否则ＭySQL不会给表加锁；事务结束前，不要用UNLOCAK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK产不能释放用LOCAK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁，正确的方式见如下语句。")])])}),[],!1,null,null,null);t.default=s.exports}}]);