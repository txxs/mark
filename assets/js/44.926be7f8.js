(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{420:function(e,s,a){"use strict";a.r(s);var t=a(13),r=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h3",{attrs:{id:"乐观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁"}},[e._v("#")]),e._v(" 乐观锁")]),e._v(" "),a("p",[e._v("总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。")]),e._v(" "),a("p",[e._v("1、version方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。")]),e._v(" "),a("p",[e._v("核心SQL代码：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("update table set x=x+1, version=version+1 where id=#{id} and version=#{version};  \n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("2、CAS操作方式：即compare and swap 或者 compare and set，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。")]),e._v(" "),a("h3",{attrs:{id:"悲观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#悲观锁"}},[e._v("#")]),e._v(" 悲观锁")]),e._v(" "),a("p",[e._v("总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。")])])}),[],!1,null,null,null);s.default=r.exports}}]);