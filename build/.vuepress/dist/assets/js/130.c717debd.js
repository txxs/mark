(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{511:function(a,v,_){"use strict";_.r(v);var t=_(13),r=Object(t.a)({},(function(){var a=this,v=a.$createElement,_=a._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("p",[a._v("原文地址：")]),a._v(" "),_("p",[a._v("https://www.javazhiyin.com/18220.html")]),a._v(" "),_("p",[a._v("https://www.hollischuang.com/archives/3875")]),a._v(" "),_("h3",{attrs:{id:"_1、jvm运行内存的分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、jvm运行内存的分类"}},[a._v("#")]),a._v(" 1、JVM运行内存的分类")]),a._v(" "),_("p",[a._v("1、程序计数器：当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有，注：如果正在执行的是Native方法，计数器值则为空")]),a._v(" "),_("p",[a._v("2、Java虚拟栈：存放基本数据类型、对象的引用、方法出口等，线程私有")]),a._v(" "),_("p",[a._v("3、Native方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有")]),a._v(" "),_("p",[a._v("4、Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享")]),a._v(" "),_("p",[a._v("5、方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。（即永久带），回收目标主要是常量池的回收和类型的卸载，各线程共享")]),a._v(" "),_("h3",{attrs:{id:"_2、java内存堆和栈区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、java内存堆和栈区别"}},[a._v("#")]),a._v(" 2、Java内存堆和栈区别")]),a._v(" "),_("p",[_("strong",[_("code",[a._v("栈内存用来存储基本类型的变量和对象的引用变量，堆内存用来存储Java中的对象")])]),a._v("，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中\n"),_("strong",[a._v("栈内存归属于单个线程，每个线程都会有一个栈内存")]),a._v("，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存，堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问\n如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError，如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError\n栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满，-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小")]),a._v(" "),_("h3",{attrs:{id:"_3、java四引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、java四引用"}},[a._v("#")]),a._v(" 3、Java四引用")]),a._v(" "),_("p",[a._v("1、强引用（StrongReference）强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题")]),a._v(" "),_("p",[a._v("2、软引用（SoftReference）\n如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中")]),a._v(" "),_("p",[a._v("3、弱引用（WeakReference）\n弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中")]),a._v(" "),_("p",[a._v("4、虚引用（PhantomReference）\n虚引用在任何时候都可能被垃圾回收器回收，主要用来跟踪对象被垃圾回收器回收的活动，被回收时会收到一个系统通知。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。")]),a._v(" "),_("h3",{attrs:{id:"_4、gc-标记对象的死活"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、gc-标记对象的死活"}},[a._v("#")]),a._v(" 4、GC 标记对象的死活")]),a._v(" "),_("p",[a._v("1、引用计数法：给对象添加一个引用计数器,没当被引用的时候,计数器的值就加一。引用失效的时候减一,当计数器的值为 0 的时候就表示改对象可以被 GC 回收了，弊端:A->B,B->A,那么 AB 将永远不会被回收了。也就是引用有环的情况")]),a._v(" "),_("p",[a._v("2、根搜索算法(可达性算法) GC Roots Tracing：通过一个叫 GC Roots 的对象作为起点,从这些结点开始向下搜索,搜索所走过的路径称为引用链,当一个对象没有与任何的引用链相连的时候则改对象就可以被。 GC 回收回收了Roots 包括：java 虚拟机栈中引用的对象,本地方法栈中引用的对象,方法区中常量引用的对象,方法区中静态属性引用的对象")]),a._v(" "),_("p",[a._v("在Java语言里，可作为GC Roots的对象包括以下几种：")]),a._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[a._v(" 虚拟机栈（栈帧中的本地变量表）中的引用的对象\n 方法区中的类静态属性引用的对象\n 方法区中的常量引用的对象。\n 本地方法栈中JNI(即一般说的Native方法)的引用的对象。\n")])]),a._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[a._v("1")]),_("br"),_("span",{staticClass:"line-number"},[a._v("2")]),_("br"),_("span",{staticClass:"line-number"},[a._v("3")]),_("br"),_("span",{staticClass:"line-number"},[a._v("4")]),_("br")])]),_("h3",{attrs:{id:"_5、gc回收算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5、gc回收算法"}},[a._v("#")]),a._v(" 5、GC回收算法")]),a._v(" "),_("p",[a._v("1、标记-清除法：标记出没有用的对象，然后一个一个回收掉")]),a._v(" "),_("p",[a._v("缺点：标记和清除两个过程效率不高，产生内存碎片导致需要分配较大对象时无法找到足够的连续内存而需要触发一次GC操作")]),a._v(" "),_("p",[a._v("2、复制算法: 按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉")]),a._v(" "),_("p",[a._v("缺点：将内存缩小为了原来的一半")]),a._v(" "),_("p",[a._v("3、标记-整理法：标记出没有用的对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内")]),a._v(" "),_("p",[a._v("优点：解决了标记- 清除算法导致的内存碎片问题和在存活率较高时复制算法效率低的问题。")]),a._v(" "),_("p",[a._v("4、分代回收：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，"),_("strong",[a._v("新生代基本采用复制算法，老年代采用标记整理算法")])]),a._v(" "),_("h3",{attrs:{id:"_6、minorgc-fullgc触发条件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6、minorgc-fullgc触发条件"}},[a._v("#")]),a._v(" 6、MinorGC&FullGC触发条件")]),a._v(" "),_("p",[a._v("Minor GC触发条件：")]),a._v(" "),_("p",[a._v("当Eden区满时，触发Minor GC。")]),a._v(" "),_("p",[a._v("Full GC触发条件：")]),a._v(" "),_("p",[a._v("（1）调用System.gc时，系统建议执行Full GC，但是不必然执行")]),a._v(" "),_("p",[a._v("（2）老年代空间不足")]),a._v(" "),_("p",[a._v("（3）方法去空间不足")]),a._v(" "),_("p",[a._v("（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存")]),a._v(" "),_("p",[a._v("（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小")]),a._v(" "),_("h3",{attrs:{id:"_7、两个对象相互引用-会不会被gc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7、两个对象相互引用-会不会被gc"}},[a._v("#")]),a._v(" 7、两个对象相互引用，会不会被GC?")]),a._v(" "),_("p",[a._v("首先两个对象相互引用，和会不会被GC没有直接关系。jvm是采用对象到GC Roots可达性来决定是否会被GC回收的。")]),a._v(" "),_("h3",{attrs:{id:"_8、引起类加载操作的五个行为"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8、引起类加载操作的五个行为"}},[a._v("#")]),a._v(" 8、引起类加载操作的五个行为")]),a._v(" "),_("p",[a._v("遇到new、getstatic、putstatic或invokestatic这四条字节码指令")]),a._v(" "),_("p",[a._v("反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化")]),a._v(" "),_("p",[a._v("子类初始化的时候，如果其父类还没初始化，则需先触发其父类的初始化")]),a._v(" "),_("p",[a._v("虚拟机执行主类的时候(有 main(string[] args))\nJDK1.7 动态语言支持")]),a._v(" "),_("h3",{attrs:{id:"_9、java对象创建时机"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9、java对象创建时机"}},[a._v("#")]),a._v(" 9、Java对象创建时机")]),a._v(" "),_("p",[a._v("使用new关键字创建对象")]),a._v(" "),_("p",[a._v("使用Class类的newInstance方法(反射机制)")]),a._v(" "),_("p",[a._v("使用Constructor类的newInstance方法(反射机制)")]),a._v(" "),_("p",[a._v("使用Clone方法创建对象")]),a._v(" "),_("p",[a._v("使用(反)序列化机制创建对象")]),a._v(" "),_("h3",{attrs:{id:"_10、类的生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10、类的生命周期"}},[a._v("#")]),a._v(" 10、类的生命周期")]),a._v(" "),_("p",[a._v("1、加载过程：通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中(方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；")]),a._v(" "),_("p",[a._v("2、验证过程：为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，文件格式验证、元数据验证、字节码验证、符号引用验证")]),a._v(" "),_("p",[a._v("3、准备过程：正式为类属性分配内存并设置类属性初始值的阶段，这些内存都将在方法区中进行分配")]),a._v(" "),_("p",[a._v("4、解析阶段：虚拟机将常量池内的符号引用替换为直接引用的过程")]),a._v(" "),_("p",[a._v("5、初始化阶段：类初始化阶段是类加载过程的最后一步。初始化阶段就是执行类构造器"),_("clint",[a._v("()方法的过程")])],1),a._v(" "),_("p",[a._v("6、使用阶段：")]),a._v(" "),_("p",[a._v("7、卸载阶段：")]),a._v(" "),_("h3",{attrs:{id:"_11、java类加载器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11、java类加载器"}},[a._v("#")]),a._v(" 11、Java类加载器")]),a._v(" "),_("p",[a._v("类加载器负责加载所有的类，同一个类(一个类用其全限定类名(包名加类名)标志)只会被加载一次")]),a._v(" "),_("p",[a._v("Bootstrap ClassLoader:根类加载器，负责加载java的核心类，它不是java.lang.ClassLoader的子类，而是由JVM自身实现")]),a._v(" "),_("p",[a._v("Extension ClassLoader:扩展类加载器，扩展类加载器的加载路径是JDK目录下jre/lib/ext,扩展类的getParent()方法返回null,实际上扩展类加载器的父类加载器是根加载器，只是根加载器并不是Java实现的")]),a._v(" "),_("p",[a._v("System ClassLoader:系统(应用)类加载器，它负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性或CLASSPATH环境变量所指定的jar包和类路径。程序可以通过getSystemClassLoader()来获取系统类加载器。系统加载器的加载路径是程序运行的当前路径")]),a._v(" "),_("h3",{attrs:{id:"_12、双亲委派模型的工作过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12、双亲委派模型的工作过程"}},[a._v("#")]),a._v(" 12、双亲委派模型的工作过程")]),a._v(" "),_("p",[a._v("首先会先查找当前ClassLoader是否加载过此类，有就返回；")]),a._v(" "),_("p",[a._v("如果没有，查询父ClassLoader是否已经加载过此类，如果已经加载过,就直接返回Parent加载的类；")]),a._v(" "),_("p",[a._v("如果整个类加载器体系上的ClassLoader都没有加载过，才由当前ClassLoader加载(调用findClass)，整个过程类似循环链表一样。")]),a._v(" "),_("h3",{attrs:{id:"_13、双亲委托机制的作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13、双亲委托机制的作用"}},[a._v("#")]),a._v(" 13、双亲委托机制的作用")]),a._v(" "),_("p",[a._v("共享功能：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载，一些Framework层级的类一旦被顶层的ClassLoader加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。")]),a._v(" "),_("p",[a._v("隔离功能：因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的类装载器，保证java/Android核心类库的纯净和安全，防止恶意加载。")]),a._v(" "),_("h3",{attrs:{id:"_14、如何打破双亲委派模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14、如何打破双亲委派模型"}},[a._v("#")]),a._v(" 14、如何打破双亲委派模型？")]),a._v(" "),_("p",[a._v("双亲委派模型的逻辑都在loadClass()中，重写loaderClass()，一般是重写findClass()的")]),a._v(" "),_("p",[a._v("系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载")]),a._v(" "),_("h3",{attrs:{id:"_15、自定义classloader"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_15、自定义classloader"}},[a._v("#")]),a._v(" 15、自定义ClassLoader：")]),a._v(" "),_("p",[a._v("loadClass(String name,boolean resolve)：根据指定的二进制名称加载类")]),a._v(" "),_("p",[a._v("findClass(String name)： 根据二进制名称来查找类\n直接使用或继承已有的ClassLoader实现：java.net.URLClassLoader、java.security.SecureClassLoader、 java.rmi.server.RMIClassLoader")]),a._v(" "),_("p",[a._v("在调用loadClass()，会先根据委派模型在父加载器中加载，如果加载失败，则会调用自己的findClass方法来完成加载")]),a._v(" "),_("h3",{attrs:{id:"_16、类加载有三种方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_16、类加载有三种方式"}},[a._v("#")]),a._v(" 16、类加载有三种方式：")]),a._v(" "),_("p",[a._v("1）命令行启动应用时候由JVM初始化加载")]),a._v(" "),_("p",[a._v("2）通过Class.forName（）方法动态加载")]),a._v(" "),_("p",[a._v("3）通过ClassLoader.loadClass（）方法动态加载")]),a._v(" "),_("h3",{attrs:{id:"_17、jvm的永久代中会发生垃圾回收么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_17、jvm的永久代中会发生垃圾回收么"}},[a._v("#")]),a._v(" 17、JVM的永久代中会发生垃圾回收么")]),a._v(" "),_("p",[a._v("垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区 (注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)")]),a._v(" "),_("h3",{attrs:{id:"_18、java对象结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_18、java对象结构"}},[a._v("#")]),a._v(" 18、Java对象结构")]),a._v(" "),_("p",[a._v("Java对象由三个部分组成：对象头、实例数据、对齐填充。")]),a._v(" "),_("p",[a._v("对象头由两部分组成，第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32/64 bit）。第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。")]),a._v(" "),_("p",[a._v("实例数据用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）")]),a._v(" "),_("p",[a._v("对齐填充：JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）")]),a._v(" "),_("h3",{attrs:{id:"_19、讲讲什么情况下会出现内存溢出-内存泄漏"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_19、讲讲什么情况下会出现内存溢出-内存泄漏"}},[a._v("#")]),a._v(" 19、讲讲什么情况下会出现内存溢出，内存泄漏")]),a._v(" "),_("p",[a._v("https://my.oschina.net/demons99/blog/1936827")]),a._v(" "),_("p",[a._v("1、内存泄漏memory leak :是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。\n2、内存溢出 out of memory :指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。")]),a._v(" "),_("p",[a._v("这就是Java中内存泄漏的发生场景。具体主要有如下几大类：")]),a._v(" "),_("p",[a._v("1、静态集合类引起内存泄漏：像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。")]),a._v(" "),_("p",[a._v("2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。主要是因为哈希值发生变化")]),a._v(" "),_("p",[a._v("3、监听器：在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。")]),a._v(" "),_("p",[a._v("4、各种连接：比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。")]),a._v(" "),_("p",[a._v("5、单例模式：不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏")]),a._v(" "),_("h3",{attrs:{id:"_20、类的实例化顺序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_20、类的实例化顺序"}},[a._v("#")]),a._v(" 20、类的实例化顺序")]),a._v(" "),_("p",[a._v("1.首先是父类的静态变量和静态代码块（看两者的书写顺序）；")]),a._v(" "),_("p",[a._v("2.第二执行子类的静态变量和静态代码块（看两者的书写顺序）；")]),a._v(" "),_("p",[a._v("3.第三执行父类的成员变量赋值")]),a._v(" "),_("p",[a._v("4.第四执行父类类的构造代码块")]),a._v(" "),_("p",[a._v("5.第五执行父类的构造方法（）")]),a._v(" "),_("p",[a._v("6.执行子类的构造代码块")]),a._v(" "),_("p",[a._v("7.第七执行子类的构造方法（）；")]),a._v(" "),_("p",[a._v("总结，也就是说虽然客户端代码是new 的构造方法，但是构造方法确实是在整个实例创建中的最后一个调用。切记切记！！！")]),a._v(" "),_("p",[_("strong",[a._v("先是父类，再是子类；\n先是类静态变量和静态代码块，再是对象的成员变量和构造代码块–》构造方法。")])]),a._v(" "),_("h3",{attrs:{id:"_21、cms的几个阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_21、cms的几个阶段"}},[a._v("#")]),a._v(" 21、CMS的几个阶段：")]),a._v(" "),_("p",[a._v("https://www.cnblogs.com/littleLord/p/5380624.html")]),a._v(" "),_("p",[a._v("1.初始标记(STW),标记GC ROOT能直接关联到的对象")]),a._v(" "),_("p",[a._v("2.并发标记,在第一个阶段被暂停的线程重新开始运行。由前阶段标记过的对象出发，所有可到达的对象都在本阶段中标记。")]),a._v(" "),_("p",[a._v("3.并发预清理,此阶段标记从新生代晋升的对象、新分配到老年代的对象以及在并发阶段被修改了的对象。")]),a._v(" "),_("p",[a._v("4.重标记(STW),因此重标记的工作尽可能多的在并发阶段完成来减少STW的时间。")]),a._v(" "),_("p",[a._v("5.并发清理")]),a._v(" "),_("p",[a._v("6.重置")]),a._v(" "),_("p",[a._v("或者这个：")]),a._v(" "),_("p",[a._v("初始标记\n并发标记\n重新标记\n并发清除")]),a._v(" "),_("h3",{attrs:{id:"_22、调优命令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_22、调优命令"}},[a._v("#")]),a._v(" 22、调优命令")]),a._v(" "),_("p",[a._v("1、jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。")]),a._v(" "),_("p",[a._v("2、jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。")]),a._v(" "),_("p",[a._v("3、jmap，JVM Memory Map命令用于生成heap dump文件")]),a._v(" "),_("p",[a._v("4、jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看")]),a._v(" "),_("p",[a._v("5、jstack，用于生成java虚拟机当前时刻的线程快照。")]),a._v(" "),_("p",[a._v("6、jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。")]),a._v(" "),_("h3",{attrs:{id:"_23、命令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_23、命令"}},[a._v("#")]),a._v(" 23、命令")]),a._v(" "),_("p",[a._v("-Xms / -Xmx — 堆的初始大小 / 堆的最大大小 -Xmn — 堆中年轻代的大小 -XX:-DisableExplicitGC — 让System.gc()不产生任何作用 -XX:+PrintGCDetails — 打印GC的细节 -XX:+PrintGCDateStamps — 打印GC操作的时间戳 -XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小 -XX:NewRatio — 可以设置老生代和新生代的比例 -XX:PrintTenuringDistribution — 设置每次新生代GC后输出幸存者乐园中对象年龄的分布 -XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值 -XX:TargetSurvivorRatio：设置幸存区的目标使用率")]),a._v(" "),_("h3",{attrs:{id:"_24、jre、jdk、jvm-及-jit-之间有什么不同"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_24、jre、jdk、jvm-及-jit-之间有什么不同"}},[a._v("#")]),a._v(" 24、JRE、JDK、JVM 及 JIT 之间有什么不同？")]),a._v(" "),_("p",[a._v("JRE 代表 Java 运行时（Java run-time），是运行 Java 引用所必须的。JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。")]),a._v(" "),_("h3",{attrs:{id:"_24、jit"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_24、jit"}},[a._v("#")]),a._v(" 24、JIT")]),a._v(" "),_("p",[a._v("1、针对特定CPU型号的编译优化，JVM会利用不同CPU支持的SIMD指令集来编译热点代码，提升性能。像intel支持的SSE2指令集在特定情况下可以提升近40倍的性能。")]),a._v(" "),_("p",[a._v("2、减少查表次数。比如调用Object.equals()方法，如果运行时发现一直是String对象的equals，编译后的代码可以直接调用String.equals方法，跳过查找该调用哪个方法的步骤。")]),a._v(" "),_("p",[a._v("3、逃逸分析。JAVA变量默认是分配在主存的堆上，但是如果方法中的变量未逃出使用的生命周期，不会被外部方法或者线程引用，可以考虑在栈上分配内存，减少GC压力。另外逃逸分析可以实现锁优化等提升性能方法。")]),a._v(" "),_("p",[a._v("4、寄存器分配，部分变量可以分配在寄存器中，相对于主存读取，更大的提升读取性能。")]),a._v(" "),_("p",[a._v("5、针对热点代码编译好的机器码进行缓存。代码缓存具有固定的大小，并且一旦它被填满，JVM 则不能再编译更多的代码。")]),a._v(" "),_("p",[a._v("6、方法内联，也是JIT实现的非常有用的优化能力，同时是开发者能够简单参与JIT性能调优的地方。")]),a._v(" "),_("h3",{attrs:{id:"_25、方法内联是什么。为什么它能够提升性能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_25、方法内联是什么。为什么它能够提升性能"}},[a._v("#")]),a._v(" 25、方法内联是什么。为什么它能够提升性能")]),a._v(" "),_("p",[a._v("要搞清楚为什么方法内联有用，首先要知道当一个函数被调用的时候发生了什么")]),a._v(" "),_("p",[a._v("1、首先会有个栈，存储目前所有活跃的方法，以及它们的本地变量和参数")]),a._v(" "),_("p",[a._v("2、当一个新的方法被调用了，一个新的栈帧会被加到栈顶，分配的本地变量和参数会存储在这个栈帧")]),a._v(" "),_("p",[a._v("3、跳到目标方法代码执行")]),a._v(" "),_("p",[a._v("4、方法返回的时候，本地方法和参数会被销毁，栈顶被移除")]),a._v(" "),_("p",[a._v("5、返回原来地址执行")]),a._v(" "),_("p",[a._v("因此，函数调用需要有一定的时间开销和空间开销，当一个方法体不大，但又频繁被调用时，这个时间和空间开销会相对变得很大，变得非常不划算，同时降低了程序的性能。")]),a._v(" "),_("h3",{attrs:{id:"_26、promotion-failed和concurrent-mode-failure原因以及解决办法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_26、promotion-failed和concurrent-mode-failure原因以及解决办法"}},[a._v("#")]),a._v(" 26、promotion failed和concurrent mode failure原因以及解决办法")]),a._v(" "),_("p",[a._v("https://blog.csdn.net/chenleixing/article/details/46706039/")]),a._v(" "),_("p",[a._v("promotion failed是在进行Minor GC时，survivor space放不下、对象只能放入老年代，而此时老年代也放不下造成的；")]),a._v(" "),_("p",[a._v("concurrent mode failure是在执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足造成的（有时候“空间不足”是CMS GC时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC）。")]),a._v(" "),_("p",[a._v("对措施为：增大survivor space、老年代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕")]),a._v(" "),_("h3",{attrs:{id:"_27、如何自定义一个类加载器-你使用过哪些或者你在什么场景下需要一个自定义的类加载器吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_27、如何自定义一个类加载器-你使用过哪些或者你在什么场景下需要一个自定义的类加载器吗"}},[a._v("#")]),a._v(" 27、如何⾃定义⼀个类加载器？你使⽤过哪些或者你在什么场景下需要⼀个⾃定义的类加载器吗？")]),a._v(" "),_("p",[a._v("1、加载特定路径的class文件")]),a._v(" "),_("p",[a._v("2、加载一个加密的网络class文件")]),a._v(" "),_("p",[a._v("3、热部署加载class文件")]),a._v(" "),_("h3",{attrs:{id:"_28、java对象创建过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_28、java对象创建过程"}},[a._v("#")]),a._v(" 28、java对象创建过程")]),a._v(" "),_("p",[a._v("1、虚拟机遇到new指令，到常量池定位到这个类的符号引用。")]),a._v(" "),_("p",[a._v("2、检查符号引用代表的类是否被加载、解析、初始化过。")]),a._v(" "),_("p",[a._v("3、虚拟机为对象分配内存。")]),a._v(" "),_("p",[a._v("4、虚拟机将分配到的内存空间都初始化为零值。")]),a._v(" "),_("p",[a._v("5、虚拟机对对象进行必要的设置。")]),a._v(" "),_("p",[a._v("6、执行方法，成员变量进行初始化")]),a._v(" "),_("p",[a._v("另外一种解释：")]),a._v(" "),_("p",[a._v("①类加载检查： 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。")]),a._v(" "),_("p",[a._v("②分配内存： 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定（“标记-清除”、“标记-压缩”）。")]),a._v(" "),_("p",[a._v("③初始化零值： 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用。")]),a._v(" "),_("p",[a._v("④设置对象头： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。")]),a._v(" "),_("p",[a._v("⑤执行 init 方法：执行 new 指令之后会接着执行 "),_("init",[a._v("方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。")])],1),a._v(" "),_("h4",{attrs:{id:"_29、java对象不是全部分配在堆上"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_29、java对象不是全部分配在堆上"}},[a._v("#")]),a._v(" 29、Java对象不是全部分配在堆上")]),a._v(" "),_("p",[a._v("逃逸是指在某个方法之内创建的对象除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收。由于其被其它变量引用，由于无法回收，即称为逃逸。")]),a._v(" "),_("p",[a._v("逃逸分析技术可以分析出某个对象是否永远只在某个方法、线程的范围内，并没有“逃逸”出这个范围，逃逸分析的一个结果就是对于某些未逃逸对象可以直接在栈上分配提高对象分配回收效率，对象占用的空间会随栈帧的出栈而销毁。")]),a._v(" "),_("h3",{attrs:{id:"_30、jvm-整体组成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_30、jvm-整体组成"}},[a._v("#")]),a._v(" 30、JVM 整体组成")]),a._v(" "),_("p",[a._v("JVM 整体组成可分为以下四个部分：\n类加载器（ClassLoader）")]),a._v(" "),_("p",[a._v("运行时数据区（Runtime Data Area）")]),a._v(" "),_("p",[a._v("执行引擎（Execution Engine）")]),a._v(" "),_("p",[a._v("本地库接口（Native Interface）")]),a._v(" "),_("p",[a._v("各个组成部分的用途：\n程序在执行之前先要把java代码转换成字节码（class文件），jvm首先需要把字节码通过一定的方式 类加载器（ClassLoader） 把文件加载到内存中 运行时数据区（Runtime Data Area） ，而字节码文件是jvm的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器 执行引擎（Execution Engine） 将字节码翻译成底层系统指令再交由CPU去执行，而这个过程中需要调用其他语言的接口 本地库接口（Native Interface）来实现整个程序的功能，这就是这4个主要组成部分的职责与功能。")]),a._v(" "),_("h3",{attrs:{id:"_31、运行时数据区中哪些区域是线程共享的-哪些是独享的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_31、运行时数据区中哪些区域是线程共享的-哪些是独享的"}},[a._v("#")]),a._v(" 31、运行时数据区中哪些区域是线程共享的？哪些是独享的？")]),a._v(" "),_("p",[a._v("在JVM运行时内存区域中，PC寄存器、虚拟机栈和本地方法栈是线程独享的。")]),a._v(" "),_("p",[a._v("而Java堆、方法区是线程共享的。但是值得注意的是，Java堆其实还未每一个线程单独分配了一块TLAB空间，这部分空间在分配时是线程独享的，在使用时是线程共享的。")]),a._v(" "),_("h3",{attrs:{id:"_32、堆和栈的区别是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_32、堆和栈的区别是什么"}},[a._v("#")]),a._v(" 32、堆和栈的区别是什么？")]),a._v(" "),_("p",[a._v("堆和栈（虚拟机栈）是完全不同的两块内存区域，一个是线程独享的，一个是线程共享的，二者之间最大的区别就是存储的内容不同：")]),a._v(" "),_("p",[a._v("堆中主要存放对象实例。")]),a._v(" "),_("p",[a._v("栈（局部变量表）中主要存放各种基本数据类型、对象的引用。")]),a._v(" "),_("h3",{attrs:{id:"_33、java中的数组是存储在堆上还是栈上的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_33、java中的数组是存储在堆上还是栈上的"}},[a._v("#")]),a._v(" 33、Java中的数组是存储在堆上还是栈上的？")]),a._v(" "),_("p",[a._v("在Java中，数组同样是一个对象，所以对象在内存中如何存放同样适用于数组；")]),a._v(" "),_("p",[a._v("所以，数组的实例是保存在堆中，而数组的引用是保存在栈上的。")]),a._v(" "),_("h3",{attrs:{id:"_34、java中的对象一定在堆上分配内存吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_34、java中的对象一定在堆上分配内存吗"}},[a._v("#")]),a._v(" 34、Java中的对象一定在堆上分配内存吗？")]),a._v(" "),_("p",[a._v("前面我们说过，Java堆中主要保存了对象实例，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。")]),a._v(" "),_("p",[a._v("其实，在编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。")]),a._v(" "),_("p",[a._v("如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。")]),a._v(" "),_("h3",{attrs:{id:"_35、对象的访问定位的两种方式-句柄和直接指针两种方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_35、对象的访问定位的两种方式-句柄和直接指针两种方式"}},[a._v("#")]),a._v(" 35、对象的访问定位的两种方式（句柄和直接指针两种方式）")]),a._v(" "),_("p",[a._v("Java程序需要通过栈上的reference数据来操作堆上的具体对象。")]),a._v(" "),_("p",[a._v("句柄： 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；")]),a._v(" "),_("p",[a._v("直接指针： 如果使用直接指针访问，reference 中存储的直接就是对象的地址。")]),a._v(" "),_("h3",{attrs:{id:"_36、如何判断一个常量是废弃常量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_36、如何判断一个常量是废弃常量"}},[a._v("#")]),a._v(" 36、如何判断一个常量是废弃常量")]),a._v(" "),_("p",[a._v('假如在常量池中存在字符串 "abc"，如果当前没有任何String对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。')]),a._v(" "),_("h3",{attrs:{id:"_37、如何判断一个类是无用的类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_37、如何判断一个类是无用的类"}},[a._v("#")]),a._v(" 37、如何判断一个类是无用的类")]),a._v(" "),_("p",[a._v("类需要同时满足下面3个条件才能算是 “无用的类” ：")]),a._v(" "),_("p",[a._v("1、该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。")]),a._v(" "),_("p",[a._v("2、加载该类的 ClassLoader 已经被回收。")]),a._v(" "),_("p",[a._v("3、该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。")]),a._v(" "),_("p",[a._v("虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。")]),a._v(" "),_("h3",{attrs:{id:"gc分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#gc分类"}},[a._v("#")]),a._v(" GC分类")]),a._v(" "),_("ul",[_("li",[a._v("Minor GC - 清理Young Generation")]),a._v(" "),_("li",[a._v("Major GC - 清理Old Generation")]),a._v(" "),_("li",[a._v("Full GC - 全部清理，其实这3个很难分开，有的Minor GC会触发Major GC，那算不算一次FGC呢？")])]),a._v(" "),_("h3",{attrs:{id:"为什么minorgc比较快呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么minorgc比较快呢"}},[a._v("#")]),a._v(" 为什么MinorGC比较快呢？")]),a._v(" "),_("ul",[_("li",[a._v("Young Generation一般比较小")]),a._v(" "),_("li",[a._v("Minor GC的时候不需要扫描Old Generation")]),a._v(" "),_("li",[a._v("Young Generation中大部分都是没用的，GC中并不需要拷贝到Survivor或者Old Generation。")])]),a._v(" "),_("h3",{attrs:{id:"minor-gc的时候为什么不需要扫描old-generation"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#minor-gc的时候为什么不需要扫描old-generation"}},[a._v("#")]),a._v(" Minor GC的时候为什么不需要扫描Old Generation")]),a._v(" "),_("p",[a._v("Old Generation中有一个数据结构Card Table，这个数据结构记录了Old Generation中引用Young Generation的情况，所以Minor GC的时候只需要检查这里即可，不需要扫描整个Old Generation。")]),a._v(" "),_("h3",{attrs:{id:"g1-为什么比cms能更好的预测gc的停顿时间呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#g1-为什么比cms能更好的预测gc的停顿时间呢"}},[a._v("#")]),a._v(" G1 为什么比CMS能更好的预测GC的停顿时间呢？")]),a._v(" "),_("p",[a._v("CMS要进行一次GC，那么就需要扫描Old Generation内存中所有的object，但是G1就不需要，他可以选择一个Region进行GC，所以能较好的控制停顿时间。")]),a._v(" "),_("h3",{attrs:{id:"为什么需要stw"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要stw"}},[a._v("#")]),a._v(" 为什么需要STW")]),a._v(" "),_("p",[a._v("重新定位堆中的对象时，JVM应该更正对此对象的所有引用。在重定位过程中，对象图不一致，这就是STW需要暂停的原因。")]),a._v(" "),_("h3",{attrs:{id:"minor-gc-要stop-world的吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#minor-gc-要stop-world的吗"}},[a._v("#")]),a._v(" minor GC 要stop world的吗")]),a._v(" "),_("p",[a._v("目前所有的新生代gc都是需要STW的")]),a._v(" "),_("ul",[_("li",[a._v("Serial：单线程STW，复制算法")]),a._v(" "),_("li",[a._v("ParNew：多线程并行STW，复制算法")]),a._v(" "),_("li",[a._v("Parallel Scavange：多线程并行STW，吞吐量优先，复制算法")]),a._v(" "),_("li",[a._v("G1：多线程并发，可以精确控制STW时间，整理算法")])]),a._v(" "),_("h3",{attrs:{id:"为什么-cms两次标记时要-stop-the-world"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么-cms两次标记时要-stop-the-world"}},[a._v("#")]),a._v(" 为什么 CMS两次标记时要 stop the world")]),a._v(" "),_("p",[a._v("大家有没有想过一件事情，当虚拟机完成两次标记后，便确认了可以回收的对象。但是，垃圾回收并不会阻塞我们程序的线程，他是与当前程序并发执行的。所以问题就出在这里，当GC线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写finalize()方法，因此回收的时候就会回收这个不该回收的对象。")]),a._v(" "),_("p",[a._v("虚拟机的解决方法就是在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW），暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除。这些特定的指令位置主要在：")]),a._v(" "),_("ol",[_("li",[a._v("循环的末尾")]),a._v(" "),_("li",[a._v("方法临返回前 / 调用方法的call指令后")]),a._v(" "),_("li",[a._v("可能抛异常的位置")])]),a._v(" "),_("h3",{attrs:{id:"如何做到一个系统几乎0次full-gc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何做到一个系统几乎0次full-gc"}},[a._v("#")]),a._v(" 如何做到一个系统几乎0次Full GC")]),a._v(" "),_("p",[a._v("如果真要做到0次的Full GC是不是就应该尽可能的让对象不要往老年代走，当然除了全局对象以外，比如咱们现在大多数后台开发都是基于Spring是不是，那么当中的Controller、Service、Config、还有Dao等这些单例模式创建的实体肯定是在老年代的。我们说的就是要处理那些基于服务用户只要存活一个线程周期的那些对象。")]),a._v(" "),_("p",[a._v("基于评估这个系统每天的服务请求数、每个请求时长、每个线程所需要创建哪些对象通过一些工具监控出来，合理的分配Eden区，S0、S1区，以及对应的老年代，还有需要考虑注意的就是那些由于动态年龄问题导致而进入到老年代的对象基本上是可以做到0次Full GC的。")]),a._v(" "),_("h3",{attrs:{id:"cms哪个阶段最耗时"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cms哪个阶段最耗时"}},[a._v("#")]),a._v(" CMS哪个阶段最耗时")]),a._v(" "),_("p",[a._v('还有一个重要阶段，也可能是最耗时的阶段，重标记阶段（final-remark），这一阶段同样也是 STW，之所以叫重标记，需要重扫根集，就是以 GC Roots 为出发点， 完整且并行地 trace 一次，找到所有存活对象并标记之。只有在这个阶段结束之后，剩下的白色对象才能称之为 "垃圾"。')]),a._v(" "),_("h3",{attrs:{id:"cms过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cms过程"}},[a._v("#")]),a._v(" CMS过程")]),a._v(" "),_("ol",[_("li",[a._v("初始标记（CMS initial mark）：标记一下GC Roots能直接关联到的对象。需要STW，速度很快。")]),a._v(" "),_("li",[a._v("并发标记（CMS concurrent mark）：进行GC Roots Tracing。不需要STW。会产生浮动垃圾。并发标记和并发清理与用户线程一起工作。")]),a._v(" "),_("li",[a._v("重新标记（CMS remark）：找到并发标记期间产生的浮动垃圾。需要STW，停顿时间一般会比初始标记稍长，但远比并发标记短。")]),a._v(" "),_("li",[a._v("并发清除（CMS concurrent sweep）：清除已标记的垃圾。不需要STW。会产生浮动垃圾，只能等下一次GC清理。")])]),a._v(" "),_("h3",{attrs:{id:"cms的优点、缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cms的优点、缺点"}},[a._v("#")]),a._v(" CMS的优点、缺点")]),a._v(" "),_("p",[a._v("原文地址：https://monkeysayhi.github.io/2018/11/02/%E6%B5%85%E8%B0%88CMS%E5%8E%9F%E7%90%86/")]),a._v(" "),_("p",[a._v("优点：")]),a._v(" "),_("ul",[_("li",[a._v("大部分时间可与用户线程并发工作")]),a._v(" "),_("li",[a._v("低停顿")])]),a._v(" "),_("p",[a._v("缺点：")]),a._v(" "),_("ul",[_("li",[a._v("对CPU资源非常敏感。并发标记和并发清理与用户线程一起工作，如果用户线程也是CPU敏感的，那么必然影响用户线程。")]),a._v(" "),_("li",[a._v("无法处理浮动垃圾（Floating Garbage）。并发标记与并发清除过程会产生浮动垃圾，如果CMS之前预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将退化使用Serial Old收集器，重新进行老年代的垃圾收集，这样停顿时间就很长了。可使用XX:CMSInitiatingOccupancyFraction参数设置触发CMS时的老年代空间比例（剩余空间就是预留空间），在JDK1.6中默认为92%。")]),a._v(" "),_("li",[a._v("基于“标记-清除算法”，收集结束时会有大量空间碎片产生，导致明明剩余空间充足，却无法为大对象分配足够的连续内存。可打开-XX：+UseCMSCompactAtFullCollection开关参数（默认打开）在进行Full GC之前整理内存碎片（称为“压缩”）；使用-XX:CMSFullGCsBeforeCompaction参数（默认0）设置多少次不带压缩的Full CG之后才进行一次带压缩的Full GC。内存整理无法并行，还需要STW，需要适当调整内存整理的频率，在GC性能与空间利用率之间平衡。")])]),a._v(" "),_("h3",{attrs:{id:"g1为什么快"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#g1为什么快"}},[a._v("#")]),a._v(" G1为什么快")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("在串行和并行收集器中，GC通过整堆扫描，来确定对象是否处于可达路径中。然而G1为了避免STW式的整堆扫描，在每个分区记录了一个已记忆集合(RSet)，内部类似一个反向指针，记录引用分区内对象的卡片索引。当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况。事实上，并非所有的引用都需要记录在RSet中，如果一个分区确定需要扫描，那么无需RSet也可以无遗漏的得到引用关系。那么引用源自本分区的对象，当然不用落入RSet中；同时，G1GC每次都会对年轻代进行整体收集，因此引用源自年轻代的对象，也不需要在RSet中记录。最后只有老年代的分区可能会有RSet记录，这些分区称为拥有RSet分区(an RSet’s owning region)。")])]),a._v(" "),_("li",[_("p",[a._v("分代垃圾收集可以将关注点集中在最近被分配的对象上，而无需整堆扫描，避免长命对象的拷贝，同时独立收集有助于降低响应时间。虽然分区使得内存分配不再要求紧凑的内存空间，但G1依然使用了分代的思想。")])]),a._v(" "),_("li",[_("p",[a._v("G1同样可以通过-Xms/-Xmx来指定堆空间大小。当发生年轻代收集或混合收集时，通过计算GC与应用的耗费时间比，自动调整堆空间大小。如果GC频率太高，则通过增加堆尺寸，来减少GC频率，相应地GC占用的时间也随之降低")])])]),a._v(" "),_("h3",{attrs:{id:"jvm内存结构-vs-java内存模型-vs-java对象模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存结构-vs-java内存模型-vs-java对象模型"}},[a._v("#")]),a._v(" JVM内存结构 VS Java内存模型 VS Java对象模型")]),a._v(" "),_("p",[a._v("原文地址：http://www.hollischuang.com/archives/2509")]),a._v(" "),_("p",[a._v("JVM内存结构，如下图")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://txxs.github.io/pic/tofutureinterview/1-18.png",alt:"1"}}),a._v("\nJava内存模型，如下图")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://txxs.github.io/pic/tofutureinterview/1-19.png",alt:"1"}}),a._v("\nJava对象模型(JMM)，如下图")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://txxs.github.io/pic/tofutureinterview/1-20.png",alt:"1"}})]),a._v(" "),_("h3",{attrs:{id:"到底什么是jmm"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#到底什么是jmm"}},[a._v("#")]),a._v(" 到底什么是JMM")]),a._v(" "),_("p",[a._v("原文地址：https://www.hollischuang.com/archives/2550")]),a._v(" "),_("p",[a._v("JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。")]),a._v(" "),_("p",[a._v("Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。")]),a._v(" "),_("p",[a._v("在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。")]),a._v(" "),_("p",[a._v("在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("原子性：在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。在synchronized的实现原理文章中，介绍过，这两个字节码，在Java中对应的关键字就是synchronized。因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。")])]),a._v(" "),_("li",[_("p",[a._v("可见性：Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。")])]),a._v(" "),_("li",[_("p",[a._v("有序性：在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。")])])])])}),[],!1,null,null,null);v.default=r.exports}}]);