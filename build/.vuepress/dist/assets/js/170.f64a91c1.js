(window.webpackJsonp=window.webpackJsonp||[]).push([[170],{549:function(e,a,t){"use strict";t.r(a);var v=t(13),r=Object(v.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("原文地址：\n"),t("code",[e._v("https://zhuanlan.zhihu.com/p/32820815 https://zhuanlan.zhihu.com/p/43560613 https://www.cnblogs.com/draem0507/p/9350699.html")])]),e._v(" "),t("p",[e._v("G1 GC是Jdk7的新特性之一、Jdk7+版本都可以自主配置G1作为JVM GC选项；作为JVM GC算法的一次重大升级、DK7u后G1已相对稳定、且未来计划替代CMS、所以有必要深入了解下，其设计目标如下:")]),e._v(" "),t("p",[e._v("1、可以像CMS收集器一样，GC操作与应用的线程一起并发执行；")]),e._v(" "),t("p",[e._v("2、紧凑的空闲内存区间且没有很长的GC停顿时间；")]),e._v(" "),t("p",[e._v("3、需要更多可预测的GC停顿时间；")]),e._v(" "),t("p",[e._v("4、不想牺牲太多吞吐量性能；")]),e._v(" "),t("p",[e._v("5、启动后不需要请求更大的Java堆。")]),e._v(" "),t("h3",{attrs:{id:"内存占用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存占用"}},[e._v("#")]),e._v(" 内存占用：")]),e._v(" "),t("p",[e._v("如果从 ParallelOldGC 或者 CMS收集器迁移到 G1，可能会看到JVM进程占用更多的内存(a larger JVM process size)。 这在很大程度上与 “accounting” 数据结构有关，如 Remembered Sets 和 Collection Sets。")]),e._v(" "),t("p",[e._v("Remembered Sets 简称 RSets。跟踪指向某个heap区内的对象引用。 堆内存中的每个区都有一个 RSet。 RSet 使heap区能并行独立地进行垃圾集合。 RSets的总体影响小于5%。")]),e._v(" "),t("p",[e._v("Collection Sets 简称 CSets。收集集合, 在一次GC中将执行垃圾回收的heap区。GC时在CSet中的所有存活数据(live data)都会被转移(复制/移动)。集合中的heap区可以是 Eden, survivor, 和/或 old generation。CSets所占用的JVM内存小于1%。")]),e._v(" "),t("h3",{attrs:{id:"推荐使用g1的场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#推荐使用g1的场景"}},[e._v("#")]),e._v(" 推荐使用G1的场景")]),e._v(" "),t("p",[e._v("G1的首要目标是为需要大量内存的系统提供一个保证GC低延迟的解决方案。 也就是说堆内存在6GB及以上，稳定和可预测的暂停时间小于0.5秒。")]),e._v(" "),t("p",[e._v("如果应用程序具有如下的一个或多个特征，那么将垃圾收集器从CMS或ParallelOldGC切换到G1将会大大提升性能。")]),e._v(" "),t("p",[e._v("1、Full GC 次数太频繁或者消耗时间太长.")]),e._v(" "),t("p",[e._v("2、对象分配的频率或代数提升(promotion)显著变化.")]),e._v(" "),t("p",[e._v("3、受够了太长的垃圾回收或内存整理时间(超过0.5~1秒)")]),e._v(" "),t("p",[e._v("注意: 如果正在使用CMS或ParallelOldGC，而应用程序的垃圾收集停顿时间并不长，那么建议继续使用现在的垃圾收集器。使用最新的JDK时，并不要求切换到G1收集器。")]),e._v(" "),t("h3",{attrs:{id:"g1组成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#g1组成"}},[e._v("#")]),e._v(" G1组成")]),e._v(" "),t("p",[e._v("G1堆由多个区（region）组成，每个区大小1M~32M，逻辑上区有3种类型，包括（Eden、Survivor、Old），按分代划分包括：年轻代（Young Generation）和老年代（Old Generation）。")]),e._v(" "),t("p",[e._v("在G1中，还有一种特殊的区域，叫Humongous区域。 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://txxs.github.io/pic/tofuturejavajvm/4-1.png",alt:"1"}})]),e._v(" "),t("h3",{attrs:{id:"对象分配策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象分配策略"}},[e._v("#")]),e._v(" 对象分配策略")]),e._v(" "),t("p",[e._v("说起大对象的分配，我们不得不谈谈对象的分配策略。它分为3个阶段：")]),e._v(" "),t("p",[e._v("1、TLAB(Thread Local Allocation Buffer)线程本地分配缓冲区")]),e._v(" "),t("p",[e._v("2、Eden区中分配")]),e._v(" "),t("p",[e._v("3、Humongous区分配")]),e._v(" "),t("p",[e._v("TLAB为线程本地分配缓冲区，它的目的为了使对象尽可能快的分配出来。如果对象在一个共享的空间中分配，我们需要采用一些同步机制来管理这些空间内的空闲空间指针。在Eden空间中，每一个线程都有一个固定的分区用于分配对象，即一个TLAB。分配对象时，线程之间不再需要进行任何的同步。对TLAB空间中无法分配的对象，JVM会尝试在Eden空间中进行分配。如果Eden空间无法容纳该对象，就只能在老年代中进行分配空间。")]),e._v(" "),t("p",[e._v("最后，G1提供了两种GC模式，Young GC和Mixed GC，两种都是Stop The World(STW)的。下面我们将分别介绍一下这2种模式。")]),e._v(" "),t("h3",{attrs:{id:"young-gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#young-gc"}},[e._v("#")]),e._v(" Young GC")]),e._v(" "),t("p",[e._v("Young GC是stop-the-world活动，会导致整个应用线程的停止。其过程如下：")]),e._v(" "),t("p",[e._v("新对象进入Eden区")]),e._v(" "),t("p",[e._v("存活对象拷贝到Survivor区；")]),e._v(" "),t("p",[e._v("存活时间达到年龄阈值时，对象晋升到Old区。")]),e._v(" "),t("p",[e._v("young gc是多线程并行执行的。")]),e._v(" "),t("p",[e._v("Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC停止工作，应用线程继续执行。")]),e._v(" "),t("p",[e._v("这时，我们需要考虑一个问题，如果仅仅GC 新生代对象，我们如何找到所有的根对象呢？ 老年代的所有对象都是根么？那这样扫描下来会耗费大量的时间。于是，G1引进了RSet的概念。它的全称是Remembered Set，作用是跟踪指向某个heap区内的对象引用。")]),e._v(" "),t("p",[e._v("在CMS中，也有RSet的概念，在老年代中有一块区域用来记录指向新生代的引用。这是一种point-out，在进行Young GC时，扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。\n但在G1中，并没有使用point-out，这是由于一个分区太小，分区数量太多，如果是用point-out的话，会造成大量的扫描浪费，有些根本不需要GC的分区引用也扫描了。于是G1中使用point-in来解决。point-in的意思是哪些分区引用了当前分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。由于新生代有多个，那么我们需要在新生代之间记录引用吗？这是不必要的，原因在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。\n需要注意的是，如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在G1 中又引入了另外一个概念，卡表（Card Table）。一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（即数组下标）来标识每个分区的空间地址。默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，即标记为脏被引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。")]),e._v(" "),t("p",[e._v("Young GC 阶段：")]),e._v(" "),t("p",[e._v("阶段1：根扫描，静态和本地对象被扫描")]),e._v(" "),t("p",[e._v("阶段2：更新RS，处理dirty card队列更新RS")]),e._v(" "),t("p",[e._v("阶段3：处理RS，检测从年轻代指向年老代的对象")]),e._v(" "),t("p",[e._v("阶段4：对象拷贝，拷贝存活的对象到survivor/old区域")]),e._v(" "),t("p",[e._v("阶段5：处理引用队列")]),e._v(" "),t("h3",{attrs:{id:"mix-gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mix-gc"}},[e._v("#")]),e._v(" Mix GC")]),e._v(" "),t("p",[e._v("Mix GC不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。\n它的GC步骤分2步：")]),e._v(" "),t("p",[e._v("全局并发标记（global concurrent marking）")]),e._v(" "),t("p",[e._v("拷贝存活对象（evacuation）")]),e._v(" "),t("p",[e._v("在进行Mix GC之前，会先进行global concurrent marking（全局并发标记）。 global concurrent marking的执行过程是怎样的呢？\n在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节。global concurrent marking的执行过程分为五个步骤：")]),e._v(" "),t("p",[e._v("初始标记（initial mark，STW），在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关。")]),e._v(" "),t("p",[e._v("根区域扫描（root region scan），G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收。")]),e._v(" "),t("p",[e._v("并发标记（Concurrent Marking），G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断")]),e._v(" "),t("p",[e._v("最终标记（Remark，STW），该阶段是 STW 回收，帮助完成标记周期。G1 GC 清空 SATB 缓冲区，跟踪未被访问的存活对象，并执行引用处理。")]),e._v(" "),t("p",[e._v("清除垃圾（Cleanup，STW），在这个最后阶段，G1 GC 执行统计和 RSet 净化的 STW 操作。在统计期间，G1 GC 会识别完全空闲的区域和可供进行混合垃圾回收的区域。清理阶段在将空白区域重置并返回到空闲列表时为部分并发。")]),e._v(" "),t("h3",{attrs:{id:"调优实践"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调优实践"}},[e._v("#")]),e._v(" 调优实践")]),e._v(" "),t("p",[e._v("MaxGCPauseMillis调优")]),e._v(" "),t("p",[e._v("前面介绍过使用GC的最基本的参数：")]),e._v(" "),t("p",[e._v("-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200\n前面2个参数都好理解，后面这个MaxGCPauseMillis参数该怎么配置呢？这个参数从字面的意思上看，就是允许的GC最大的暂停时间。G1尽量确保每次GC暂停的时间都在设置的MaxGCPauseMillis范围内。 那G1是如何做到最大暂停时间的呢？这涉及到另一个概念，CSet(collection set)。它的意思是在一次垃圾收集器中被收集的区域集合。")]),e._v(" "),t("p",[e._v("Young GC：选定所有新生代里的region。通过控制新生代的region个数来控制young GC的开销。")]),e._v(" "),t("p",[e._v("Mixed GC：选定所有新生代里的region，外加根据global concurrent\nmarking统计得出收集收益高的若干老年代region。在用户指定的开销目标范围内尽可能选择收益高的老年代region。\n在理解了这些后，我们再设置最大暂停时间就好办了。 首先，我们能容忍的最大暂停时间是有一个限度的，我们需要在这个限度范围内设置。但是应该设置的值是多少呢？我们需要在吞吐量跟MaxGCPauseMillis之间做一个平衡。如果MaxGCPauseMillis设置的过小，那么GC就会频繁，吞吐量就会下降。如果MaxGCPauseMillis设置的过大，应用程序暂停时间就会变长。G1的默认暂停时间是200毫秒，我们可以从这里入手，调整合适的时间。")]),e._v(" "),t("p",[e._v("其他调优参数:")]),e._v(" "),t("p",[e._v("-XX:G1HeapRegionSize=n\n设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。")]),e._v(" "),t("p",[e._v("-XX:ParallelGCThreads=n\n设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。\n如果逻辑处理器不止八个，则将 n 的值设置为逻辑处理器数的 5/8 左右。这适用于大多数情况，除非是较大的 SPARC 系统，其中 n 的值可以是逻辑处理器数的 5/16 左右。")]),e._v(" "),t("p",[e._v("-XX:ConcGCThreads=n\n设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右。\n-XX:InitiatingHeapOccupancyPercent=45\n设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。")]),e._v(" "),t("p",[e._v("避免使用以下参数：\n避免使用 -Xmn 选项或 -XX:NewRatio 等其他相关选项显式设置年轻代大小。固定年轻代的大小会覆盖暂停时间目标。")]),e._v(" "),t("h3",{attrs:{id:"触发full-gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#触发full-gc"}},[e._v("#")]),e._v(" 触发Full GC")]),e._v(" "),t("p",[e._v("在某些情况下，G1触发了Full GC，这时G1会退化使用Serial收集器来完成垃圾的清理工作，它仅仅使用单线程来完成GC工作，GC暂停时间将达到秒级别的。整个应用处于假死状态，不能处理任何请求，我们的程序当然不希望看到这些。那么发生Full GC的情况有哪些呢？")]),e._v(" "),t("p",[e._v("1、并发模式失败")]),e._v(" "),t("p",[e._v("G1启动标记周期，但在Mix GC之前，老年代就被填满，这时候G1会放弃标记周期。这种情形下，需要增加堆大小，或者调整周期（例如增加线程数-XX:ConcGCThreads等）。")]),e._v(" "),t("p",[e._v("2、晋升失败或者疏散失败")]),e._v(" "),t("p",[e._v("G1在进行GC的时候没有足够的内存供存活对象或晋升对象使用，由此触发了Full GC。可以在日志中看到(to-space exhausted)或者（to-space overflow）。解决这种问题的方式是：\na,增加 -XX:G1ReservePercent 选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量。\nb,通过减少 -XX:InitiatingHeapOccupancyPercent 提前启动标记周期。\nc,也可以通过增加 -XX:ConcGCThreads 选项的值来增加并行标记线程的数目。")]),e._v(" "),t("p",[e._v("3、巨型对象分配失败")]),e._v(" "),t("p",[e._v("当巨型对象找不到合适的空间进行分配时，就会启动Full GC，来释放空间。这种情况下，应该避免分配大量的巨型对象，增加内存或者增大-XX:G1HeapRegionSize，使巨型对象不再是巨型对象。")]),e._v(" "),t("h3",{attrs:{id:"一些概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一些概念"}},[e._v("#")]),e._v(" 一些概念")]),e._v(" "),t("h4",{attrs:{id:"分区-region"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分区-region"}},[e._v("#")]),e._v(" 分区 Region")]),e._v(" "),t("p",[e._v("G1采用了分区(Region)的思路，将整个堆空间分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。因此，在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize=n可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区。")]),e._v(" "),t("h4",{attrs:{id:"卡片-card"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#卡片-card"}},[e._v("#")]),e._v(" 卡片 Card")]),e._v(" "),t("p",[e._v("在每个分区内部又被分成了若干个大小为512 Byte卡片(Card)，标识堆内存最小可用粒度所有分区的卡片将会记录在全局卡片表(Global Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见RSet)。每次对内存的回收，都是对指定分区的卡片进行处理。")]),e._v(" "),t("h4",{attrs:{id:"堆-heap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆-heap"}},[e._v("#")]),e._v(" 堆 Heap")]),e._v(" "),t("p",[e._v("G1同样可以通过-Xms/-Xmx来指定堆空间大小。当发生年轻代收集或混合收集时，通过计算GC与应用的耗费时间比，自动调整堆空间大小。如果GC频率太高，则通过增加堆尺寸，来减少GC频率，相应地GC占用的时间也随之降低；目标参数-XX:GCTimeRatio即为GC与应用的耗费时间比，G1默认为9，而CMS默认为99，因为CMS的设计原则是耗费在GC上的时间尽可能的少。另外，当空间不足，如对象空间分配或转移失败时，G1会首先尝试增加堆空间，如果扩容失败，则发起担保的Full GC。Full GC后，堆尺寸计算结果也会调整堆空间。")]),e._v(" "),t("h4",{attrs:{id:"分代-generation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分代-generation"}},[e._v("#")]),e._v(" 分代 Generation")]),e._v(" "),t("p",[e._v("分代垃圾收集可以将关注点集中在最近被分配的对象上，而无需整堆扫描，避免长命对象的拷贝，同时独立收集有助于降低响应时间。虽然分区使得内存分配不再要求紧凑的内存空间，但G1依然使用了分代的思想。与其他垃圾收集器类似，G1将内存在逻辑上划分为年轻代和老年代，其中年轻代又划分为Eden空间和Survivor空间。但年轻代空间并不是固定不变的，当现有年轻代分区占满时，JVM会分配新的空闲分区加入到年轻代空间。")]),e._v(" "),t("p",[e._v("整个年轻代内存会在初始空间-XX:G1NewSizePercent(默认整堆5%)与最大空间-XX:G1MaxNewSizePercent(默认60%)之间动态变化，且由参数目标暂停时间-XX:MaxGCPauseMillis(默认200ms)、需要扩缩容的大小以及分区的已记忆集合(RSet)计算得到。当然，G1依然可以设置固定的年轻代大小(参数-XX:NewRatio、-Xmn)，但同时暂停目标将失去意义。")]),e._v(" "),t("h4",{attrs:{id:"本地分配缓冲-local-allocation-buffer-lab"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本地分配缓冲-local-allocation-buffer-lab"}},[e._v("#")]),e._v(" 本地分配缓冲 Local allocation buffer (Lab)")]),e._v(" "),t("p",[e._v("值得注意的是，由于分区的思想，每个线程均可以”认领”某个分区用于线程本地的内存分配，而不需要顾及分区是否连续。因此，每个应用线程和GC线程都会独立的使用分区，进而减少同步时间，提升GC效率，这个分区称为本地分配缓冲区(Lab)。")]),e._v(" "),t("p",[e._v("其中，应用线程可以独占一个本地缓冲区(TLAB)来创建的对象，而大部分都会落入Eden区域(巨型对象或分配失败除外)，因此TLAB的分区属于Eden空间；而每次垃圾收集时，每个GC线程同样可以独占一个本地缓冲区(GCLAB)用来转移对象，每次回收会将对象复制到Suvivor空间或老年代空间；对于从Eden/Survivor空间晋升(Promotion)到Survivor/老年代空间的对象，同样有GC独占的本地缓冲区进行操作，该部分称为晋升本地缓冲区(PLAB)。")]),e._v(" "),t("h4",{attrs:{id:"巨型对象-humongous-region"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#巨型对象-humongous-region"}},[e._v("#")]),e._v(" 巨型对象 Humongous Region")]),e._v(" "),t("p",[e._v("一个大小达到甚至超过分区大小一半的对象称为巨型对象(Humongous Object)。当线程为巨型分配空间时，不能简单在TLAB进行分配，因为巨型对象的移动成本很高，而且有可能一个分区不能容纳巨型对象。因此，巨型对象会直接在老年代分配，所占用的连续空间称为巨型分区(Humongous Region)。G1内部做了一个优化，一旦发现没有引用指向巨型对象，则可直接在年轻代收集周期中被回收。")]),e._v(" "),t("p",[e._v("巨型对象会独占一个、或多个连续分区，其中第一个分区被标记为开始巨型(StartsHumongous)，相邻连续分区被标记为连续巨型(ContinuesHumongous)。由于无法享受Lab带来的优化，并且确定一片连续的内存空间需要扫描整堆，因此确定巨型对象开始位置的成本非常高，如果可以，应用程序应避免生成巨型对象。")]),e._v(" "),t("h4",{attrs:{id:"已记忆集合-remember-set-rset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#已记忆集合-remember-set-rset"}},[e._v("#")]),e._v(" 已记忆集合 Remember Set (RSet)")]),e._v(" "),t("p",[e._v("在串行和并行收集器中，GC通过整堆扫描，来确定对象是否处于可达路径中。然而G1为了避免STW式的整堆扫描，在每个分区记录了一个已记忆集合(RSet)，内部类似一个反向指针，记录引用分区内对象的卡片索引。当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况。")]),e._v(" "),t("p",[e._v("事实上，并非所有的引用都需要记录在RSet中，如果一个分区确定需要扫描，那么无需RSet也可以无遗漏的得到引用关系。那么引用源自本分区的对象，当然不用落入RSet中；同时，G1 GC每次都会对年轻代进行整体收集，因此引用源自年轻代的对象，也不需要在RSet中记录。最后只有老年代的分区可能会有RSet记录，这些分区称为拥有RSet分区(an RSet’s owning region)。")]),e._v(" "),t("h4",{attrs:{id:"per-region-table-prt"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#per-region-table-prt"}},[e._v("#")]),e._v(" Per Region Table (PRT)")]),e._v(" "),t("p",[e._v("RSet在内部使用Per Region Table(PRT)记录分区的引用情况。由于RSet的记录要占用分区的空间，如果一个分区非常”受欢迎”，那么RSet占用的空间会上升，从而降低分区的可用空间。G1应对这个问题采用了改变RSet的密度的方式，在PRT中将会以三种模式记录引用：")]),e._v(" "),t("p",[e._v("稀少：直接记录引用对象的卡片索引\n细粒度：记录引用对象的分区索引\n粗粒度：只记录引用情况，每个分区对应一个比特位\n由上可知，粗粒度的PRT只是记录了引用数量，需要通过整堆扫描才能找出所有引用，因此扫描速度也是最慢的。")]),e._v(" "),t("h4",{attrs:{id:"收集集合-cset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#收集集合-cset"}},[e._v("#")]),e._v(" 收集集合 CSet")]),e._v(" "),t("p",[e._v("收集集合(CSet)代表每次GC暂停时回收的一系列目标分区。在任意一次收集暂停中，CSet所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。因此无论是年轻代收集，还是混合收集，工作的机制都是一致的。年轻代收集CSet只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到CSet中。")]),e._v(" "),t("p",[e._v("候选老年代分区的CSet准入条件，可以通过活跃度阈值-XX:G1MixedGCLiveThresholdPercent(默认85%)进行设置，从而拦截那些回收开销巨大的对象；同时，每次混合收集可以包含候选老年代分区，可根据CSet对堆的总大小占比-XX:G1OldCSetRegionThresholdPercent(默认10%)设置数量上限。")]),e._v(" "),t("p",[e._v("由上述可知，G1的收集都是根据CSet进行操作的，年轻代收集与混合收集没有明显的不同，最大的区别在于两种收集的触发条件。")]),e._v(" "),t("h4",{attrs:{id:"年轻代收集集合-cset-of-young-collection"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#年轻代收集集合-cset-of-young-collection"}},[e._v("#")]),e._v(" 年轻代收集集合 CSet of Young Collection")]),e._v(" "),t("p",[e._v("应用线程不断活动后，年轻代空间会被逐渐填满。当JVM分配对象到Eden区域失败(Eden区已满)时，便会触发一次STW式的年轻代收集。在年轻代收集中，Eden分区存活的对象将被拷贝到Survivor分区；原有Survivor分区存活的对象，将根据任期阈值(tenuring threshold)分别晋升到PLAB中，新的survivor分区和老年代分区。而原有的年轻代分区将被整体回收掉。")]),e._v(" "),t("p",[e._v("同时，年轻代收集还负责维护对象的年龄(存活次数)，辅助判断老化(tenuring)对象晋升的时候是到Survivor分区还是到老年代分区。年轻代收集首先先将晋升对象尺寸总和、对象年龄信息维护到年龄表中，再根据年龄表、Survivor尺寸、Survivor填充容量-XX:TargetSurvivorRatio(默认50%)、最大任期阈值-XX:MaxTenuringThreshold(默认15)，计算出一个恰当的任期阈值，凡是超过任期阈值的对象都会被晋升到老年代。")]),e._v(" "),t("h4",{attrs:{id:"混合收集集合-cset-of-mixed-collection"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#混合收集集合-cset-of-mixed-collection"}},[e._v("#")]),e._v(" 混合收集集合 CSet of Mixed Collection")]),e._v(" "),t("p",[e._v("年轻代收集不断活动后，老年代的空间也会被逐渐填充。当老年代占用空间超过整堆比IHOP阈值-XX:InitiatingHeapOccupancyPercent(默认45%)时，G1就会启动一次混合垃圾收集周期。为了满足暂停目标，G1可能不能一口气将所有的候选分区收集掉，因此G1可能会产生连续多次的混合收集与应用线程交替执行，每次STW的混合收集与年轻代收集过程相类似。")]),e._v(" "),t("p",[e._v("为了确定包含到年轻代收集集合CSet的老年代分区，JVM通过参数混合周期的最大总次数-XX:G1MixedGCCountTarget(默认8)、堆废物百分比-XX:G1HeapWastePercent(默认5%)。通过候选老年代分区总数与混合周期最大总次数，确定每次包含到CSet的最小分区数量；根据堆废物百分比，当收集达到参数时，不再启动新的混合收集。而每次添加到CSet的分区，则通过计算得到的GC效率进行安排。")])])}),[],!1,null,null,null);a.default=r.exports}}]);