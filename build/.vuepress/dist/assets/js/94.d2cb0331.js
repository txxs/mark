(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{468:function(s,t,a){"use strict";a.r(t);var v=a(13),_=Object(v.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("原文地址：")]),s._v(" "),a("p",[s._v("http://www.jishuwen.com/d/2udm")]),s._v(" "),a("p",[s._v("https://www.bangbangde.com/post/gossip.html")]),s._v(" "),a("p",[s._v("http://kaiyuan.me/2015/07/08/Gossip/")]),s._v(" "),a("p",[s._v("https://blog.csdn.net/qq_33814629/article/details/79904158")]),s._v(" "),a("p",[s._v("https://www.jianshu.com/p/8279d6fd65bb")]),s._v(" "),a("p",[s._v("https://my.oschina.net/u/3847203/blog/3024666")]),s._v(" "),a("h3",{attrs:{id:"gossip是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gossip是什么"}},[s._v("#")]),s._v(" Gossip是什么")]),s._v(" "),a("p",[s._v("Gossip协议是一个通信协议，一种传播消息的方式，也是一种最终一致性协议，灵感来自于：瘟疫、社交网络等。使用Gossip协议的有：Redis Cluster、Consul、Apache Cassandra等。Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个"),a("strong",[s._v("最终一致性协议")]),s._v("。")]),s._v(" "),a("h3",{attrs:{id:"六度分隔理论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六度分隔理论"}},[s._v("#")]),s._v(" 六度分隔理论")]),s._v(" "),a("p",[s._v("说到社交网络，就不得不提著名的 六度分隔理论 。1967年，哈佛大学的心理学教授Stanley Milgram想要描绘一个连结人与社区的人际连系网。做过一次连锁信实验，结果发现了“六度分隔”现象。简单地说：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过六个人你就能够认识任何一个陌生人。")]),s._v(" "),a("p",[s._v("数学解释该理论：若每个人平均认识260人，其六度就是260↑6 =1,188,137,600,000。消除一些节点重复，那也几乎 覆盖 了整个地球人口若干多多倍，这也是Gossip协议的雏形。")]),s._v(" "),a("h3",{attrs:{id:"原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[s._v("#")]),s._v(" 原理")]),s._v(" "),a("p",[s._v("Gossip协议基本思想就是：一个节点想要分享一些信息给网络中的其他的一些节点。于是，它 周期性 的 随机 选择一些节点，并把信息传递给这些节点。这些收到信息的节点接下来会做同样的事情，即把这些信息传递给其他一些随机选择的节点。一般而言，信息会周期性的传递给N个目标节点，而不只是一个。这个N被称为 fanout （这个单词的本意是扇出）。")]),s._v(" "),a("h3",{attrs:{id:"用途"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用途"}},[s._v("#")]),s._v(" 用途")]),s._v(" "),a("p",[s._v("Gossip协议的主要用途就是 信息传播和扩散 ：即把一些发生的事件传播到全世界。它们也被用于数据库复制，信息扩散，集群成员身份确认，故障探测等。")]),s._v(" "),a("p",[s._v("基于Gossip协议的一些有名的系统：Apache Cassandra，Redis（Cluster模式），Consul等。")]),s._v(" "),a("h3",{attrs:{id:"可扩展性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可扩展性"}},[s._v("#")]),s._v(" 可扩展性")]),s._v(" "),a("p",[s._v("Gossip协议是可扩展的，因为它只需要O(logN) 个周期就能把消息传播给所有节点。某个节点在往固定数量节点传播消息过程中，并不需要等待确认（ack），并且，即使某条消息传播过程中丢失，它也不需要做任何补偿措施。大哥比方，某个节点本来需要将消息传播给4个节点，但是由于网络或者其他原因，只有3个消息接收到消息，即使这样，这对最终所有节点接收到消息是没有任何影响的。")]),s._v(" "),a("p",[s._v("如下表格所示，假定fanout=4，那么在节点数分别是20、40、80、160时，消息传播到所有节点需要的循环次数对比，在节点成倍扩大的情况下，循环次数并没有增加很多。所以，Gossip协议具备可扩展性：")]),s._v(" "),a("h3",{attrs:{id:"可扩展性-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可扩展性-2"}},[s._v("#")]),s._v(" 可扩展性")]),s._v(" "),a("p",[s._v("失败容错\nGossip也具备失败容错的能力，即使网络故障等一些问题，Gossip协议依然能很好的运行。因为一个节点会多次分享某个需要传播的信息，即使不能连通某个节点，其他被感染的节点也会尝试向这个节点传播信息。")]),s._v(" "),a("h3",{attrs:{id:"健壮性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#健壮性"}},[s._v("#")]),s._v(" 健壮性")]),s._v(" "),a("p",[s._v("Gossip协议下，没有任何扮演特殊角色的节点（比如leader等）。任何一个节点无论什么时候下线或者加入，并不会破坏整个系统的服务质量。然而，Gossip协议也有不完美的地方，例如， 拜占庭 问题（Byzantine）。即，如果有一个恶意传播消息的节点，Gossip协议的分布式系统就会出问题。")]),s._v(" "),a("h3",{attrs:{id:"复杂度分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复杂度分析"}},[s._v("#")]),s._v(" 复杂度分析")]),s._v(" "),a("p",[s._v("对于一个节点数为 N 的网络来说，假设每个 Gossip 周期，新感染的节点都能再感染至少一个新节点，那么 Gossip 协议退化成一个二叉树查找，经过 LogN 个周期之后，感染全网，时间开销是 O(LogN)。由于每个周期，每个节点都会至少发出一次消息，因此，消息复杂度（消息数量 = N * N）是 O(N^2) 。注意，这是 Gossip 理论上最优的收敛速度，但是在实际情况中，最优的收敛速度")]),s._v(" "),a("h3",{attrs:{id:"gossip-的特点-优势"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gossip-的特点-优势"}},[s._v("#")]),s._v(" Gossip 的特点（优势）")]),s._v(" "),a("p",[s._v("1）扩展性")]),s._v(" "),a("p",[s._v("网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。")]),s._v(" "),a("p",[s._v("2）容错")]),s._v(" "),a("p",[s._v("网络中任何节点的宕机和重启都不会影响 Gossip 消息的传播，Gossip 协议具有天然的分布式系统容错特性。")]),s._v(" "),a("p",[s._v("3）去中心化")]),s._v(" "),a("p",[s._v("Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。")]),s._v(" "),a("p",[s._v("4）一致性收敛")]),s._v(" "),a("p",[s._v("Gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN。")]),s._v(" "),a("p",[s._v("5）简单")]),s._v(" "),a("p",[s._v("Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性。")]),s._v(" "),a("h3",{attrs:{id:"gossip-的缺陷"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gossip-的缺陷"}},[s._v("#")]),s._v(" Gossip 的缺陷")]),s._v(" "),a("p",[s._v("分布式网络中，没有一种完美的解决方案，Gossip 协议跟其他协议一样，也有一些不可避免的缺陷，主要是两个：")]),s._v(" "),a("p",[s._v("1）消息的延迟")]),s._v(" "),a("p",[s._v("由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下。")]),s._v(" "),a("p",[s._v("2）消息冗余")]),s._v(" "),a("p",[s._v("Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余。")]),s._v(" "),a("h3",{attrs:{id:"gossip-中的通信模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gossip-中的通信模式"}},[s._v("#")]),s._v(" Gossip 中的通信模式")]),s._v(" "),a("p",[s._v("在 Gossip 协议下，网络中两个节点之间有三种通信方式:")]),s._v(" "),a("p",[s._v("Push: 节点 A 将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据")]),s._v(" "),a("p",[s._v("Pull：A 仅将数据 key, version 推送给 B，B 将本地比 A 新的数据（Key, value, version）推送给 A，A 更新本地")]),s._v(" "),a("p",[s._v("Push/Pull：与 Pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 则更新本地")]),s._v(" "),a("p",[s._v("如果把两个节点数据同步一次定义为一个周期，则在一个周期内，Push 需通信 1 次，Pull 需 2 次，Push/Pull 则需 3 次。虽然消息数增加了，但从效果上来讲，Push/Pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，Push/Pull 的收敛速度也是最快的。")]),s._v(" "),a("h3",{attrs:{id:"redis-cluster-gossip的机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-cluster-gossip的机制"}},[s._v("#")]),s._v(" Redis cluster gossip的机制")]),s._v(" "),a("p",[s._v("社区版redis cluster是一个P2P无中心节点的集群架构，依靠gossip协议传播协同自动化修复集群的状态。本文将深入redis cluster gossip协议的细节，剖析redis cluster gossip协议机制如何运转。")]),s._v(" "),a("h4",{attrs:{id:"运转机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#运转机制"}},[s._v("#")]),s._v(" 运转机制")]),s._v(" "),a("p",[s._v("通过gossip协议，cluster可以提供集群间状态同步更新、选举自助failover等重要的集群功能。")]),s._v(" "),a("h4",{attrs:{id:"gossip协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gossip协议"}},[s._v("#")]),s._v(" gossip协议")]),s._v(" "),a("p",[s._v("gossip协议包含多种消息，包括ping，pong，meet，fail等等。")]),s._v(" "),a("p",[s._v("meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信；")]),s._v(" "),a("p",[s._v("ping：每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据；")]),s._v(" "),a("p",[s._v("pong: 返回ping和meet，包含自己的状态和其他信息，也可以用于信息广播和更新；")]),s._v(" "),a("p",[s._v("fail: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。")]),s._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[s._v("高可用性与主备切换原理")])]),s._v(" "),a("h4",{attrs:{id:"_3-1-判断节点宕机-这个和redis和哨兵机制一致"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-判断节点宕机-这个和redis和哨兵机制一致"}},[s._v("#")]),s._v(" 3.1 判断节点宕机（这个和redis和哨兵机制一致）")]),s._v(" "),a("p",[s._v("如果一个节点认为另外一个节点宕机，name就是pfail，主观宕机；\n如果多个节点都认为另外一个节点宕机了，那么就是fail，客观宕机，跟哨兵的原理几乎一样，sdown，odown；\n在cluster-node-timeout内，某个节点一直没有返回pong，那么就被认为pfail；\n如果一个节点认为某个节点pfail了，那么会在gossip ping消息中，ping给其他节点，如果超过半数的节点都认为pfail了，那么就会变成fail；")]),s._v(" "),a("h4",{attrs:{id:"_3-2-从节点过滤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-从节点过滤"}},[s._v("#")]),s._v(" 3.2 从节点过滤")]),s._v(" "),a("p",[s._v("对宕机的master node，从其所有的slave node中，选择一个切换成master node；\n检查每个slave node与master node断开连接的时间，如果超过了cluster-node-timeout * cluster-slave-validity-factor，那么就没有资格切换成master；")]),s._v(" "),a("h4",{attrs:{id:"_3-3-从节点选举"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-从节点选举"}},[s._v("#")]),s._v(" 3.3 从节点选举")]),s._v(" "),a("p",[s._v("哨兵：对所有从节点进行排序，slave priority，offset，run id；\n每个从节点，都根据自己对master复制数据的offset，来设置一个选举时间，offset越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举；\n所有的master node开始slave选举投票，给要进行选举的slave进行投票，如果大部分master node（N/2 + 1）都投票给了某个从节点，那么选举通过，那个从节点可以切换成master；\n从节点执行主备切换，从节点切换为主节点；")])])}),[],!1,null,null,null);t.default=_.exports}}]);