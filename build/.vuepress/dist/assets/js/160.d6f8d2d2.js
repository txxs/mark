(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{534:function(t,a,n){"use strict";n.r(a);var e=n(13),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("原文地址：\nhttps://blog.csdn.net/weixin_36759405/article/details/82770422\nhttps://juejin.im/post/5b69aa63f265da0f4a4e97e0")]),t._v(" "),n("p",[t._v("JDK动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。")]),t._v(" "),n("p",[t._v("CGlib动态代理：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。")]),t._v(" "),n("p",[t._v("区别：JDK代理只能对实现接口的类生成代理；CGlib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理final修饰的类。")]),t._v(" "),n("p",[t._v("总结：\n1.JDK代理使用的是反射机制实现aop的动态代理，CGLIB代理使用字节码处理框架asm，通过修改字节码生成子类。所以jdk动态代理的方式创建代理对象效率较高，执行效率较低，cglib创建效率较低，执行效率高；\n2.JDK动态代理机制是委托机制，具体说动态实现接口类，在动态生成的实现类里面委托hanlder去调用原始实现类方法，CGLIB则使用的继承机制，具体说被代理类和代理类是继承关系，所以代理类是可以赋值给被代理类的，如果被代理类有接口，那么代理类也可以赋值给接口。")]),t._v(" "),n("h3",{attrs:{id:"应用场景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),n("p",[t._v("动态代理在Spring、Mybatis、Dubbo等各大框架中均有大量使用，因此熟悉动态代理是阅读这些框架源码必须掌握的基本功之一")])])}),[],!1,null,null,null);a.default=s.exports}}]);