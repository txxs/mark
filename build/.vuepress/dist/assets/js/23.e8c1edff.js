(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{407:function(e,v,_){"use strict";_.r(v);var s=_(13),o=Object(s.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"面试题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面试题"}},[e._v("#")]),e._v(" 面试题")]),e._v(" "),_("p",[e._v("es 写入数据的工作原理是什么啊？es 查询数据的工作原理是什么啊？底层的 lucene 介绍一下呗？倒排索引了解吗？")]),e._v(" "),_("h2",{attrs:{id:"面试官心理分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面试官心理分析"}},[e._v("#")]),e._v(" 面试官心理分析")]),e._v(" "),_("p",[e._v("问这个，其实面试官就是要看看你了解不了解 es 的一些基本原理，因为用 es 无非就是写入数据，搜索数据。你要是不明白你发起一个写入和搜索请求的时候，es 在干什么，那你真的是......")]),e._v(" "),_("p",[e._v("对 es 基本就是个黑盒，你还能干啥？你唯一能干的就是用 es 的 api 读写数据了。要是出点什么问题，你啥都不知道，那还能指望你什么呢？")]),e._v(" "),_("h2",{attrs:{id:"面试题剖析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面试题剖析"}},[e._v("#")]),e._v(" 面试题剖析")]),e._v(" "),_("h3",{attrs:{id:"es-写数据过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#es-写数据过程"}},[e._v("#")]),e._v(" es 写数据过程")]),e._v(" "),_("ul",[_("li",[e._v("客户端选择一个 node 发送请求过去，这个 node 就是 "),_("code",[e._v("coordinating node")]),e._v("（协调节点）。")]),e._v(" "),_("li",[_("code",[e._v("coordinating node")]),e._v(" 对 document 进行"),_("strong",[e._v("路由")]),e._v("，将请求转发给对应的 node（有 primary shard）。")]),e._v(" "),_("li",[e._v("实际的 node 上的 "),_("code",[e._v("primary shard")]),e._v(" 处理请求，然后将数据同步到 "),_("code",[e._v("replica node")]),e._v("。")]),e._v(" "),_("li",[_("code",[e._v("coordinating node")]),e._v(" 如果发现 "),_("code",[e._v("primary node")]),e._v(" 和所有 "),_("code",[e._v("replica node")]),e._v(" 都搞定之后，就返回响应结果给客户端。")])]),e._v(" "),_("p",[_("img",{attrs:{src:"https://txxs.github.io/pic/tofuturedbes/1-3.png",alt:"1"}})]),e._v(" "),_("h3",{attrs:{id:"es-读数据过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#es-读数据过程"}},[e._v("#")]),e._v(" es 读数据过程")]),e._v(" "),_("p",[e._v("可以通过 "),_("code",[e._v("doc id")]),e._v(" 来查询，会根据 "),_("code",[e._v("doc id")]),e._v(" 进行 hash，判断出来当时把 "),_("code",[e._v("doc id")]),e._v(" 分配到了哪个 shard 上面去，从那个 shard 去查询。")]),e._v(" "),_("ul",[_("li",[e._v("客户端发送请求到"),_("strong",[e._v("任意")]),e._v("一个 node，成为 "),_("code",[e._v("coordinate node")]),e._v("。")]),e._v(" "),_("li",[_("code",[e._v("coordinate node")]),e._v(" 对 "),_("code",[e._v("doc id")]),e._v(" 进行哈希路由，将请求转发到对应的 node，此时会使用 "),_("code",[e._v("round-robin")]),e._v(" "),_("strong",[e._v("随机轮询算法")]),e._v("，在 "),_("code",[e._v("primary shard")]),e._v(" 以及其所有 replica 中随机选择一个，让读请求负载均衡。")]),e._v(" "),_("li",[e._v("接收请求的 node 返回 document 给 "),_("code",[e._v("coordinate node")]),e._v("。")]),e._v(" "),_("li",[_("code",[e._v("coordinate node")]),e._v(" 返回 document 给客户端。")])]),e._v(" "),_("h3",{attrs:{id:"es-搜索数据过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#es-搜索数据过程"}},[e._v("#")]),e._v(" es 搜索数据过程")]),e._v(" "),_("p",[e._v("es 最强大的是做全文检索，就是比如你有三条数据：")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("java真好玩儿啊\njava好难学啊\nj2ee特别牛\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br")])]),_("p",[e._v("你根据 "),_("code",[e._v("java")]),e._v(" 关键词来搜索，将包含 "),_("code",[e._v("java")]),e._v("的 "),_("code",[e._v("document")]),e._v(" 给搜索出来。es 就会给你返回：java真好玩儿啊，java好难学啊。")]),e._v(" "),_("ul",[_("li",[e._v("客户端发送请求到一个 "),_("code",[e._v("coordinate node")]),e._v("。")]),e._v(" "),_("li",[e._v("协调节点将搜索请求转发到"),_("strong",[e._v("所有")]),e._v("的 shard 对应的 "),_("code",[e._v("primary shard")]),e._v(" 或 "),_("code",[e._v("replica shard")]),e._v("，都可以。")]),e._v(" "),_("li",[e._v("query phase：每个 shard 将自己的搜索结果（其实就是一些 "),_("code",[e._v("doc id")]),e._v("）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。")]),e._v(" "),_("li",[e._v("fetch phase：接着由协调节点根据 "),_("code",[e._v("doc id")]),e._v(" 去各个节点上"),_("strong",[e._v("拉取实际")]),e._v("的 "),_("code",[e._v("document")]),e._v(" 数据，最终返回给客户端。")])]),e._v(" "),_("blockquote",[_("p",[e._v("写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。")])]),e._v(" "),_("h3",{attrs:{id:"写数据底层原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#写数据底层原理"}},[e._v("#")]),e._v(" 写数据底层原理")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://txxs.github.io/pic/tofuturedbes/1-4.png",alt:"1"}})]),e._v(" "),_("p",[e._v("先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。")]),e._v(" "),_("p",[e._v("如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 "),_("code",[e._v("refresh")]),e._v(" 到一个新的 "),_("code",[e._v("segment file")]),e._v(" 中，但是此时数据不是直接进入 "),_("code",[e._v("segment file")]),e._v(" 磁盘文件，而是先进入 "),_("code",[e._v("os cache")]),e._v(" 。这个过程就是 "),_("code",[e._v("refresh")]),e._v("。")]),e._v(" "),_("p",[e._v("每隔 1 秒钟，es 将 buffer 中的数据写入一个"),_("strong",[e._v("新的")]),e._v(" "),_("code",[e._v("segment file")]),e._v("，每秒钟会产生一个"),_("strong",[e._v("新的磁盘文件")]),e._v(" "),_("code",[e._v("segment file")]),e._v("，这个 "),_("code",[e._v("segment file")]),e._v(" 中就存储最近 1 秒内 buffer 中写入的数据。")]),e._v(" "),_("p",[e._v("但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。")]),e._v(" "),_("p",[e._v("操作系统里面，磁盘文件其实都有一个东西，叫做 "),_("code",[e._v("os cache")]),e._v("，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 "),_("code",[e._v("os cache")]),e._v("，先进入操作系统级别的一个内存缓存中去。只要 "),_("code",[e._v("buffer")]),e._v(" 中的数据被 refresh 操作刷入 "),_("code",[e._v("os cache")]),e._v("中，这个数据就可以被搜索到了。")]),e._v(" "),_("p",[e._v("为什么叫 es 是"),_("strong",[e._v("准实时")]),e._v("的？ "),_("code",[e._v("NRT")]),e._v("，全称 "),_("code",[e._v("near real-time")]),e._v("。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。可以通过 es 的 "),_("code",[e._v("restful api")]),e._v(" 或者 "),_("code",[e._v("java api")]),e._v("，"),_("strong",[e._v("手动")]),e._v("执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 "),_("code",[e._v("os cache")]),e._v("中，让数据立马就可以被搜索到。只要数据被输入 "),_("code",[e._v("os cache")]),e._v(" 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。")]),e._v(" "),_("p",[e._v("重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 "),_("code",[e._v("buffer")]),e._v(" 数据写入一个又一个新的 "),_("code",[e._v("segment file")]),e._v(" 中去，每次 "),_("code",[e._v("refresh")]),e._v(" 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 "),_("code",[e._v("commit")]),e._v(" 操作。")]),e._v(" "),_("p",[e._v("commit 操作发生第一步，就是将 buffer 中现有数据 "),_("code",[e._v("refresh")]),e._v(" 到 "),_("code",[e._v("os cache")]),e._v(" 中去，清空 buffer。然后，将一个 "),_("code",[e._v("commit point")]),e._v(" 写入磁盘文件，里面标识着这个 "),_("code",[e._v("commit point")]),e._v(" 对应的所有 "),_("code",[e._v("segment file")]),e._v("，同时强行将 "),_("code",[e._v("os cache")]),e._v(" 中目前所有的数据都 "),_("code",[e._v("fsync")]),e._v(" 到磁盘文件中去。最后"),_("strong",[e._v("清空")]),e._v(" 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。")]),e._v(" "),_("p",[e._v("这个 commit 操作叫做 "),_("code",[e._v("flush")]),e._v("。默认 30 分钟自动执行一次 "),_("code",[e._v("flush")]),e._v("，但如果 translog 过大，也会触发 "),_("code",[e._v("flush")]),e._v("。flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。")]),e._v(" "),_("p",[e._v("translog 日志文件的作用是什么？你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 "),_("code",[e._v("translog")]),e._v(" 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。")]),e._v(" "),_("p",[e._v("translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会"),_("strong",[e._v("丢失")]),e._v(" 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接 "),_("code",[e._v("fsync")]),e._v(" 到磁盘，但是性能会差很多。")]),e._v(" "),_("p",[e._v("实际上你在这里，如果面试官没有问你 es 丢数据的问题，你可以在这里给面试官炫一把，你说，其实 es 第一是准实时的，数据写入 1 秒后可以搜索到；可能会丢失数据的。有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果宕机，会导致 5 秒的"),_("strong",[e._v("数据丢失")]),e._v("。")]),e._v(" "),_("p",[_("strong",[e._v("总结一下")]),e._v("，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。")]),e._v(" "),_("blockquote",[_("p",[e._v("数据写入 segment file 之后，同时就建立好了倒排索引。")])]),e._v(" "),_("h3",{attrs:{id:"删除-更新数据底层原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#删除-更新数据底层原理"}},[e._v("#")]),e._v(" 删除/更新数据底层原理")]),e._v(" "),_("p",[e._v("如果是删除操作，commit 的时候会生成一个 "),_("code",[e._v(".del")]),e._v(" 文件，里面将某个 doc 标识为 "),_("code",[e._v("deleted")]),e._v(" 状态，那么搜索的时候根据 "),_("code",[e._v(".del")]),e._v(" 文件就知道这个 doc 是否被删除了。")]),e._v(" "),_("p",[e._v("如果是更新操作，就是将原来的 doc 标识为 "),_("code",[e._v("deleted")]),e._v(" 状态，然后新写入一条数据。")]),e._v(" "),_("p",[e._v("buffer 每 refresh 一次，就会产生一个 "),_("code",[e._v("segment file")]),e._v("，所以默认情况下是 1 秒钟一个 "),_("code",[e._v("segment file")]),e._v("，这样下来 "),_("code",[e._v("segment file")]),e._v(" 会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 "),_("code",[e._v("segment file")]),e._v(" 合并成一个，同时这里会将标识为 "),_("code",[e._v("deleted")]),e._v(" 的 doc 给"),_("strong",[e._v("物理删除掉")]),e._v("，然后将新的 "),_("code",[e._v("segment file")]),e._v(" 写入磁盘，这里会写一个 "),_("code",[e._v("commit point")]),e._v("，标识所有新的 "),_("code",[e._v("segment file")]),e._v("，然后打开 "),_("code",[e._v("segment file")]),e._v(" 供搜索使用，同时删除旧的 "),_("code",[e._v("segment file")]),e._v("。")])])}),[],!1,null,null,null);v.default=o.exports}}]);