(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{442:function(e,s,a){"use strict";a.r(s);var t=a(13),r=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("原文地址：")]),e._v(" "),a("p",[e._v("https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-master-slave.md")]),e._v(" "),a("h1",{attrs:{id:"redis-主从架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-主从架构"}},[e._v("#")]),e._v(" Redis 主从架构")]),e._v(" "),a("p",[e._v("单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑"),a("strong",[e._v("读高并发")]),e._v("的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的"),a("strong",[e._v("读请求全部走从节点")]),e._v("。这样也可以很轻松实现水平扩容，"),a("strong",[e._v("支撑读高并发")]),e._v("。")]),e._v(" "),a("p",[a("img",{attrs:{src:"/images/redis-master-slave.png",alt:"redis-master-slave"}})]),e._v(" "),a("p",[e._v("redis replication -> 主从架构 -> 读写分离 -> 水平扩容支撑读高并发")]),e._v(" "),a("h2",{attrs:{id:"redis-replication-的核心机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-replication-的核心机制"}},[e._v("#")]),e._v(" redis replication 的核心机制")]),e._v(" "),a("ul",[a("li",[e._v("redis 采用"),a("strong",[e._v("异步方式")]),e._v("复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；")]),e._v(" "),a("li",[e._v("一个 master node 是可以配置多个 slave node 的；")]),e._v(" "),a("li",[e._v("slave node 也可以连接其他的 slave node；")]),e._v(" "),a("li",[e._v("slave node 做复制的时候，不会 block master node 的正常工作；")]),e._v(" "),a("li",[e._v("slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；")]),e._v(" "),a("li",[e._v("slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。")])]),e._v(" "),a("p",[e._v("注意，如果采用了主从架构，那么建议必须"),a("strong",[e._v("开启")]),e._v(" master node 的"),a("RouterLink",{attrs:{to:"/docs/high-concurrency/redis-persistence.html"}},[e._v("持久化")]),e._v("，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。")],1),e._v(" "),a("p",[e._v("另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能"),a("strong",[e._v("确保启动的时候，是有数据的")]),e._v("，即使采用了后续讲解的"),a("RouterLink",{attrs:{to:"/docs/high-concurrency/redis-sentinel.html"}},[e._v("高可用机制")]),e._v("，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。")],1),e._v(" "),a("h2",{attrs:{id:"redis-主从复制的核心原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-主从复制的核心原理"}},[e._v("#")]),e._v(" redis 主从复制的核心原理")]),e._v(" "),a("p",[e._v("当启动一个 slave node 的时候，它会发送一个 "),a("code",[e._v("PSYNC")]),e._v(" 命令给 master node。")]),e._v(" "),a("p",[e._v("如果这是 slave node 初次连接到 master node，那么会触发一次 "),a("code",[e._v("full resynchronization")]),e._v(" 全量复制。此时 master 会启动一个后台线程，开始生成一份 "),a("code",[e._v("RDB")]),e._v(" 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。"),a("code",[e._v("RDB")]),e._v(" 文件生成完毕后， master 会将这个 "),a("code",[e._v("RDB")]),e._v(" 发送给 slave，slave 会先"),a("strong",[e._v("写入本地磁盘，然后再从本地磁盘加载到内存")]),e._v("中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。")]),e._v(" "),a("p",[a("img",{attrs:{src:"/images/redis-master-slave-replication.png",alt:"redis-master-slave-replication"}})]),e._v(" "),a("h3",{attrs:{id:"主从复制的断点续传"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主从复制的断点续传"}},[e._v("#")]),e._v(" 主从复制的断点续传")]),e._v(" "),a("p",[e._v("从 redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。")]),e._v(" "),a("p",[e._v("master node 会在内存中维护一个 backlog，master 和 slave 都会保存一个 replica offset 还有一个 master run id，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 replica offset 开始继续复制，如果没有找到对应的 offset，那么就会执行一次 "),a("code",[e._v("resynchronization")]),e._v("。")]),e._v(" "),a("blockquote",[a("p",[e._v("如果根据 host+ip 定位 master node，是不靠谱的，如果 master node 重启或者数据出现了变化，那么 slave node 应该根据不同的 run id 区分。")])]),e._v(" "),a("h3",{attrs:{id:"无磁盘化复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#无磁盘化复制"}},[e._v("#")]),e._v(" 无磁盘化复制")]),e._v(" "),a("p",[e._v("master 在内存中直接创建 "),a("code",[e._v("RDB")]),e._v("，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 "),a("code",[e._v("repl-diskless-sync yes")]),e._v(" 即可。")]),e._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("repl-diskless-sync "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("yes")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来")]),e._v("\nrepl-diskless-sync-delay "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("5")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("h3",{attrs:{id:"过期-key-处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#过期-key-处理"}},[e._v("#")]),e._v(" 过期 key 处理")]),e._v(" "),a("p",[e._v("slave 不会过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。")]),e._v(" "),a("h2",{attrs:{id:"复制的完整流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复制的完整流程"}},[e._v("#")]),e._v(" 复制的完整流程")]),e._v(" "),a("p",[e._v("slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的"),a("code",[e._v("host")]),e._v("和"),a("code",[e._v("ip")]),e._v("，但是复制流程没开始。")]),e._v(" "),a("p",[e._v("slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后 slave node 发送 "),a("code",[e._v("ping")]),e._v(" 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node "),a("strong",[e._v("第一次执行全量复制")]),e._v("，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node。")]),e._v(" "),a("p",[a("img",{attrs:{src:"/images/redis-master-slave-replication-detail.png",alt:"redis-master-slave-replication-detail"}})]),e._v(" "),a("h3",{attrs:{id:"全量复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全量复制"}},[e._v("#")]),e._v(" 全量复制")]),e._v(" "),a("ul",[a("li",[e._v("master 执行 bgsave ，在本地生成一份 rdb 快照文件。")]),e._v(" "),a("li",[e._v("master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)")]),e._v(" "),a("li",[e._v("master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。")]),e._v(" "),a("li",[e._v("如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。")])]),e._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("client-output-buffer-limit slave 256MB 64MB "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("60")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("ul",[a("li",[e._v("slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中，同时"),a("strong",[e._v("基于旧的数据版本")]),e._v("对外提供服务。")]),e._v(" "),a("li",[e._v("如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF。")])]),e._v(" "),a("h3",{attrs:{id:"增量复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#增量复制"}},[e._v("#")]),e._v(" 增量复制")]),e._v(" "),a("ul",[a("li",[e._v("如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。")]),e._v(" "),a("li",[e._v("master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB。")]),e._v(" "),a("li",[e._v("master 就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的。")])]),e._v(" "),a("h3",{attrs:{id:"heartbeat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#heartbeat"}},[e._v("#")]),e._v(" heartbeat")]),e._v(" "),a("p",[e._v("主从节点互相都会发送 heartbeat 信息。")]),e._v(" "),a("p",[e._v("master 默认每隔 10秒 发送一次 heartbeat，slave node 每隔 1秒 发送一个 heartbeat。")]),e._v(" "),a("h3",{attrs:{id:"异步复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步复制"}},[e._v("#")]),e._v(" 异步复制")]),e._v(" "),a("p",[e._v("master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slave node。")]),e._v(" "),a("h2",{attrs:{id:"redis-如何才能做到高可用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-如何才能做到高可用"}},[e._v("#")]),e._v(" redis 如何才能做到高可用")]),e._v(" "),a("p",[e._v("如果系统在 365 天内，有 99.99% 的时间，都是可以哗哗对外提供服务的，那么就说系统是高可用的。")]),e._v(" "),a("p",[e._v("一个 slave 挂掉了，是不会影响可用性的，还有其它的 slave 在提供相同数据下的相同的对外的查询服务。")]),e._v(" "),a("p",[e._v("但是，如果 master node 死掉了，会怎么样？没法写数据了，写缓存的时候，全部失效了。slave node 还有什么用呢，没有 master 给它们复制数据了，系统相当于不可用了。")]),e._v(" "),a("p",[e._v("redis 的高可用架构，叫做 "),a("code",[e._v("failover")]),e._v(" "),a("strong",[e._v("故障转移")]),e._v("，也可以叫做主备切换。")]),e._v(" "),a("p",[e._v("master node 在故障时，自动检测，并且将某个 slave node 自动切换为 master node 的过程，叫做主备切换。这个过程，实现了 redis 的主从架构下的高可用。")]),e._v(" "),a("p",[e._v("后面会详细说明 redis "),a("RouterLink",{attrs:{to:"/docs/high-concurrency/redis-sentinel.html"}},[e._v("基于哨兵的高可用性")]),e._v("。")],1)])}),[],!1,null,null,null);s.default=r.exports}}]);