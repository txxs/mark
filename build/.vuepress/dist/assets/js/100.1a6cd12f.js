(window.webpackJsonp=window.webpackJsonp||[]).push([[100],{486:function(v,_,t){"use strict";t.r(_);var e=t(13),p=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("原文地址：")]),v._v(" "),t("p",[v._v("https://blog.csdn.net/y4x5M0nivSrJaY3X92c/article/details/89325158")]),v._v(" "),t("p",[v._v("https://www.go2live.cn/nocate/%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%9C%9F%E5%AE%9E%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F-id-%E6%A1%88%E4%BE%8B%E7%9C%8B%E5%A6%82%E4%BD%95%E5%81%9A%E6%9E%B6%E6%9E%84.html")]),v._v(" "),t("p",[v._v("对于系统中的一组数据而言，必不可少地对应有唯一标识。简单的单体应用可以使用数据库的自增 ID 作为唯一标识。而在复杂的分布式系统中，就需要一些特定的策略去生成对应的分布式 ID。")]),v._v(" "),t("p",[v._v("常见的项目中 ID 会有以下两个特点：")]),v._v(" "),t("p",[v._v("1、全局唯一性。")]),v._v(" "),t("p",[v._v("2、趋势递增（对于使用 MySQL 的项目而言）。")]),v._v(" "),t("p",[v._v("因为一般 ID 会作为数据库的主键存储，而在 MySQL InnoDB 中使用的是聚簇索引，使用有序的 ID 可以保证写入性能。一般在分布式系统中，会有一个单独的服务来生成 ID。而这个服务则需要保证高可用性、高QPS 与安全性。另外生成的 ID 是不应该对外暴露的，如果非要对外展示，最好是无规则、不规律的编码。如果不依赖机器什么的话，而是依赖第三方，比如mysql,zk，或者redis就必须要保证高可用，或者做好降级策略")]),v._v(" "),t("h3",{attrs:{id:"uuid-机器的网卡-当前时间-一个随机数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#uuid-机器的网卡-当前时间-一个随机数"}},[v._v("#")]),v._v(" UUID（机器的网卡+当前时间+一个随机数）")]),v._v(" "),t("p",[v._v("UUID (Universally Unique Identifier) 生成的是一个长度为 32 的 16 进制格式的字符串。UUID 有多个版本，各版本算法不同。但核心思想是一致的，基本上都是结合机器的网卡、当前时间、一个随机数来生成特定长度的字符串。")]),v._v(" "),t("p",[v._v("优点：性能好、高可扩展性：本地生成，无网络消耗，不需要考虑性能瓶颈。")]),v._v(" "),t("p",[v._v("缺点：")]),v._v(" "),t("p",[v._v("1、无法保证趋势递增。")]),v._v(" "),t("p",[v._v("2、UUID 过长，如果需要在数据库存储，作为主键建立索引效率低。")]),v._v(" "),t("p",[v._v("适用场景：不需要考虑空间占用，不需要生成有递增趋势，且不在 MySQL 中存储。")]),v._v(" "),t("h3",{attrs:{id:"数据库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库"}},[v._v("#")]),v._v(" 数据库")]),v._v(" "),t("p",[v._v("结合数据库维护一个Sequence表，每当需要为某个表的新纪录生成ID时就从Sequence表中取出对应的nextid,将其+1后更新到数据库中以备下次使用。\n由于所有的插入都要访问该表，很容易造成性能瓶颈，且存在单点问题，如果该表所在的数据库失效，全部应用无法工作。\n在高并发场景下，无法保证高性能。")]),v._v(" "),t("h3",{attrs:{id:"snowflake"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#snowflake"}},[v._v("#")]),v._v(" Snowflake")]),v._v(" "),t("p",[v._v("snowflake 是 Twitter 开源的一个 ID 生成算法。")]),v._v(" "),t("p",[v._v("1、首位符号位：因为 ID 一般为正数，该值为 0。")]),v._v(" "),t("p",[v._v("2、41 位时间戳（毫秒级）：")]),v._v(" "),t("p",[v._v("3、时间戳不是当前时间的时间戳，而是存储时间戳的差值（当前时间戳 - 起始时间戳（起始时间戳需要程序指定））理论上可以最多使用 (1 << 41) / (1000x60x60x24x365) = 69年。")]),v._v(" "),t("p",[v._v("4、10 位数据机器位：包括 5 位数据标识位和 5 位机器标识位，也就是说最多可以部署节点数为：1 << 10 = 1024。")]),v._v(" "),t("p",[v._v("5、12 位毫秒内的序列：同一节点、同一时刻最多生成 ID 数 1 << 12 = 4096。")]),v._v(" "),t("p",[v._v("6、最后生成结果为 64 位 Long 型数值。")]),v._v(" "),t("p",[v._v("优点：")]),v._v(" "),t("p",[v._v("1、趋势递增，且按照时间有序。")]),v._v(" "),t("p",[v._v("2、性能高、稳定性高、不依赖数据库等第三方系统。")]),v._v(" "),t("p",[v._v("3、可以按照自身业务特性灵活分配 bit 位。")]),v._v(" "),t("p",[v._v("缺点：依赖于机器时钟，时钟回拨会造成暂不可用或重复发号。")]),v._v(" "),t("h3",{attrs:{id:"实战方案选型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实战方案选型"}},[v._v("#")]),v._v(" 实战方案选型")]),v._v(" "),t("p",[v._v("对于分布式下的全局ID需要具备如下特点：")]),v._v(" "),t("p",[v._v("1、全局唯一，区别于单机唯一，需要保证集群中的每台机器生成的ID都是不一样的，不能存在重复")]),v._v(" "),t("p",[v._v("2、顺序性，生成的全局ID，需要能够有序递增")]),v._v(" "),t("p",[v._v("3、区间约束：生成的全局ID需要满足业务规则，如：每家店每天生成的ID区间在1-999")]),v._v(" "),t("p",[v._v("4、性能要求：需要考虑门店数量较大情况下（如超过1万家）并发访问带来的性能问题")]),v._v(" "),t("p",[v._v("以上，完成业务架构梳理后，接下来需要看下如何实现，这就涉及到了技术架构。")]),v._v(" "),t("p",[v._v("1、使用数据库：自增主键")]),v._v(" "),t("p",[v._v("2、使用Redis实现：incr命令")]),v._v(" "),t("p",[v._v("3、使用zookeeper实现：有序节点")]),v._v(" "),t("p",[v._v("4、使用mongoDB实现：ObjectId")]),v._v(" "),t("p",[v._v("5、使用业界流行的开源框架实现")]),v._v(" "),t("p",[v._v("Twitter开源的Snowflake方案")]),v._v(" "),t("p",[v._v("微信的seqsvr")]),v._v(" "),t("p",[v._v("百度的UidGenerator")]),v._v(" "),t("p",[v._v("美团的Leaf")])])}),[],!1,null,null,null);_.default=p.exports}}]);