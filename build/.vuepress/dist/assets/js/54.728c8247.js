(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{430:function(a,s,t){"use strict";t.r(s);var _=t(13),e=Object(_.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h3",{attrs:{id:"为什么用索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么用索引"}},[a._v("#")]),a._v(" 为什么用索引")]),a._v(" "),t("p",[a._v("30W数据\nSELECT * FROM employees WHERE first_name='Zhonghui';\nfirst_name字段：\n不加索引： 0.115s\n加索引: 0.01s\n效率提高10倍")]),a._v(" "),t("p",[a._v("explain SELECT * FROM employees WHERE first_name='Zhonghui';")]),a._v(" "),t("p",[a._v("加索引查询232行，\n不加索引查询近30W行")]),a._v(" "),t("p",[a._v("通过explain可以查看")]),a._v(" "),t("h3",{attrs:{id:"索引的优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#索引的优势"}},[a._v("#")]),a._v(" 索引的优势：")]),a._v(" "),t("p",[a._v("(1)能够提高数据检索的效率，降低数据库I/O的成本")]),a._v(" "),t("p",[a._v("(2)能够提高排序检索的性能")]),a._v(" "),t("p",[a._v("(3)能够提高分组检索的性能")]),a._v(" "),t("h3",{attrs:{id:"索引的劣势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#索引的劣势"}},[a._v("#")]),a._v(" 索引的劣势：")]),a._v(" "),t("p",[a._v("(1)增加了硬盘的空间消耗")]),a._v(" "),t("p",[a._v("(2)增加增删改带来的I/O量")]),a._v(" "),t("h3",{attrs:{id:"适合创建索引的条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#适合创建索引的条件"}},[a._v("#")]),a._v(" 适合创建索引的条件：")]),a._v(" "),t("p",[a._v("(1)为较为频繁的查询条件字段创建索引，出现在WHERE字句中")]),a._v(" "),t("p",[a._v("(2)创建的字段有较强的唯一性")]),a._v(" "),t("p",[a._v("(3)创建的字段不能频繁的更新")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("SELECT \ncount(*) AS count \nFROM trade_bASe AS a\nWHERE \na.trade_status = 7 \nAND a.create_time BETWEEN '2015-09-01' AND '2016-01-14' \nAND a.booking_source = '2'\n\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br")])]),t("p",[a._v("根据这条SQL，应该建立的索引是：trade_status, booking_source,create_time的联合索引；其中，trade_status、booking_source的顺序可以颠倒，而且 create_time 的区间查询放到后面。这就是利用了索引的最左匹配原则。")]),a._v(" "),t("h3",{attrs:{id:"索引优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#索引优化"}},[a._v("#")]),a._v(" 索引优化：")]),a._v(" "),t("p",[a._v("1、聚簇索引的顺序就是数据的物理存储顺序，而对非聚簇索引的解释是:索引顺序与数据物理排列顺序无关。正式因为如此，所以一个表最多只能有一个聚簇索引。聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。聚簇索引主要用在Innodb存储引擎中。非聚簇索引主要用在MyISAM存储引擎中。非聚簇索引比聚簇索引多了一次读取数据的IO操作，所以查找性能上会差。https://www.cnblogs.com/crazylqy/p/7615457.html")]),a._v(" "),t("p",[a._v("2，索引不会包含有NULL值的列：只要列中包含有NULL值，都将不会被包含在索引中，组合索引中只要有一列有NULL值，那么这一列对于此条组合索引就是无效的。所以我们在数据库设计时，不要让索引字段的默认值为NULL。尽量避免NULL：应该指定列为NOT")]),a._v(" "),t("p",[a._v("3，使用短索引：假设，如果有一个数据类型为CHAR(255)的列，在前10个或20个字符内，绝大部分数据的值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省I/O操作。")]),a._v(" "),t("p",[a._v("4，索引列排序：MySQL查询只使用一个索引，因此如果WHERE子句中已经使用了索引的话，那么ORDER BY中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下，不要使用排序操作；尽量不要包含多个列的排序，如果需要，最好给这些列也创建组合索引。")]),a._v(" "),t("p",[a._v('5，LIKE语句操作：一般情况下，不建议使用LIKE操作；如果非使用不可，如何使用也是一个研究的课题。LIKE "%aaaaa%"不会使用索引，但是LIKE "aaa%"却可以使用索引。')]),a._v(" "),t("p",[a._v("6，不要在索引列上进行运算：在建立索引的原则中，提到了索引列不能进行运算，这里就不再赘述了。")]),a._v(" "),t("p",[a._v("7，尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。")]),a._v(" "),t("p",[a._v("8，尽量选择区分度高的列作为索引，区分度的公式是 COUNT(DISTINCT col) / COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度是0。可能有人会问，这个比率有什么经验么？使用场景不同，这个值也很难确定，一般需要JOIN的字段我们要求在0.1以上，即平均1条扫描10条记录。")]),a._v(" "),t("p",[a._v("9，最左前缀匹配原则。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询（>,<,BETWEEN,LIKE）就停止匹配，比如： a = 1 AND b = 2 AND c > 3 AND d = 4，如果建立 （a,b,c,d）顺序的索引，d是用不到索引的，如果建立（a,b,d,c）的索引，则都可以用到，a,b,d的顺序可以任意调整。")]),a._v(" "),t("p",[a._v("10，等于（=）和in 可以乱序。比如，a = 1 AND b = 2 AND c = 3 建立（a,b,c）索引可以任意顺序，MySQL的查询优化器会帮你优化成索引可以识别的模式。")]),a._v(" "),t("p",[a._v("11、越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快")]),a._v(" "),t("p",[a._v("12、简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址")])])}),[],!1,null,null,null);s.default=e.exports}}]);