(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{456:function(a,e,t){"use strict";t.r(e);var v=t(13),s=Object(v.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("原文地址：")]),a._v(" "),t("p",[a._v("https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-caching-avalanche-and-caching-penetration.md")]),a._v(" "),t("h2",{attrs:{id:"面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面试题"}},[a._v("#")]),a._v(" 面试题")]),a._v(" "),t("p",[a._v("了解什么是 redis 的雪崩、穿透和击穿？redis 崩溃之后会怎么样？系统该如何应对这种情况？如何处理 redis 的穿透？")]),a._v(" "),t("p",[t("strong",[a._v("这个其实是说了redis挂了之后怎么办，事前，事中，事后三种方案 ，记住别人问你的时候，其实他是一个缓存")])]),a._v(" "),t("h2",{attrs:{id:"面试官心理分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面试官心理分析"}},[a._v("#")]),a._v(" 面试官心理分析")]),a._v(" "),t("p",[a._v("其实这是问到缓存必问的，因为缓存雪崩和穿透，是缓存最大的两个问题，要么不出现，一旦出现就是致命性的问题，所以面试官一定会问你。")]),a._v(" "),t("h2",{attrs:{id:"面试题剖析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面试题剖析"}},[a._v("#")]),a._v(" 面试题剖析")]),a._v(" "),t("h3",{attrs:{id:"缓存雪崩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[a._v("#")]),a._v(" 缓存雪崩")]),a._v(" "),t("p",[a._v("对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。")]),a._v(" "),t("p",[a._v("这就是缓存雪崩。")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/redis-caching-avalanche.png",alt:"redis-caching-avalanche"}})]),a._v(" "),t("p",[a._v("大约在 3 年前，国内比较知名的一个互联网公司，曾因为缓存事故，导致雪崩，后台系统全部崩溃，事故从当天下午持续到晚上凌晨 3~4 点，公司损失了几千万。")]),a._v(" "),t("p",[a._v("缓存雪崩的事前事中事后的解决方案如下。")]),a._v(" "),t("ul",[t("li",[a._v("事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。")]),a._v(" "),t("li",[a._v("事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。")]),a._v(" "),t("li",[a._v("事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/redis-caching-avalanche-solution.png",alt:"redis-caching-avalanche-solution"}})]),a._v(" "),t("p",[a._v("用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 redis。如果 ehcache 和 redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 redis 中。")]),a._v(" "),t("p",[a._v("限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？"),t("strong",[a._v("走降级")]),a._v("！可以返回一些默认的值，或者友情提示，或者空白的值。")]),a._v(" "),t("p",[a._v("好处：")]),a._v(" "),t("ul",[t("li",[a._v("数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。")]),a._v(" "),t("li",[a._v("只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。")]),a._v(" "),t("li",[a._v("只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。")])]),a._v(" "),t("h3",{attrs:{id:"缓存穿透"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[a._v("#")]),a._v(" 缓存穿透")]),a._v(" "),t("p",[a._v("对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。")]),a._v(" "),t("p",[a._v("黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。")]),a._v(" "),t("p",[a._v("举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“"),t("strong",[a._v("视缓存于无物")]),a._v("”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/redis-caching-penetration.png",alt:"redis-caching-penetration"}})]),a._v(" "),t("p",[a._v("解决方式很简单，每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 "),t("code",[a._v("set -999 UNKNOWN")]),a._v("。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。")]),a._v(" "),t("h3",{attrs:{id:"缓存击穿"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[a._v("#")]),a._v(" 缓存击穿")]),a._v(" "),t("p",[a._v("缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。")]),a._v(" "),t("p",[a._v("解决方式也很简单，可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。")])])}),[],!1,null,null,null);e.default=s.exports}}]);