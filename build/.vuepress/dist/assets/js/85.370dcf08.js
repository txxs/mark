(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{465:function(t,i,l){"use strict";l.r(i);var s=l(13),v=Object(s.a)({},(function(){var t=this,i=t.$createElement,l=t._self._c||i;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h3",{attrs:{id:"实现思路"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#实现思路"}},[t._v("#")]),t._v(" 实现思路")]),t._v(" "),l("ul",[l("li",[t._v("RPC有两个使用方 一个是本地调用端 一个是远程实现端")]),t._v(" "),l("li",[t._v("调用端使用动态代理 代理我们需要远程调度的接口 实现忽略底层细节 像使用本地服务一样使用调用远程服务")]),t._v(" "),l("li",[t._v("将我们本地调用的接口方法信息(形参，方法名，返回类型等)通过网络发送至远程实现端")]),t._v(" "),l("li",[t._v("远程实现端接收到相应信息，反射调用对象的实现类")]),t._v(" "),l("li",[t._v("执行完实现类后把返回值发回给调用端")]),t._v(" "),l("li",[t._v("调用端接收到返回值，代理返回结果 远程调用完毕")])]),t._v(" "),l("h3",{attrs:{id:"另外一种总结"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#另外一种总结"}},[t._v("#")]),t._v(" 另外一种总结")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。这连接可以是HTTP方式的，也可以是TCP方式的。")])]),t._v(" "),l("li",[l("p",[t._v("第二，要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。比如基于Web服务协议栈的RPC，就要提供一个endpoint URI，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。")])]),t._v(" "),l("li",[l("p",[t._v("第三，当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给B服务器。")])]),t._v(" "),l("li",[l("p",[t._v("第四，B服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。")])]),t._v(" "),l("li",[l("p",[t._v("第五，返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用")])])]),t._v(" "),l("p",[l("img",{attrs:{src:"https://txxs.github.io/pic/tofuturedistirpc/1-1.png",alt:"1"}})])])}),[],!1,null,null,null);i.default=v.exports}}]);