<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Mark</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/mark/mlogo.svg">
    <link rel="manifest" href="/mark/manifest.json">
    <meta name="description" content="本博客主要是用来记录系统化的知识，内容部分来自github上的其他开源仓库，如有问题联系sdlyjhm01@sina.com">
    
    <link rel="preload" href="/mark/assets/css/0.styles.06a758ea.css" as="style"><link rel="preload" href="/mark/assets/js/app.92e1a2e3.js" as="script"><link rel="preload" href="/mark/assets/js/2.9796e7dc.js" as="script"><link rel="preload" href="/mark/assets/js/148.a4173523.js" as="script"><link rel="preload" href="/mark/assets/js/4.70c6b853.js" as="script"><link rel="prefetch" href="/mark/assets/js/10.fbb45a51.js"><link rel="prefetch" href="/mark/assets/js/100.027a096c.js"><link rel="prefetch" href="/mark/assets/js/101.f7067152.js"><link rel="prefetch" href="/mark/assets/js/102.024ad162.js"><link rel="prefetch" href="/mark/assets/js/103.5d056aae.js"><link rel="prefetch" href="/mark/assets/js/104.fa4d8cec.js"><link rel="prefetch" href="/mark/assets/js/105.17b344cf.js"><link rel="prefetch" href="/mark/assets/js/106.9bce0bab.js"><link rel="prefetch" href="/mark/assets/js/107.161ce549.js"><link rel="prefetch" href="/mark/assets/js/108.d9024072.js"><link rel="prefetch" href="/mark/assets/js/109.ee27b37e.js"><link rel="prefetch" href="/mark/assets/js/11.80b654ab.js"><link rel="prefetch" href="/mark/assets/js/110.a1830cac.js"><link rel="prefetch" href="/mark/assets/js/111.06885278.js"><link rel="prefetch" href="/mark/assets/js/112.ec48555e.js"><link rel="prefetch" href="/mark/assets/js/113.24635129.js"><link rel="prefetch" href="/mark/assets/js/114.8fc77473.js"><link rel="prefetch" href="/mark/assets/js/115.a39b0ea1.js"><link rel="prefetch" href="/mark/assets/js/116.b0cfd3ac.js"><link rel="prefetch" href="/mark/assets/js/117.0bff6f69.js"><link rel="prefetch" href="/mark/assets/js/118.d9a1678f.js"><link rel="prefetch" href="/mark/assets/js/119.360d7624.js"><link rel="prefetch" href="/mark/assets/js/12.6d0871a3.js"><link rel="prefetch" href="/mark/assets/js/120.0f07abc2.js"><link rel="prefetch" href="/mark/assets/js/121.25ef4688.js"><link rel="prefetch" href="/mark/assets/js/122.ab535412.js"><link rel="prefetch" href="/mark/assets/js/123.aff98816.js"><link rel="prefetch" href="/mark/assets/js/124.f8f14c50.js"><link rel="prefetch" href="/mark/assets/js/125.b1a78758.js"><link rel="prefetch" href="/mark/assets/js/126.8eb36919.js"><link rel="prefetch" href="/mark/assets/js/127.464c203d.js"><link rel="prefetch" href="/mark/assets/js/128.687c2e6e.js"><link rel="prefetch" href="/mark/assets/js/129.51e6ba47.js"><link rel="prefetch" href="/mark/assets/js/13.e3a73739.js"><link rel="prefetch" href="/mark/assets/js/130.c717debd.js"><link rel="prefetch" href="/mark/assets/js/131.a57c7484.js"><link rel="prefetch" href="/mark/assets/js/132.02d1a2d2.js"><link rel="prefetch" href="/mark/assets/js/133.ca253696.js"><link rel="prefetch" href="/mark/assets/js/134.2991f9c5.js"><link rel="prefetch" href="/mark/assets/js/135.8ef71a2a.js"><link rel="prefetch" href="/mark/assets/js/136.dc605919.js"><link rel="prefetch" href="/mark/assets/js/137.67730076.js"><link rel="prefetch" href="/mark/assets/js/138.d8c65801.js"><link rel="prefetch" href="/mark/assets/js/139.2f99ff7e.js"><link rel="prefetch" href="/mark/assets/js/14.1ed959f6.js"><link rel="prefetch" href="/mark/assets/js/140.3b645a3e.js"><link rel="prefetch" href="/mark/assets/js/141.6f8749be.js"><link rel="prefetch" href="/mark/assets/js/142.3d959e49.js"><link rel="prefetch" href="/mark/assets/js/143.5b78829e.js"><link rel="prefetch" href="/mark/assets/js/144.4c4816a2.js"><link rel="prefetch" href="/mark/assets/js/145.79841a51.js"><link rel="prefetch" href="/mark/assets/js/146.1fc2cd42.js"><link rel="prefetch" href="/mark/assets/js/147.6eb84780.js"><link rel="prefetch" href="/mark/assets/js/149.d74a2622.js"><link rel="prefetch" href="/mark/assets/js/15.c1038853.js"><link rel="prefetch" href="/mark/assets/js/150.58feda5b.js"><link rel="prefetch" href="/mark/assets/js/151.96c562cb.js"><link rel="prefetch" href="/mark/assets/js/152.35ddf89d.js"><link rel="prefetch" href="/mark/assets/js/153.b79e6a8b.js"><link rel="prefetch" href="/mark/assets/js/154.97779b76.js"><link rel="prefetch" href="/mark/assets/js/155.43cd2156.js"><link rel="prefetch" href="/mark/assets/js/156.236533c2.js"><link rel="prefetch" href="/mark/assets/js/157.d015e470.js"><link rel="prefetch" href="/mark/assets/js/158.0e1f8c13.js"><link rel="prefetch" href="/mark/assets/js/159.9de871d5.js"><link rel="prefetch" href="/mark/assets/js/16.f00c64fd.js"><link rel="prefetch" href="/mark/assets/js/160.83e77120.js"><link rel="prefetch" href="/mark/assets/js/161.78228eb1.js"><link rel="prefetch" href="/mark/assets/js/162.adce8a63.js"><link rel="prefetch" href="/mark/assets/js/163.b2d017d3.js"><link rel="prefetch" href="/mark/assets/js/164.69825b4d.js"><link rel="prefetch" href="/mark/assets/js/165.f554269d.js"><link rel="prefetch" href="/mark/assets/js/166.cceac3ee.js"><link rel="prefetch" href="/mark/assets/js/167.9f6db258.js"><link rel="prefetch" href="/mark/assets/js/168.424f4d8a.js"><link rel="prefetch" href="/mark/assets/js/169.11e13f73.js"><link rel="prefetch" href="/mark/assets/js/17.73b72526.js"><link rel="prefetch" href="/mark/assets/js/170.d67b1e26.js"><link rel="prefetch" href="/mark/assets/js/171.95caf8ff.js"><link rel="prefetch" href="/mark/assets/js/172.98326d74.js"><link rel="prefetch" href="/mark/assets/js/173.12208555.js"><link rel="prefetch" href="/mark/assets/js/174.e2e512d1.js"><link rel="prefetch" href="/mark/assets/js/175.5de95aae.js"><link rel="prefetch" href="/mark/assets/js/176.fd89c678.js"><link rel="prefetch" href="/mark/assets/js/177.e4018046.js"><link rel="prefetch" href="/mark/assets/js/178.837eaca8.js"><link rel="prefetch" href="/mark/assets/js/179.6533cab8.js"><link rel="prefetch" href="/mark/assets/js/18.853ba918.js"><link rel="prefetch" href="/mark/assets/js/180.add9c61e.js"><link rel="prefetch" href="/mark/assets/js/181.584ec0c3.js"><link rel="prefetch" href="/mark/assets/js/182.ab450f09.js"><link rel="prefetch" href="/mark/assets/js/183.e4c7f14b.js"><link rel="prefetch" href="/mark/assets/js/184.fb202665.js"><link rel="prefetch" href="/mark/assets/js/185.599a5ec7.js"><link rel="prefetch" href="/mark/assets/js/186.bc6afb47.js"><link rel="prefetch" href="/mark/assets/js/187.f4e863e4.js"><link rel="prefetch" href="/mark/assets/js/188.9807b51e.js"><link rel="prefetch" href="/mark/assets/js/189.b8753c71.js"><link rel="prefetch" href="/mark/assets/js/19.e9b1dcfd.js"><link rel="prefetch" href="/mark/assets/js/190.c37c0c58.js"><link rel="prefetch" href="/mark/assets/js/191.d658c007.js"><link rel="prefetch" href="/mark/assets/js/192.ec89e330.js"><link rel="prefetch" href="/mark/assets/js/193.5ec91a0f.js"><link rel="prefetch" href="/mark/assets/js/194.bcc3b6ac.js"><link rel="prefetch" href="/mark/assets/js/195.e7e89a8e.js"><link rel="prefetch" href="/mark/assets/js/196.9650acd0.js"><link rel="prefetch" href="/mark/assets/js/197.60ed2939.js"><link rel="prefetch" href="/mark/assets/js/198.9dcbad35.js"><link rel="prefetch" href="/mark/assets/js/199.e08acaf4.js"><link rel="prefetch" href="/mark/assets/js/20.4f331f61.js"><link rel="prefetch" href="/mark/assets/js/200.62d87394.js"><link rel="prefetch" href="/mark/assets/js/201.d4bde771.js"><link rel="prefetch" href="/mark/assets/js/202.1393910b.js"><link rel="prefetch" href="/mark/assets/js/203.cb278cbf.js"><link rel="prefetch" href="/mark/assets/js/204.0b19e441.js"><link rel="prefetch" href="/mark/assets/js/205.0f299615.js"><link rel="prefetch" href="/mark/assets/js/206.822078c6.js"><link rel="prefetch" href="/mark/assets/js/207.0b3c1c27.js"><link rel="prefetch" href="/mark/assets/js/208.cee4afc6.js"><link rel="prefetch" href="/mark/assets/js/209.9f987997.js"><link rel="prefetch" href="/mark/assets/js/21.c74f1424.js"><link rel="prefetch" href="/mark/assets/js/210.b912554e.js"><link rel="prefetch" href="/mark/assets/js/211.9d3e75a5.js"><link rel="prefetch" href="/mark/assets/js/212.71ebd5db.js"><link rel="prefetch" href="/mark/assets/js/213.9a4b3c07.js"><link rel="prefetch" href="/mark/assets/js/214.486d9eaa.js"><link rel="prefetch" href="/mark/assets/js/215.07f79be1.js"><link rel="prefetch" href="/mark/assets/js/216.90ee67e6.js"><link rel="prefetch" href="/mark/assets/js/217.a21585ca.js"><link rel="prefetch" href="/mark/assets/js/218.b35d663a.js"><link rel="prefetch" href="/mark/assets/js/219.4595de1c.js"><link rel="prefetch" href="/mark/assets/js/22.c1d496c9.js"><link rel="prefetch" href="/mark/assets/js/220.f29de7a1.js"><link rel="prefetch" href="/mark/assets/js/221.89b143f6.js"><link rel="prefetch" href="/mark/assets/js/222.cca213d4.js"><link rel="prefetch" href="/mark/assets/js/223.6146a6d7.js"><link rel="prefetch" href="/mark/assets/js/224.5ddd3952.js"><link rel="prefetch" href="/mark/assets/js/225.c131d933.js"><link rel="prefetch" href="/mark/assets/js/226.367e606b.js"><link rel="prefetch" href="/mark/assets/js/227.6e5da2f7.js"><link rel="prefetch" href="/mark/assets/js/228.11123405.js"><link rel="prefetch" href="/mark/assets/js/229.d8a0b5fa.js"><link rel="prefetch" href="/mark/assets/js/23.4333640f.js"><link rel="prefetch" href="/mark/assets/js/230.20010286.js"><link rel="prefetch" href="/mark/assets/js/231.481866c6.js"><link rel="prefetch" href="/mark/assets/js/232.7b2aa9dc.js"><link rel="prefetch" href="/mark/assets/js/233.abff58fe.js"><link rel="prefetch" href="/mark/assets/js/234.c5f9f58f.js"><link rel="prefetch" href="/mark/assets/js/235.67940be6.js"><link rel="prefetch" href="/mark/assets/js/236.2d8f374c.js"><link rel="prefetch" href="/mark/assets/js/237.8f5d87d5.js"><link rel="prefetch" href="/mark/assets/js/238.63b71a1d.js"><link rel="prefetch" href="/mark/assets/js/239.05c3b17a.js"><link rel="prefetch" href="/mark/assets/js/24.cbd56564.js"><link rel="prefetch" href="/mark/assets/js/240.87f0594c.js"><link rel="prefetch" href="/mark/assets/js/241.110e4bac.js"><link rel="prefetch" href="/mark/assets/js/242.35914afa.js"><link rel="prefetch" href="/mark/assets/js/243.59f4fc4d.js"><link rel="prefetch" href="/mark/assets/js/244.0b97267d.js"><link rel="prefetch" href="/mark/assets/js/245.53b73619.js"><link rel="prefetch" href="/mark/assets/js/246.828715ee.js"><link rel="prefetch" href="/mark/assets/js/247.3d23aaba.js"><link rel="prefetch" href="/mark/assets/js/248.bbd06a7d.js"><link rel="prefetch" href="/mark/assets/js/249.41aea4f1.js"><link rel="prefetch" href="/mark/assets/js/25.ac8322d1.js"><link rel="prefetch" href="/mark/assets/js/250.da82811d.js"><link rel="prefetch" href="/mark/assets/js/251.39562a60.js"><link rel="prefetch" href="/mark/assets/js/252.de0bf0bc.js"><link rel="prefetch" href="/mark/assets/js/253.5d547c29.js"><link rel="prefetch" href="/mark/assets/js/254.aea8fdae.js"><link rel="prefetch" href="/mark/assets/js/255.7c51ec31.js"><link rel="prefetch" href="/mark/assets/js/256.06fe17f9.js"><link rel="prefetch" href="/mark/assets/js/257.33c2ec09.js"><link rel="prefetch" href="/mark/assets/js/258.e58e44fa.js"><link rel="prefetch" href="/mark/assets/js/259.9571c018.js"><link rel="prefetch" href="/mark/assets/js/26.785db377.js"><link rel="prefetch" href="/mark/assets/js/260.86bee389.js"><link rel="prefetch" href="/mark/assets/js/261.11e74891.js"><link rel="prefetch" href="/mark/assets/js/262.a3886826.js"><link rel="prefetch" href="/mark/assets/js/263.edfe28ba.js"><link rel="prefetch" href="/mark/assets/js/264.392bdd96.js"><link rel="prefetch" href="/mark/assets/js/265.836530c0.js"><link rel="prefetch" href="/mark/assets/js/266.1c9900d2.js"><link rel="prefetch" href="/mark/assets/js/267.8dbb63c6.js"><link rel="prefetch" href="/mark/assets/js/268.d91309e2.js"><link rel="prefetch" href="/mark/assets/js/269.7ec3892f.js"><link rel="prefetch" href="/mark/assets/js/27.eb7e8ff0.js"><link rel="prefetch" href="/mark/assets/js/270.5c482c88.js"><link rel="prefetch" href="/mark/assets/js/271.39ff24be.js"><link rel="prefetch" href="/mark/assets/js/272.06bb9e48.js"><link rel="prefetch" href="/mark/assets/js/273.aa6a5d00.js"><link rel="prefetch" href="/mark/assets/js/274.5924dec3.js"><link rel="prefetch" href="/mark/assets/js/275.eaa6987b.js"><link rel="prefetch" href="/mark/assets/js/276.49237d44.js"><link rel="prefetch" href="/mark/assets/js/28.d637a557.js"><link rel="prefetch" href="/mark/assets/js/29.78f496e8.js"><link rel="prefetch" href="/mark/assets/js/3.d3cb6ecd.js"><link rel="prefetch" href="/mark/assets/js/30.04b98d4d.js"><link rel="prefetch" href="/mark/assets/js/31.98f1a2af.js"><link rel="prefetch" href="/mark/assets/js/32.0bc8f6d9.js"><link rel="prefetch" href="/mark/assets/js/33.fddffa17.js"><link rel="prefetch" href="/mark/assets/js/34.2e2cc112.js"><link rel="prefetch" href="/mark/assets/js/35.b5c65e52.js"><link rel="prefetch" href="/mark/assets/js/36.8156b993.js"><link rel="prefetch" href="/mark/assets/js/37.d4d6b147.js"><link rel="prefetch" href="/mark/assets/js/38.c9ea75bc.js"><link rel="prefetch" href="/mark/assets/js/39.41376eb5.js"><link rel="prefetch" href="/mark/assets/js/40.73d2d9e4.js"><link rel="prefetch" href="/mark/assets/js/41.f172bc1f.js"><link rel="prefetch" href="/mark/assets/js/42.b437e03b.js"><link rel="prefetch" href="/mark/assets/js/43.3cd3f1b3.js"><link rel="prefetch" href="/mark/assets/js/44.292881ee.js"><link rel="prefetch" href="/mark/assets/js/45.c1e3cae0.js"><link rel="prefetch" href="/mark/assets/js/46.fe779fca.js"><link rel="prefetch" href="/mark/assets/js/47.67fffb22.js"><link rel="prefetch" href="/mark/assets/js/48.c6c664aa.js"><link rel="prefetch" href="/mark/assets/js/49.50269c8a.js"><link rel="prefetch" href="/mark/assets/js/5.0b2d3a40.js"><link rel="prefetch" href="/mark/assets/js/50.b7c51e4d.js"><link rel="prefetch" href="/mark/assets/js/51.88fad818.js"><link rel="prefetch" href="/mark/assets/js/52.727c66c2.js"><link rel="prefetch" href="/mark/assets/js/53.38c41b64.js"><link rel="prefetch" href="/mark/assets/js/54.daeb58fa.js"><link rel="prefetch" href="/mark/assets/js/55.94bdad99.js"><link rel="prefetch" href="/mark/assets/js/56.ae880421.js"><link rel="prefetch" href="/mark/assets/js/57.994fbd52.js"><link rel="prefetch" href="/mark/assets/js/58.adaa2964.js"><link rel="prefetch" href="/mark/assets/js/59.e32e2057.js"><link rel="prefetch" href="/mark/assets/js/6.f05774e4.js"><link rel="prefetch" href="/mark/assets/js/60.43e99ed1.js"><link rel="prefetch" href="/mark/assets/js/61.f3edf3c6.js"><link rel="prefetch" href="/mark/assets/js/62.08cf95d5.js"><link rel="prefetch" href="/mark/assets/js/63.6810e631.js"><link rel="prefetch" href="/mark/assets/js/64.50593833.js"><link rel="prefetch" href="/mark/assets/js/65.9ab86a1d.js"><link rel="prefetch" href="/mark/assets/js/66.9efa2efa.js"><link rel="prefetch" href="/mark/assets/js/67.8c4b3654.js"><link rel="prefetch" href="/mark/assets/js/68.8000c397.js"><link rel="prefetch" href="/mark/assets/js/69.3247d5d4.js"><link rel="prefetch" href="/mark/assets/js/7.46392252.js"><link rel="prefetch" href="/mark/assets/js/70.618e85ff.js"><link rel="prefetch" href="/mark/assets/js/71.837fc208.js"><link rel="prefetch" href="/mark/assets/js/72.e86979bd.js"><link rel="prefetch" href="/mark/assets/js/73.a8765062.js"><link rel="prefetch" href="/mark/assets/js/74.a3e3ac23.js"><link rel="prefetch" href="/mark/assets/js/75.bb7c9557.js"><link rel="prefetch" href="/mark/assets/js/76.5a8de615.js"><link rel="prefetch" href="/mark/assets/js/77.1f0bb919.js"><link rel="prefetch" href="/mark/assets/js/78.9a1b66d5.js"><link rel="prefetch" href="/mark/assets/js/79.be0dfaec.js"><link rel="prefetch" href="/mark/assets/js/8.929c879f.js"><link rel="prefetch" href="/mark/assets/js/80.7ddf1bc8.js"><link rel="prefetch" href="/mark/assets/js/81.b7badbfb.js"><link rel="prefetch" href="/mark/assets/js/82.78e85969.js"><link rel="prefetch" href="/mark/assets/js/83.420d43cc.js"><link rel="prefetch" href="/mark/assets/js/84.35905cc9.js"><link rel="prefetch" href="/mark/assets/js/85.413f4f6a.js"><link rel="prefetch" href="/mark/assets/js/86.21e9aa54.js"><link rel="prefetch" href="/mark/assets/js/87.7162bc56.js"><link rel="prefetch" href="/mark/assets/js/88.43d86259.js"><link rel="prefetch" href="/mark/assets/js/89.d974497f.js"><link rel="prefetch" href="/mark/assets/js/9.9d4021a1.js"><link rel="prefetch" href="/mark/assets/js/90.70a6df38.js"><link rel="prefetch" href="/mark/assets/js/91.25bfb1d6.js"><link rel="prefetch" href="/mark/assets/js/92.9cdc3392.js"><link rel="prefetch" href="/mark/assets/js/93.b5812dcf.js"><link rel="prefetch" href="/mark/assets/js/94.00b0fe67.js"><link rel="prefetch" href="/mark/assets/js/95.544b0da2.js"><link rel="prefetch" href="/mark/assets/js/96.94832874.js"><link rel="prefetch" href="/mark/assets/js/97.ee169531.js"><link rel="prefetch" href="/mark/assets/js/98.04594ceb.js"><link rel="prefetch" href="/mark/assets/js/99.895610bf.js">
    <link rel="stylesheet" href="/mark/assets/css/0.styles.06a758ea.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mark/" class="home-link router-link-active"><img src="/mark/mlogo.svg" alt="Mark" class="logo"> <span class="site-name can-hide">Mark</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://txxs.github.io/record/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工程算法" class="dropdown-title"><span class="title">工程算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="工程算法" class="mobile-dropdown-title"><span class="title">工程算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/algo/" class="nav-link">
  个人总结
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="业务" class="dropdown-title"><span class="title">业务</span> <span class="arrow down"></span></button> <button type="button" aria-label="业务" class="mobile-dropdown-title"><span class="title">业务</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/buss/" class="nav-link">
  buss
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/db/es/" class="nav-link">
  ES
</a></li><li class="dropdown-item"><!----> <a href="/mark/db/mysql/" class="nav-link">
  Mysql
</a></li><li class="dropdown-item"><!----> <a href="/mark/db/redis/" class="nav-link">
  redis
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分布式" class="dropdown-title"><span class="title">分布式</span> <span class="arrow down"></span></button> <button type="button" aria-label="分布式" class="mobile-dropdown-title"><span class="title">分布式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/distri/the/" class="nav-link">
  理论
</a></li><li class="dropdown-item"><!----> <a href="/mark/distri/rpc/" class="nav-link">
  rpc
</a></li><li class="dropdown-item"><!----> <a href="/mark/distri/zk/" class="nav-link">
  zk
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="网络" class="dropdown-title"><span class="title">网络</span> <span class="arrow down"></span></button> <button type="button" aria-label="网络" class="mobile-dropdown-title"><span class="title">网络</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/internet/" class="nav-link">
  网络
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="问答" class="dropdown-title"><span class="title">问答</span> <span class="arrow down"></span></button> <button type="button" aria-label="问答" class="mobile-dropdown-title"><span class="title">问答</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/interview/" class="nav-link">
  问答
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="java" class="dropdown-title"><span class="title">java</span> <span class="arrow down"></span></button> <button type="button" aria-label="java" class="mobile-dropdown-title"><span class="title">java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/java/collection/" class="nav-link router-link-active">
  collection
</a></li><li class="dropdown-item"><!----> <a href="/mark/java/thread/" class="nav-link">
  thread
</a></li><li class="dropdown-item"><!----> <a href="/mark/java/io/" class="nav-link">
  io
</a></li><li class="dropdown-item"><!----> <a href="/mark/java/spring/" class="nav-link">
  spring
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="kafka" class="dropdown-title"><span class="title">kafka</span> <span class="arrow down"></span></button> <button type="button" aria-label="kafka" class="mobile-dropdown-title"><span class="title">kafka</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/kafka/" class="nav-link">
  kafka
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="q&amp;a" class="dropdown-title"><span class="title">q&amp;a</span> <span class="arrow down"></span></button> <button type="button" aria-label="q&amp;a" class="mobile-dropdown-title"><span class="title">q&amp;a</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/q&amp;a/interview/" class="nav-link">
  问答
</a></li><li class="dropdown-item"><!----> <a href="/mark/q&amp;a/self/" class="nav-link">
  自己
</a></li><li class="dropdown-item"><!----> <a href="/mark/q&amp;a/tuji/" class="nav-link">
  突击
</a></li><li class="dropdown-item"><!----> <a href="/mark/q&amp;a/key/" class="nav-link">
  key
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="总结" class="dropdown-title"><span class="title">总结</span> <span class="arrow down"></span></button> <button type="button" aria-label="总结" class="mobile-dropdown-title"><span class="title">总结</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/self/" class="nav-link">
  问答
</a></li></ul></div></div> <a href="https://github.com/txxs/mark" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://txxs.github.io/record/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工程算法" class="dropdown-title"><span class="title">工程算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="工程算法" class="mobile-dropdown-title"><span class="title">工程算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/algo/" class="nav-link">
  个人总结
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="业务" class="dropdown-title"><span class="title">业务</span> <span class="arrow down"></span></button> <button type="button" aria-label="业务" class="mobile-dropdown-title"><span class="title">业务</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/buss/" class="nav-link">
  buss
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/db/es/" class="nav-link">
  ES
</a></li><li class="dropdown-item"><!----> <a href="/mark/db/mysql/" class="nav-link">
  Mysql
</a></li><li class="dropdown-item"><!----> <a href="/mark/db/redis/" class="nav-link">
  redis
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分布式" class="dropdown-title"><span class="title">分布式</span> <span class="arrow down"></span></button> <button type="button" aria-label="分布式" class="mobile-dropdown-title"><span class="title">分布式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/distri/the/" class="nav-link">
  理论
</a></li><li class="dropdown-item"><!----> <a href="/mark/distri/rpc/" class="nav-link">
  rpc
</a></li><li class="dropdown-item"><!----> <a href="/mark/distri/zk/" class="nav-link">
  zk
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="网络" class="dropdown-title"><span class="title">网络</span> <span class="arrow down"></span></button> <button type="button" aria-label="网络" class="mobile-dropdown-title"><span class="title">网络</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/internet/" class="nav-link">
  网络
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="问答" class="dropdown-title"><span class="title">问答</span> <span class="arrow down"></span></button> <button type="button" aria-label="问答" class="mobile-dropdown-title"><span class="title">问答</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/interview/" class="nav-link">
  问答
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="java" class="dropdown-title"><span class="title">java</span> <span class="arrow down"></span></button> <button type="button" aria-label="java" class="mobile-dropdown-title"><span class="title">java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/java/collection/" class="nav-link router-link-active">
  collection
</a></li><li class="dropdown-item"><!----> <a href="/mark/java/thread/" class="nav-link">
  thread
</a></li><li class="dropdown-item"><!----> <a href="/mark/java/io/" class="nav-link">
  io
</a></li><li class="dropdown-item"><!----> <a href="/mark/java/spring/" class="nav-link">
  spring
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="kafka" class="dropdown-title"><span class="title">kafka</span> <span class="arrow down"></span></button> <button type="button" aria-label="kafka" class="mobile-dropdown-title"><span class="title">kafka</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/kafka/" class="nav-link">
  kafka
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="q&amp;a" class="dropdown-title"><span class="title">q&amp;a</span> <span class="arrow down"></span></button> <button type="button" aria-label="q&amp;a" class="mobile-dropdown-title"><span class="title">q&amp;a</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/q&amp;a/interview/" class="nav-link">
  问答
</a></li><li class="dropdown-item"><!----> <a href="/mark/q&amp;a/self/" class="nav-link">
  自己
</a></li><li class="dropdown-item"><!----> <a href="/mark/q&amp;a/tuji/" class="nav-link">
  突击
</a></li><li class="dropdown-item"><!----> <a href="/mark/q&amp;a/key/" class="nav-link">
  key
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="总结" class="dropdown-title"><span class="title">总结</span> <span class="arrow down"></span></button> <button type="button" aria-label="总结" class="mobile-dropdown-title"><span class="title">总结</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mark/self/" class="nav-link">
  问答
</a></li></ul></div></div> <a href="https://github.com/txxs/mark" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>工程算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mark/java/collection/ArrayList集合加入1万条数据.html" class="sidebar-link">ArrayList集合加入1万条数据，应该怎么提高效率</a></li><li><a href="/mark/java/collection/Arrays.asList获得的List使用时需要注意什么.html" class="sidebar-link">/java/collection/Arrays.asList获得的List使用时需要注意什么.html</a></li><li><a href="/mark/java/collection/bean作用域生命周期.html" class="sidebar-link">/java/collection/bean作用域生命周期.html</a></li><li><a href="/mark/java/collection/Comparable与Comparator的区别.html" class="sidebar-link">/java/collection/Comparable与Comparator的区别.html</a></li><li><a href="/mark/java/collection/CopyOnWriteArrayList原理.html" class="sidebar-link">我们还是先来回顾一下COW：</a></li><li><a href="/mark/java/collection/finally执行顺序.html" class="sidebar-link">/java/collection/finally执行顺序.html</a></li><li><a href="/mark/java/collection/hashmap原理.html" class="sidebar-link">/java/collection/hashmap原理.html</a></li><li><a href="/mark/java/collection/hashmap的死循环详解.html" class="sidebar-link">/java/collection/hashmap的死循环详解.html</a></li><li><a href="/mark/java/collection/Java集合框架更多细节.html" class="active sidebar-link">/java/collection/Java集合框架更多细节.html</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#集合框架图" class="sidebar-link">集合框架图</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#collection" class="sidebar-link">Collection</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#map" class="sidebar-link">Map</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#工具类" class="sidebar-link">工具类</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#通用实现" class="sidebar-link">通用实现</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#arraylist" class="sidebar-link">ArrayList</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_1-概览" class="sidebar-link">1. 概览</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_2-序列化" class="sidebar-link">2. 序列化</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_3-扩容" class="sidebar-link">3. 扩容</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_4-删除元素" class="sidebar-link">4. 删除元素</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_5-fail-fast" class="sidebar-link">5. Fail-Fast</a></li></ul></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#vector" class="sidebar-link">Vector</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_1-同步" class="sidebar-link">1. 同步</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_2-arraylist-与-vector" class="sidebar-link">2. ArrayList 与 Vector</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_3-vector-替代方案" class="sidebar-link">3. Vector 替代方案</a></li></ul></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#linkedlist" class="sidebar-link">LinkedList</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_1-概览-2" class="sidebar-link">1. 概览</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_2-add" class="sidebar-link">2. add()</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_3-remove" class="sidebar-link">3. remove()</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_4-get" class="sidebar-link">4. get()</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_5-总结" class="sidebar-link">5. 总结</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_6-arraylist-与-linkedlist" class="sidebar-link">6. ArrayList 与 LinkedList</a></li></ul></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#hashmap" class="sidebar-link">HashMap</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_1-存储结构" class="sidebar-link">1. 存储结构</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_2-重要参数" class="sidebar-link">2. 重要参数</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_3-确定哈希桶数组索引位置" class="sidebar-link">3. 确定哈希桶数组索引位置</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_4-分析hashmap的put方法" class="sidebar-link">4. 分析HashMap的put方法</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_5-扩容机制" class="sidebar-link">5. 扩容机制</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_6-线程安全性" class="sidebar-link">6. 线程安全性</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_7-jdk1-8与jdk1-7的性能对比" class="sidebar-link">7. JDK1.8与JDK1.7的性能对比</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_8-hash较均匀的情况" class="sidebar-link">8. Hash较均匀的情况</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_9-hash极不均匀的情况" class="sidebar-link">9. Hash极不均匀的情况</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_10-hashmap与hashtable" class="sidebar-link">10. HashMap与Hashtable</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_11-小结" class="sidebar-link">11. 小结</a></li></ul></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#concurrenthashmap" class="sidebar-link">ConcurrentHashMap</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_1-概述" class="sidebar-link">1. 概述</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_2-存储结构" class="sidebar-link">2. 存储结构</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_2-size-操作" class="sidebar-link">2. size 操作</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_3-同步方式" class="sidebar-link">3. 同步方式</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_4-jdk-1-8-的改动" class="sidebar-link">4. JDK 1.8 的改动</a></li></ul></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#hashset" class="sidebar-link">HashSet</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_1-成员变量" class="sidebar-link">1. 成员变量</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_2-构造函数" class="sidebar-link">2. 构造函数</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_3-add" class="sidebar-link">3. add()</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_4-总结" class="sidebar-link">4. 总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#linkedhashset-and-linkedhashmap" class="sidebar-link">LinkedHashSet and LinkedHashMap</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_1-概览-3" class="sidebar-link">1. 概览</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_2-get" class="sidebar-link">2. get()</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_3-put" class="sidebar-link">3. put()</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_4-remove" class="sidebar-link">4. remove()</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_5-linkedhashset" class="sidebar-link">5. LinkedHashSet</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_6-linkedhashmap经典用法" class="sidebar-link">6. LinkedHashMap经典用法</a></li></ul></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#迭代器模式" class="sidebar-link">迭代器模式</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#适配器模式" class="sidebar-link">适配器模式</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_1-arraylist和linkedlist区别" class="sidebar-link">1. ArrayList和LinkedList区别</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_2-hashmap和hashtable区别-hashmap的key类型" class="sidebar-link">2. HashMap和Hashtable区别，HashMap的key类型</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_3-hashmap和concurrenthashmap" class="sidebar-link">3. HashMap和ConcurrentHashMap</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_4-hashtable的原理" class="sidebar-link">4. Hashtable的原理</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_5-hash冲突的解决办法" class="sidebar-link">5. Hash冲突的解决办法</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_6-什么是迭代器" class="sidebar-link">6. 什么是迭代器</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_7-构造相同hash的字符串进行攻击-这种情况应该怎么处理-jdk7如何处理" class="sidebar-link">7. 构造相同hash的字符串进行攻击，这种情况应该怎么处理？JDK7如何处理</a></li><li class="sidebar-sub-header"><a href="/mark/java/collection/Java集合框架更多细节.html#_8-hashmap为什么大小是2的幂次" class="sidebar-link">8. HashMap为什么大小是2的幂次</a></li></ul></li><li><a href="/mark/java/collection/jdk5-10.html" class="sidebar-link">/java/collection/jdk5-10.html</a></li><li><a href="/mark/java/collection/RestControllerVSController.html" class="sidebar-link">/java/collection/RestControllerVSController.html</a></li><li><a href="/mark/java/collection/Set如何保证元素不重复.html" class="sidebar-link">/java/collection/Set如何保证元素不重复.html</a></li><li><a href="/mark/java/collection/springmvc.html" class="sidebar-link">先来看一下什么是 MVC 模式</a></li><li><a href="/mark/java/collection/spring中的设计模式.html" class="sidebar-link">/java/collection/spring中的设计模式.html</a></li><li><a href="/mark/java/collection/spring问题.html" class="sidebar-link">/java/collection/spring问题.html</a></li><li><a href="/mark/java/collection/动态代理两种方式及其区别.html" class="sidebar-link">/java/collection/动态代理两种方式及其区别.html</a></li><li><a href="/mark/java/collection/反射有什么作用.html" class="sidebar-link">/java/collection/反射有什么作用.html</a></li><li><a href="/mark/java/collection/异常原理分类.html" class="sidebar-link">/java/collection/异常原理分类.html</a></li><li><a href="/mark/java/collection/面向对象三大特征和5个原则.html" class="sidebar-link">/java/collection/面向对象三大特征和5个原则.html</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>原文地址：</p> <p>https://github.com/frank-lam/fullstack-tutorial/edit/master/notes/JavaArchitecture/02-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.md</p> <ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li> <li><a href="#%E4%B8%80%E6%A6%82%E8%BF%B0">一、概述</a> <ul><li><a href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE">集合框架图</a></li> <li><a href="#Collection">Collection</a></li> <li><a href="#Map">Map</a></li> <li><a href="#%E5%B7%A5%E5%85%B7%E7%B1%BB">工具类</a></li> <li><a href="#%E9%80%9A%E7%94%A8%E5%AE%9E%E7%8E%B0">通用实现</a></li></ul></li> <li><a href="#%E4%BA%8C%E6%B7%B1%E5%85%A5%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">二、深入源码分析</a> <ul><li><a href="#ArrayList">ArrayList</a> <ul><li><a href="#1-%E6%A6%82%E8%A7%88">1. 概览</a></li> <li><a href="#2-%E5%BA%8F%E5%88%97%E5%8C%96">2. 序列化</a></li> <li><a href="#3-%E6%89%A9%E5%AE%B9">3. 扩容</a></li> <li><a href="#4-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0">4. 删除元素</a></li> <li><a href="#5-Fail-Fast">5. Fail-Fast</a></li></ul></li> <li><a href="#Vector">Vector</a> <ul><li><a href="#1-%E5%90%8C%E6%AD%A5">1. 同步</a></li> <li><a href="#2-ArrayList-%E4%B8%8E-Vector">2. ArrayList 与 Vector</a></li> <li><a href="#3-Vector-%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88">3. Vector 替代方案</a> <ul><li><a href="#synchronizedList">synchronizedList</a></li> <li><a href="#CopyOnWriteArrayList">CopyOnWriteArrayList</a></li></ul></li></ul></li> <li><a href="#LinkedList">LinkedList</a> <ul><li><a href="#1-%E6%A6%82%E8%A7%88-1">1. 概览</a></li> <li><a href="#2-add">2. add()</a></li> <li><a href="#3-remove">3. remove()</a></li> <li><a href="#4-get">4. get()</a></li> <li><a href="#5-%E6%80%BB%E7%BB%93">5. 总结</a></li> <li><a href="#6-ArrayList-%E4%B8%8E-LinkedList">6. ArrayList 与 LinkedList</a></li></ul></li> <li><a href="#HashMap">HashMap</a> <ul><li><a href="#1-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">1. 存储结构</a> <ul><li><a href="#jdk17-%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">JDK1.7 的存储结构</a></li> <li><a href="#jdk18-%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">JDK1.8 的存储结构</a></li></ul></li> <li><a href="#2-%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0">2. 重要参数</a></li> <li><a href="#3-%E7%A1%AE%E5%AE%9A%E5%93%88%E5%B8%8C%E6%A1%B6%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E4%BD%8D%E7%BD%AE">3. 确定哈希桶数组索引位置</a></li> <li><a href="#4-%E5%88%86%E6%9E%90HashMap%E7%9A%84put%E6%96%B9%E6%B3%95">4. 分析HashMap的put方法</a></li> <li><a href="#5-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6">5. 扩容机制</a></li> <li><a href="#6-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7">6. 线程安全性</a></li> <li><a href="#7-jdk18%E4%B8%8Ejdk17%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94">7. JDK1.8与JDK1.7的性能对比</a></li> <li><a href="#8-hash%E8%BE%83%E5%9D%87%E5%8C%80%E7%9A%84%E6%83%85%E5%86%B5">8. Hash较均匀的情况</a></li> <li><a href="#9-hash%E6%9E%81%E4%B8%8D%E5%9D%87%E5%8C%80%E7%9A%84%E6%83%85%E5%86%B5">9. Hash极不均匀的情况</a></li> <li><a href="#10-HashMap%E4%B8%8EHashtable">10. HashMap与Hashtable</a></li> <li><a href="#11-%E5%B0%8F%E7%BB%93">11. 小结</a></li></ul></li> <li><a href="#ConcurrentHashMap">ConcurrentHashMap</a> <ul><li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li> <li><a href="#2-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">2. 存储结构</a></li> <li><a href="#2-size-%E6%93%8D%E4%BD%9C">2. size 操作</a></li> <li><a href="#3-%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F">3. 同步方式</a></li> <li><a href="#4-jdk-18-%E7%9A%84%E6%94%B9%E5%8A%A8">4. JDK 1.8 的改动</a></li></ul></li> <li><a href="#hashset">HashSet</a> <ul><li><a href="#1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">1. 成员变量</a></li> <li><a href="#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">2. 构造函数</a></li> <li><a href="#3-add">3. add()</a></li> <li><a href="#4-%E6%80%BB%E7%BB%93">4. 总结</a></li></ul></li> <li><a href="#LinkedHashSet-and-LinkedHashMap">LinkedHashSet and LinkedHashMap</a> <ul><li><a href="#1-%E6%A6%82%E8%A7%88-2">1. 概览</a></li> <li><a href="#2-get">2. get()</a></li> <li><a href="#3-put">3. put()</a></li> <li><a href="#4-remove">4. remove()</a></li> <li><a href="#5-LinkedHashSet">5. LinkedHashSet</a></li> <li><a href="#6-LinkedHashMap%E7%BB%8F%E5%85%B8%E7%94%A8%E6%B3%95">6. LinkedHashMap经典用法</a></li></ul></li></ul></li> <li><a href="#%E4%B8%89%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">三、容器中的设计模式</a> <ul><li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">迭代器模式</a></li> <li><a href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式</a></li></ul></li> <li><a href="#%E5%9B%9B%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97">四、面试指南</a> <ul><li><a href="#1-ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB">1. ArrayList和LinkedList区别</a></li> <li><a href="#2-HashMap%E5%92%8CHashtable%E5%8C%BA%E5%88%ABHashMap%E7%9A%84key%E7%B1%BB%E5%9E%8B">2. HashMap和Hashtable区别，HashMap的key类型</a></li> <li><a href="#3-HashMap%E5%92%8CConcurrentHashMap">3. HashMap和ConcurrentHashMap</a></li> <li><a href="#4-Hashtable%E7%9A%84%E5%8E%9F%E7%90%86">4. Hashtable的原理</a></li> <li><a href="#5-hash%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">5. Hash冲突的解决办法</a></li> <li><a href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8">6. 什么是迭代器</a></li> <li><a href="#7-%E6%9E%84%E9%80%A0%E7%9B%B8%E5%90%8Chash%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E6%94%BB%E5%87%BB%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86jdk7%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86">7. 构造相同hash的字符串进行攻击，这种情况应该怎么处理？JDK7如何处理</a></li> <li><a href="#8-HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%B0%8F%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AC%A1">8. HashMap为什么大小是2的幂次</a></li></ul></li> <li><a href="#%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97">更新日志</a></li></ul> <h1 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h1> <p>Java集合框架 (Java Collections Framework, JCF) 也称容器，这里可以类比 C++ 中的 STL，在市面上似乎还没能找到一本详细介绍的书籍。在这里主要对如下部分进行源码分析，及在面试中常见的问题。</p> <p>例如，在阿里面试常问到的 HashMap 和 ConcurrentHashMap 原理等等。深入源码分析是面试中必备的技能，通过本文的阅读会对集合框架有更深一步的了解。</p> <p>本文参考：</p> <ul><li><a href="https://github.com/CarpenterLee/JCFInternals" target="_blank" rel="noopener noreferrer">CarpenterLee/JCFInternals: 深入理解Java集合框架<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/crossoverJie/Java-Interview" target="_blank" rel="noopener noreferrer">crossoverJie/Java-Interview: 👨‍🎓 Java related : basic, concurrent, algorithm<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md" target="_blank" rel="noopener noreferrer">Interview-Notebook/Java 容器.md at master · CyC2018/Interview-Notebook<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h1 id="一、概述"><a href="#一、概述" class="header-anchor">#</a> 一、概述</h1> <p>Java集合框架提供了数据持有对象的方式，提供了对数据集合的操作。Java 集合框架位于 <code>java.util</code> 包下，主要有三个大类：<strong>Collection(接口)</strong>、<strong>Map(接口)</strong>、<strong>集合工具类</strong>。</p> <h2 id="集合框架图"><a href="#集合框架图" class="header-anchor">#</a> 集合框架图</h2> <div align="center"><img src="assets/1535785576589.png" width=""></div> <h2 id="collection"><a href="#collection" class="header-anchor">#</a> Collection</h2> <ul><li><code>ArrayList</code>：<strong>线程不同步</strong>。默认初始容量为 10，当数组大小不足时容量扩大为 1.5 倍。为追求效率，ArrayList 没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用 Vector 替代。</li> <li><code>LinkedList</code>：<strong>线程不同步</strong>。<strong>双向链接实现</strong>。LinkedList 同时实现了 List 接口和 Deque 接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（Queue），同时又可以看作一个栈（Stack）。这样看来，LinkedList 简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用 LinkedList，一方面是因为 Java 官方已经声明不建议使用 Stack 类，更遗憾的是，Java 里根本没有一个叫做 Queue 的类（它是个接口名字）。关于栈或队列，现在的首选是 ArrayDeque，它有着比 LinkedList（当作栈或队列使用时）有着更好的性能。</li> <li><code>Stack and Queue</code>：Java 里有一个叫做 Stack 的类，却没有叫做 Queue 的类（它是个接口名字）。当需要使用栈时，Java 已不推荐使用 Stack，而是推荐使用更高效的 ArrayDeque；既然 Queue 只是一个接口，当需要使用队列时也就首选 ArrayDeque 了（次选是 LinkedList ）。</li> <li><code>Vector</code>：<strong>线程同步</strong>。默认初始容量为 10，当数组大小不足时容量扩大为 2 倍。它的同步是通过 <code>Iterator</code> 方法加 <code>synchronized</code> 实现的。</li> <li><code>Stack</code>：<strong>线程同步</strong>。继承自 Vector，添加了几个方法来完成栈的功能。现在已经不推荐使用 Stack，在栈和队列中有限使用 ArrayDeque，其次是 LinkedList。</li> <li><code>TreeSet</code>：<strong>线程不同步</strong>，内部使用 <code>NavigableMap</code> 操作。默认元素 “自然顺序” 排列，可以通过 <code>Comparator</code> 改变排序。TreeSet 里面有一个 TreeMap（适配器模式）</li> <li><code>HashSet</code>：<strong>线程不同步</strong>，内部使用 HashMap 进行数据存储，提供的方法基本都是调用 HashMap 的方法，所以两者本质是一样的。集合元素可以为 NULL。</li> <li><code>Set</code>：Set 是一种不包含重复元素的 Collection，Set 最多只有一个 null 元素。Set 集合通常可以通过 Map 集合通过适配器模式得到。</li> <li><code>PriorityQueue</code>：Java 中 PriorityQueue 实现了 Queue 接口，不允许放入 null 元素；其通过堆实现，具体说是通过完全二叉树（complete binary tree）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为 PriorityQueue 的底层实现。
<ul><li><strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>（Java 的优先队列每次取最小元素，C++ 的优先队列每次取最大元素）。这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器</strong>（<em>Comparator</em>，类似于 C++ 的仿函数）。</li></ul></li> <li><code>NavigableSet</code>：添加了搜索功能，可以对给定元素进行搜索：小于、小于等于、大于、大于等于，放回一个符合条件的最接近给定元素的 key。</li> <li><code>EnumSet</code>：线程不同步。内部使用 Enum 数组实现，速度比 <code>HashSet</code> 快。<strong>只能存储在构造函数传入的枚举类的枚举值</strong>。</li></ul> <p>注释：更多设计模式，请转向 <a href="/mark/java/collection/06 设计模式.html">Java 设计模式</a></p> <h2 id="map"><a href="#map" class="header-anchor">#</a> Map</h2> <ul><li><code>TreeMap</code>：线程不同步，基于 <strong>红黑树</strong> （Red-Black tree）的 NavigableMap 实现，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。
<ul><li><strong>TreeMap 底层通过红黑树（Red-Black tree）实现</strong>，也就意味着 <code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code> 都有着 <code>log(n)</code> 的时间复杂度。其具体算法实现参照了《算法导论》。</li></ul></li> <li><code>Hashtable</code>：<strong>线程安全</strong>，HashMap 的迭代器 (Iterator) 是 <code>fail-fast</code> 迭代器。<strong>Hashtable 不能存储 NULL 的 key 和 value。</strong></li> <li><code>HashMap</code>：线程不同步。根据 <code>key</code> 的 <code>hashcode</code> 进行存储，内部使用静态内部类 <code>Node</code> 的数组进行存储，默认初始大小为 16，每次扩大一倍。当发生 Hash 冲突时，采用拉链法（链表）。JDK 1.8中：<strong>当单个桶中元素个数大于等于8时，链表实现改为红黑树实现；当元素个数小于6时，变回链表实现。由此来防止hashCode攻击。</strong> <ul><li>Java HashMap 采用的是冲突链表方式。</li> <li>HashMap 是 Hashtable 的轻量级实现，可以接受为 null 的键值 (key) 和值 (value)，而 Hashtable 不允许。</li></ul></li> <li><code>LinkedHashMap</code>：<strong>保存了记录的插入顺序</strong>，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的。也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比 HashMap 慢，不过有种情况例外，当 HashMap 容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap 慢，因为 LinkedHashMap 的遍历速度只和实际数据有关，和容量无关，而 HashMap 的遍历速度和他的容量有关。</li> <li><code>WeakHashMap</code>：从名字可以看出它是某种 Map。它的特殊之处在于 WeakHashMap 里的 entry 可能会被 GC 自动删除，即使程序员没有调用 <code>remove()</code> 或者 <code>clear()</code> 方法。 WeakHashMap 的存储结构类似于HashMap
<ul><li>既然有 WeekHashMap，是否有 WeekHashSet 呢？答案是没有！不过 Java Collections 工具类给出了解决方案，<code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code> 方法可以将任何 Map包装成一个Set。</li></ul></li></ul> <h2 id="工具类"><a href="#工具类" class="header-anchor">#</a> 工具类</h2> <ul><li><p><code>Collections</code>、<code>Arrays</code>：集合类的一个工具类帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p></li> <li><p><code>Comparable</code>、<code>Comparator</code>：一般是用于对象的比较来实现排序，两者略有区别。</p> <blockquote><ul><li>类设计者没有考虑到比较问题而没有实现 Comparable 接口。这是我们就可以通过使用 Comparator，这种情况下，我们是不需要改变对象的。</li> <li>一个集合中，我们可能需要有多重的排序标准，这时候如果使用 Comparable 就有些捉襟见肘了，可以自己继承 Comparator 提供多种标准的比较器进行排序。</li></ul></blockquote></li></ul> <p><strong>说明</strong>：线程不同步的时候可以通过，Collections.synchronizedList() 方法来包装一个线程同步方法</p> <h2 id="通用实现"><a href="#通用实现" class="header-anchor">#</a> 通用实现</h2> <table align="center"><tr><td colspan="2" rowspan="2" align="center" border="0"></td><th colspan="5" align="center">Implementations</th></tr><tr><th>Hash Table</th><th>Resizable Array</th><th>Balanced Tree</th><th>Linked List</th><th>Hash Table + Linked List</th></tr><tr><th rowspan="4">Interfaces</th><th>Set</th><td><tt>HashSet</tt></td><td></td><td><tt>TreeSet</tt></td><td></td><td><tt>LinkedHashSet</tt></td></tr><tr><th>List</th><td></td><td><tt>ArrayList</tt></td><td></td><td><tt>LinkedList</tt></td><td></td></tr><tr><th>Deque</th><td></td><td><tt>ArrayDeque</tt></td><td></td><td><tt>LinkedList</tt></td><td></td></tr><tr><th>Map</th><td><tt>HashMap</tt></td><td></td><td><tt>TreeMap</tt></td><td></td><td><tt>LinkedHashMap</tt></td></tr></table> <p><strong>参考资料：</strong></p> <ul><li><a href="https://github.com/CarpenterLee/JCFInternals" target="_blank" rel="noopener noreferrer">CarpenterLee/JCFInternals:深入理解Java集合框架<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.im/post/5af86ac8f265da0ba063410e" target="_blank" rel="noopener noreferrer">Java基础-集合框架 - 掘金<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h1 id="二、深入源码分析"><a href="#二、深入源码分析" class="header-anchor">#</a> 二、深入源码分析</h1> <p>源码分析基于 JDK 1.8 / JDK 1.7，在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。</p> <h2 id="arraylist"><a href="#arraylist" class="header-anchor">#</a> ArrayList</h2> <h3 id="_1-概览"><a href="#_1-概览" class="header-anchor">#</a> 1. 概览</h3> <p>实现了 RandomAccess 接口，因此支持随机访问，这是理所当然的，因为 ArrayList 是基于数组实现的。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>数组的默认大小为 10。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CAPACITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div align="center"><img src="assets/ArrayList_base.png" width="600"></div> <h3 id="_2-序列化"><a href="#_2-序列化" class="header-anchor">#</a> 2. 序列化</h3> <p>基于数组实现，保存元素的数组使用 transient 修饰，该关键字声明数组默认不会被序列化。ArrayList 具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。ArrayList 重写了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">transient</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span> <span class="token comment">// non-private to simplify nested class access</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_3-扩容"><a href="#_3-扩容" class="header-anchor">#</a> 3. 扩容</h3> <p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p> <p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// JDK 1.8</span>
    
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span>
    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 判断数组是否越界</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        minCapacity <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment">// overflow-conscious code</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 扩容</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// overflow-conscious code</span>
    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1.5倍</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// minCapacity is usually close to size, so this is a win:</span>
    elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&gt;</span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span> MAX_ARRAY_SIZE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><h3 id="_4-删除元素"><a href="#_4-删除元素" class="header-anchor">#</a> 4. 删除元素</h3> <p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>
    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// clear to let GC do its work</span>
    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_5-fail-fast"><a href="#_5-fail-fast" class="header-anchor">#</a> 5. Fail-Fast</h3> <p><strong>开始之前我们想讲讲，什么是 fail-fast 机制?</strong></p> <p>fail-fast 机制在遍历一个集合时，当集合结构被修改，会抛出 Concurrent Modification Exception。</p> <p>fail-fast 会在以下两种情况下抛出 Concurrent Modification Exception</p> <p>（1）单线程环境</p> <ul><li><p>集合被创建后，在遍历它的过程中修改了结构。</p></li> <li><p>注意 remove() 方法会让 expectModcount 和 modcount 相等，所以是不会抛出这个异常。</p></li></ul> <p>（2）多线程环境</p> <ul><li>当一个线程在遍历这个集合，而另一个线程对这个集合的结构进行了修改。</li></ul> <p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指<strong>添加</strong>或者<strong>删除</strong>至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p> <p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 Concurrent Modification Exception。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>ObjectOutputStream</span> s<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>IOException</span><span class="token punctuation">{</span>
    <span class="token comment">// Write out element count, and any hidden stuff</span>
    <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
    s<span class="token punctuation">.</span><span class="token function">defaultWriteObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Write out size as capacity for behavioural compatibility with clone()</span>
    s<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Write out all elements in the proper order.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        s<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="vector"><a href="#vector" class="header-anchor">#</a> Vector</h2> <h3 id="_1-同步"><a href="#_1-同步" class="header-anchor">#</a> 1. 同步</h3> <p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token function">ensureCapacityHelper</span><span class="token punctuation">(</span>elementCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    elementData<span class="token punctuation">[</span>elementCount<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> elementCount<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIndexOutOfBoundsException</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="_2-arraylist-与-vector"><a href="#_2-arraylist-与-vector" class="header-anchor">#</a> 2. ArrayList 与 Vector</h3> <ul><li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li> <li>Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。</li></ul> <h3 id="_3-vector-替代方案"><a href="#_3-vector-替代方案" class="header-anchor">#</a> 3. Vector 替代方案</h3> <h4 id="synchronizedlist"><a href="#synchronizedlist" class="header-anchor">#</a> synchronizedList</h4> <p>为了获得线程安全的 ArrayList，可以使用  <code>Collections.synchronizedList();</code>  得到一个线程安全的  ArrayList。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> synList <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="copyonwritearraylist"><a href="#copyonwritearraylist" class="header-anchor">#</a> CopyOnWriteArrayList</h4> <div align="center"><img src="assets/cow.png" width=""></div><br> <p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>CopyOnWrite 容器即写时复制的容器。通俗的理解是<strong>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器</strong>。这样做的好处是我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种<strong>读写分离</strong>的思想，读和写不同的容器。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">T</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">// 复制出新数组</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 把新元素添加到新数组里</span>
        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token comment">// 把原数组引用指向新数组</span>
        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setArray</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    array <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>读的时候不需要加锁，如果读的时候有多个线程正在向 ArrayList 添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的 ArrayList。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>CopyOnWrite的缺点</strong></p> <ul><li>CopyOnWrite 容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</li></ul> <p><strong>内存占用问题</strong>。</p> <ul><li><p>因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意：在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说 200M 左右，那么再写入 100M 数据进去，内存就会占用 300M，那么这个时候很有可能造成频繁的 Yong GC 和 Full GC。之前我们系统中使用了一个服务由于每晚使用 CopyOnWrite 机制更新大对象，造成了每晚 15 秒的 Full GC，应用响应时间也随之变长。</p></li> <li><p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是 10 进制的数字，可以考虑把它压缩成 36 进制或 64 进制。或者不使用 CopyOnWrite 容器，而使用其他的并发容器，如  ConcurrentHashMap 。</p></li></ul> <p><strong>数据一致性问题</strong>。</p> <ul><li><p>CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用 CopyOnWrite 容器。</p></li> <li><p>关于 C++ 的 STL 中，曾经也有过 Copy-On-Write 的玩法，参见陈皓的《<a href="http://blog.csdn.net/haoel/article/details/24058" target="_blank" rel="noopener noreferrer">C++ STL String类中的Copy-On-Write<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>》，后来，因为有很多线程安全上的事，就被去掉了。</p></li></ul> <p>参考资料：</p> <ul><li><a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="noopener noreferrer">聊聊并发-Java中的Copy-On-Write容器 | 并发编程网 – ifeve.com<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="linkedlist"><a href="#linkedlist" class="header-anchor">#</a> LinkedList</h2> <div align="center"><img src="assets/LinkedList_base.png" width="600"></div> <h3 id="_1-概览-2"><a href="#_1-概览-2" class="header-anchor">#</a> 1. 概览</h3> <p><strong>LinkedList 底层是基于双向链表实现的</strong>，也是实现了 List 接口，所以也拥有 List 的一些特点 (JDK1.7/8 之后取消了循环，修改为双向链表) 。</p> <p>LinkedList 同时实现了 List 接口和 Deque 接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（Queue），同时又可以看作一个栈（Stack）。这样看来， LinkedList 简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用 LinkedList ，一方面是因为 Java 官方已经声明不建议使用 Stack 类，更遗憾的是，Java里根本没有一个叫做 Queue 的类（它是个接口名字）。</p> <p>关于栈或队列，现在的首选是 ArrayDeque，它有着比 LinkedList （当作栈或队列使用时）有着更好的性能。</p> <p>基于双向链表实现，内部使用 Node 来存储链表节点信息。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">E</span> item<span class="token punctuation">;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>每个链表存储了 Head 和 Tail 指针：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">;</span>
<span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> last<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>LinkedList 的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率<em>LinkedList</em>没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用 <code>Collections.synchronizedList()</code> 方法对其进行包装。</p> <h3 id="_2-add"><a href="#_2-add" class="header-anchor">#</a> 2. add()</h3> <div align="center"><img src="assets/LinkedList_add.png" width="600"></div> <p>add() 方法有两个版本，一个是 <code>add(E e)</code>，该方法在 LinkedList 的末尾插入元素，因为有 last 指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是 <code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// JDK 1.8</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
* Links e as last element.
*/</span>
<span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    size<span class="token operator">++</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p><code>add(int index, E element)</code> 的逻辑稍显复杂，可以分成两部分</p> <ol><li><p>先根据 index 找到要插入的位置；</p></li> <li><p>修改引用，完成插入操作。</p></li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span>
        <span class="token function">linkLast</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">linkBefore</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>上面代码中的 <code>node(int index)</code> 函数有一点小小的 trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件 <code>index &lt; (size &gt;&gt; 1)</code>，也即是 index 是靠近前端还是后端。</p> <h3 id="_3-remove"><a href="#_3-remove" class="header-anchor">#</a> 3. remove()</h3> <p>remove() 方法也有两个版本，一个是删除跟指定元素相等的第一个元素 <code>remove(Object o)</code>，另一个是删除指定下标处的元素 <code>remove(int index)</code>。</p> <div align="center"><img src="assets/LinkedList_remove.png" width="600"></div> <p>两个删除操作都要：</p> <ol><li>先找到要删除元素的引用；</li> <li>修改相关引用，完成删除操作。</li></ol> <p>在寻找被删元素引用的时候 <code>remove(Object o)</code> 调用的是元素的 equals 方法，而 <code>remove(int index)</code> 使用的是下标计数，两种方式都是线性时间复杂度。在步骤 2 中，两个 <code>revome()</code> 方法都是通过 <code>unlink(Node&lt;E&gt; x)</code> 方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。</p> <h3 id="_4-get"><a href="#_4-get" class="header-anchor">#</a> 4. get()</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
    
<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// assert isElementIndex(index);</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
            x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>由此可以看出是使用二分查找来看 <code>index</code> 离 size 中间距离来判断是从头结点正序查还是从尾节点倒序查。</p> <ul><li>node() 会以 <code>O(n/2)</code> 的性能去获取一个结点
<ul><li>如果索引值大于链表大小的一半，那么将从尾结点开始遍历</li></ul></li></ul> <p>这样的效率是非常低的，特别是当 index 越接近 size 的中间值时。</p> <h3 id="_5-总结"><a href="#_5-总结" class="header-anchor">#</a> 5. 总结</h3> <ul><li>LinkedList 插入，删除都是移动指针效率很高。</li> <li>查找需要进行遍历查询，效率较低。</li></ul> <h3 id="_6-arraylist-与-linkedlist"><a href="#_6-arraylist-与-linkedlist" class="header-anchor">#</a> 6. ArrayList 与 LinkedList</h3> <ul><li>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；</li> <li>ArrayList 支持随机访问，LinkedList 不支持；</li> <li>LinkedList 在任意位置添加删除元素更快。</li></ul> <h2 id="hashmap"><a href="#hashmap" class="header-anchor">#</a> HashMap</h2> <p>我们这篇文章就来试着分析下 HashMap 的源码，由于 HashMap 底层涉及到太多方面，一篇文章总是不能面面俱到，所以我们可以带着面试官常问的几个问题去看源码：</p> <ol><li>了解底层如何存储数据的</li> <li>HashMap 的几个主要方法</li> <li>HashMap 是如何确定元素存储位置的以及如何处理哈希冲突的</li> <li>HashMap 扩容机制是怎样的</li> <li>JDK 1.8 在扩容和解决哈希冲突上对 HashMap 源码做了哪些改动？有什么好处?</li></ol> <p>HashMap 的内部功能实现很多，本文主要从根据 key 获取哈希桶数组索引位置、put 方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。</p> <h3 id="_1-存储结构"><a href="#_1-存储结构" class="header-anchor">#</a> 1. 存储结构</h3> <h4 id="jdk1-7-的存储结构"><a href="#jdk1-7-的存储结构" class="header-anchor">#</a> JDK1.7 的存储结构</h4> <p>在 1.7 之前 JDK 采用「拉链法」来存储数据，即数组和链表结合的方式：</p> <div align="center"><img src="assets/hashmap-link.jpg" width="550"></div> <p>「拉链法」用专业点的名词来说叫做<strong>链地址法</strong>。简单来说，就是数组加链表的结合。在每个数组元素上存储的都是一个链表。</p> <p>我们之前说到不同的 key 可能经过 hash 运算可能会得到相同的地址，但是一个数组单位上只能存放一个元素，采用链地址法以后，如果遇到相同的 hash 值的 key 的时候，我们可以将它放到作为数组元素的链表上。待我们去取元素的时候通过 hash 运算的结果找到这个链表，再在链表中找到与 key 相同的节点，就能找到 key 相应的值了。</p> <p>JDK1.7 中新添加进来的元素总是放在数组相应的角标位置，而原来处于该角标的位置的节点作为 next 节点放到新节点的后边。稍后通过源码分析我们也能看到这一点。</p> <h4 id="jdk1-8-的存储结构"><a href="#jdk1-8-的存储结构" class="header-anchor">#</a> JDK1.8 的存储结构</h4> <p>对于 JDK1.8 之后的 <code>HashMap</code> 底层在解决哈希冲突的时候，就不单单是使用数组加上单链表的组合了，因为当处理如果 hash 值冲突较多的情况下，链表的长度就会越来越长，此时通过单链表来寻找对应 Key 对应的 Value 的时候就会使得时间复杂度达到 O(n)，因此在 JDK1.8 之后，在链表新增节点导致链表长度超过 <code>TREEIFY_THRESHOLD = 8</code>  的时候，就会在添加元素的同时将原来的单链表转化为红黑树。</p> <p>对数据结构很在行的读者应该，知道红黑树是一种易于增删改查的二叉树，他对与数据的查询的时间复杂度是 <code>O(logn)</code> 级别，所以利用红黑树的特点就可以更高效的对 <code>HashMap</code> 中的元素进行操作。</p> <div align="center"><img src="assets/hashmap-rb-link.jpg" width="550"></div><br> <p>从结构实现来讲，HashMap 是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p> <div align="center"><img src="assets/hashMap-datastruct.png" width="400"></div> <p><strong>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？</strong></p> <p>（1）从源码可知，HashMap 类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个 Node 的数组。我们来看 Node（ JDK1.8 中） 是何物。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token comment">//用来定位数组索引位置</span>
    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>
    <span class="token class-name">V</span> value<span class="token punctuation">;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>   <span class="token comment">//链表的下一个node</span>

    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">V</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>Node 是 HashMap 的一个内部类，实现了 Map.Entry 接口，本质是就是一个映射（键值对）。上图中的每个黑色圆点就是一个Node对象。</p> <p>（2）HashMap 就是使用哈希表来存储的。哈希表为解决冲突，可以采用<strong>开放地址法</strong>和<strong>链地址法</strong>等来解决问题， Java 中 HashMap 采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被 Hash 后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;美团&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;小美&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>系统将调用 &quot;美团&quot; 这个 key 的 hashCode() 方法得到其 hashCode 值（该方法适用于每个 Java 对象），然后再通过 Hash 算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个 key 会定位到相同的位置，表示发生了 Hash 碰撞。当然 Hash 算法计算结果越分散均匀，Hash 碰撞的概率就越小，map 的存取效率就会越高。</p> <p>如果哈希桶数组很大，即使较差的 Hash 算法也会比较分散，如果哈希桶数组数组很小，即使好的 Hash 算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的 hash 算法减少 Hash 碰撞。</p> <p><strong>那么通过什么方式来控制 map 使得 Hash 碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？</strong></p> <p>答案就是好的 Hash 算法和扩容机制。</p> <p>在理解 Hash 和扩容流程之前，我们得先了解下 HashMap 的几个字段。从 HashMap 的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> threshold<span class="token punctuation">;</span>             <span class="token comment">// 所能容纳的key-value对极限 </span>
<span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>    <span class="token comment">// 负载因子</span>
<span class="token keyword">int</span> modCount<span class="token punctuation">;</span>  
<span class="token keyword">int</span> size<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>首先，<strong>Node[] table的初始化长度 length (默认值是16)</strong>，<strong>Load factor 为负载因子(默认值是0.75)</strong>，threshold 是 HashMap 所能容纳的最大数据量的 Node (键值对)个数。<strong>threshold = length * Load factor</strong>。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p> <p>结合负载因子的定义公式可知，threshold 就是在此 Load factor 和 length (数组长度)对应下允许的最大元素数目，超过这个数目就重新 resize(扩容)，扩容后的 HashMap 容量是之前容量的两倍。默认的负载因子 0.75 是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子 Load factor 的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子 loadFactor 的值，这个值可以大于1。</p> <p>size 这个字段其实很好理解，就是 HashMap 中实际存在的键值对数量。注意和 table 的长度 length、容纳最大键值对数量 threshold 的区别。而 modCount 字段主要用来记录 HashMap 内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如 put 新键值对，但是某个 key 对应的 value 值被覆盖不属于结构变化。</p> <p>在 HashMap 中，哈希桶数组 table 的长度 length 大小必须为 2<sup>n</sup>（一定是合数），这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考 <a href="https://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="noopener noreferrer">为什么一般hashtable的桶数会取一个素数？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，<strong>Hashtable 初始化桶大小为 11，就是桶大小设计为素数的应用（Hashtable 扩容后不能保证还是素数）</strong>。HashMap 采用这种非常规设计，<strong>主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap 定位哈希桶索引位置时，也加入了高位参与运算的过程</strong>。</p> <p>这里存在一个问题，即使负载因子和 Hash 算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。于是，在 JDK1.8 版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高 HashMap 的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考：<a href="https://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="noopener noreferrer">教你初步了解红黑树<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h3 id="_2-重要参数"><a href="#_2-重要参数" class="header-anchor">#</a> 2. 重要参数</h3> <table><thead><tr><th>参数</th> <th>说明</th></tr></thead> <tbody><tr><td>buckets</td> <td>在 HashMap 的注释里使用哈希桶来形象的表示数组中每个地址位置。注意这里并不是数组本身，数组是装哈希桶的，他可以被称为<strong>哈希表</strong>。</td></tr> <tr><td>capacity</td> <td>table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td></tr> <tr><td>size</td> <td>table 的实际使用量。</td></tr> <tr><td>threshold</td> <td>size 的临界值，size 必须小于 threshold，如果大于等于，就必须进行扩容操作。</td></tr> <tr><td>loadFactor</td> <td>装载因子，table 能够使用的比例，threshold = capacity * loadFactor。</td></tr> <tr><td>TREEIFY_THRESHOLD</td> <td>树化阀值，哈希桶中的节点个数大于该值（默认为8）的时候将会被转为红黑树行存储结构。</td></tr> <tr><td>UNTREEIFY_THRESHOLD</td> <td>非树化阀值，小于该值（默认为 6）的时候将再次改为单链表的格式存储</td></tr></tbody></table> <h3 id="_3-确定哈希桶数组索引位置"><a href="#_3-确定哈希桶数组索引位置" class="header-anchor">#</a> 3. 确定哈希桶数组索引位置</h3> <p>很多操作都需要先确定一个键值对所在的桶下标。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>（一）计算 hash 值</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> h <span class="token operator">&amp;&amp;</span> k <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Hashing</span><span class="token punctuation">.</span><span class="token function">stringHash32</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// This function ensures that hashCodes that differ only by</span>
    <span class="token comment">// constant multiples at each bit position have a bounded</span>
    <span class="token comment">// number of collisions (approximately 8 at default load factor).</span>
    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>（二）取模</p> <p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>x   : 00010000
x-1 : 00001111
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>y       : 10110010
x-1     : 00001111
y&amp;(x-1) : 00000010
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个性质和 y 对 x 取模效果是一样的：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>y   : 10110010
x   : 00010000
y%x : 00000010
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p> <p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_4-分析hashmap的put方法"><a href="#_4-分析hashmap的put方法" class="header-anchor">#</a> 4. 分析HashMap的put方法</h3> <p>HashMap 的 put 方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。</p> <div align="center"><img src="assets/hashmap-put.png" width=""></div><br> <p>①.判断键值对数组 table[i] 是否为空或为 null，否则执行 resize() 进行扩容；</p> <p>②.根据键值 key 计算 hash 值得到插入的数组索引i，如果 table[i]==null，直接新建节点添加，转向 ⑥，如果table[i] 不为空，转向 ③；</p> <p>③.判断 table[i] 的首个元素是否和 key 一样，如果相同直接覆盖 value，否则转向 ④，这里的相同指的是 hashCode 以及 equals；</p> <p>④.判断table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向 ⑤；</p> <p>⑤.遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；</p> <p>⑥.插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold，如果超过，进行扩容。</p> <p>JDK1.8 HashMap 的 put 方法源码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对key的hashCode()做hash</span>
    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token comment">// 步骤①：tab为空则创建</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">// 步骤②：计算index，并对null做处理 </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> 
        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
        <span class="token comment">// 步骤③：节点key存在，直接覆盖value</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token comment">// 步骤④：判断该链为红黑树</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 步骤⑤：该链为链表</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>value<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                     <span class="token comment">//链表长度大于8转换为红黑树进行处理</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st  </span>
                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                 <span class="token comment">// key已经存在直接覆盖value</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
                           <span class="token keyword">break</span><span class="token punctuation">;</span>
                p <span class="token operator">=</span> e<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// existing mapping for key</span>
            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
    <span class="token comment">// 步骤⑥：超过最大容量 就扩容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br></div></div><h3 id="_5-扩容机制"><a href="#_5-扩容机制" class="header-anchor">#</a> 5. 扩容机制</h3> <p>扩容 (resize) 就是重新计算容量，向 HashMap 对象里不停的添加元素，而 HashMap 对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然 Java 里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p> <p>我们分析下 resize 的源码，鉴于 JDK1.8 融入了红黑树，较复杂，为了便于理解我们仍然使用 JDK1.7 的代码，好理解一些，本质上区别不大，具体区别后文再说。</p> <div class="language-JAVA line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//传入新的容量</span>
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token comment">//引用扩容前的Entry数组</span>
    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>         
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//扩容前的数组大小如果已经达到最大(2^30)了</span>
        threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span> <span class="token comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//初始化一个新的Entry数组</span>
    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">//！！将数据转移到新的Entry数组里</span>
    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>                           <span class="token comment">//HashMap的table属性引用新的Entry数组</span>
    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//修改阈值</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer() 方法将原有 Entry 数组的元素拷贝到新的 Entry 数组里。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> src <span class="token operator">=</span> table<span class="token punctuation">;</span>                   <span class="token comment">//src引用了旧的Entry数组</span>
    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> src<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//遍历旧的Entry数组</span>
        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> src<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token comment">//取得旧Entry数组的每个元素</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            src<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span>
            <span class="token keyword">do</span> <span class="token punctuation">{</span>
                <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//！！重新计算每个元素在数组中的位置</span>
                e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//标记[1]</span>
                newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>      <span class="token comment">//将元素放在数组上</span>
                e <span class="token operator">=</span> next<span class="token punctuation">;</span>             <span class="token comment">//访问下一个Entry链上的元素</span>
            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>newTable[i] 的引用赋给了 e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到 Entry 链的尾部(如果发生了 hash 冲突的话），这一点和 Jdk1.8 有区别，下文详解。在旧数组中同一条 Entry 链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p> <p>下面举个例子说明下扩容过程。假设了我们的 hash 算法就是简单的用 key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组 table 的 size=2， 所以 key = 3、7、5，put 顺序依次为 5、7、3。在 mod 2 以后都冲突在 table[1] 这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小 size 大于 table 的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize 成 4，然后所有的 Node 重新 rehash 的过程。</p> <div align="center"><img src="assets/jdk1.7-resize.png" width="600"></div> <p>下面我们讲解下 JDK1.8 做了哪些优化。经过观测可以发现，我们使用的是 2 次幂的扩展 (指长度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。看下图可以明白这句话的意思，n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和 key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。</p> <div align="center"><img src="assets/hashMap-1.8-hash1.png" width="700"></div><br> <p>元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit (红色)，因此新的 index 就会发生这样的变化：</p> <div align="center"><img src="assets/hashMap-1.8-hash2.png" width="600"></div> <p>因此，我们在扩充 HashMap 的时候，不需要像 JDK1.7 的实现那样重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引+oldCap”，可以看看下图为 16 扩充为 32 的 resize 示意图：</p> <div align="center"><img src="assets/jdk1.8-resize.png" width="700"></div><br> <p>这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。这一块就是 JDK1.8 新增的优化点。有一点注意区别，JDK1.7 中 rehash 的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8 不会倒置。有兴趣的同学可以研究下 JDK1.8 的 resize源 码，写的很赞，如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>
    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 没超过最大值，就扩充为原来的2倍</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token generics"><span class="token punctuation">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;</span><span class="token operator">&amp;</span>
                 oldCap <span class="token punctuation">&gt;</span></span><span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>
            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span>
        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment">// zero initial threshold signifies using defaults</span>
        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 计算新的resize上限</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>
                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;rawtypes&quot;</span>，<span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>
    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 把每个bucket都移动到新的buckets中</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 链表优化重hash的代码块</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
                    <span class="token keyword">do</span> <span class="token punctuation">{</span>
                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                        <span class="token comment">// 原索引</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token comment">// 原索引+oldCap</span>
                        <span class="token keyword">else</span> <span class="token punctuation">{</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 原索引放到bucket里</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">// 原索引+oldCap放到bucket里</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br></div></div><h3 id="_6-线程安全性"><a href="#_6-线程安全性" class="header-anchor">#</a> 6. 线程安全性</h3> <p>在多线程使用场景中，应该尽量避免使用线程不安全的 HashMap，而使用线程安全的 ConcurrentHashMap。那么为什么说 HashMap 是线程不安全的，下面举例子说明在并发的多线程使用场景中使用 HashMap 可能造成死循环。代码例子如下(便于理解，仍然使用 JDK1.7 的环境)：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMapInfiniteLoop</span> <span class="token punctuation">{</span>  

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">2</span>，<span class="token number">0.75f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">5</span>， <span class="token string">&quot;C&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token string">&quot;Thread1&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">&quot;B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token string">&quot;Thread2&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> &quot;<span class="token class-name">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p> <p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p> <div align="center"><img src="assets/jdk1.7-drop-dead-1.png" width="600"></div> <p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p> <p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p> <div align="center"><img src="assets/jdk1.7-drop-dead-2.png" width="600"></div> <div align="center"><img src="assets/jdk1.7-drop-dead-3.png" width="600"></div> <p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p> <div align="center"><img src="assets/jdk1.7-drop-dead-5.png" width="600"></div> <p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p> <h3 id="_7-jdk1-8与jdk1-7的性能对比"><a href="#_7-jdk1-8与jdk1-7的性能对比" class="header-anchor">#</a> 7. JDK1.8与JDK1.7的性能对比</h3> <p>HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。</p> <h3 id="_8-hash较均匀的情况"><a href="#_8-hash较均匀的情况" class="header-anchor">#</a> 8. Hash较均匀的情况</h3> <p>为了便于测试，我们先写一个类Key，如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Key</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>

    <span class="token class-name">Key</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Key</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span> o<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> o<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token class-name">Key</span> key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Key</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>
        <span class="token keyword">return</span> value <span class="token operator">==</span> key<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Keys</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_KEY <span class="token operator">=</span> <span class="token number">10_000_000</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Key</span><span class="token punctuation">[</span><span class="token punctuation">]</span> KEYS_CACHE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Key</span><span class="token punctuation">[</span>MAX_KEY<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_KEY<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            KEYS_CACHE<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Key</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Key</span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> KEYS_CACHE<span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、......10000000），屏蔽了扩容的情况，代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> mapSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>mapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mapSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Keys</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">long</span> beginTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取纳秒</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mapSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Keys</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">long</span> endTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>endTime <span class="token operator">-</span> beginTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span> <span class="token number">1000</span> <span class="token number">0000</span><span class="token punctuation">;</span>i<span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">test</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下：</p> <div align="center"><img src="assets/hashmap-compare1.png" width=""></div><br> <p>通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。</p> <h3 id="_9-hash极不均匀的情况"><a href="#_9-hash极不均匀的情况" class="header-anchor">#</a> 9. Hash极不均匀的情况</h3> <p>假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Key</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token comment">//...</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>仍然执行main方法，得出的结果如下表所示：</p> <div align="center"><img src="assets/hashmap-compare2.png" width=""></div><br> <p>从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p> <p>测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。</p> <h3 id="_10-hashmap与hashtable"><a href="#_10-hashmap与hashtable" class="header-anchor">#</a> 10. HashMap与Hashtable</h3> <ol><li>Hashtable 使用 synchronized 来进行同步。</li> <li>HashMap 可以插入键为 null 的 Entry。</li> <li>HashMap 的迭代器是 fail-fast 迭代器。</li> <li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li></ol> <h3 id="_11-小结"><a href="#_11-小结" class="header-anchor">#</a> 11. 小结</h3> <ol><li>扩容是一个特别耗性能的操作，所以当程序员在使用 HashMap 的时候，估算 map 的大小，初始化的时候给一个大致的数值，避免 map 进行频繁的扩容。</li> <li>负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</li> <li>HashMap 是线程不安全的，不要在并发的环境中同时操作 HashMap，建议使用 ConcurrentHashMap。</li> <li>JDK1.8 引入红黑树大程度优化了 HashMap 的性能。</li></ol> <p>参考资料：</p> <ul><li><a href="https://tech.meituan.com/java_hashmap.html" target="_blank" rel="noopener noreferrer">Java 8系列之重新认识HashMap——美团技术<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.im/post/5ac83fa35188255c5668afd0" target="_blank" rel="noopener noreferrer">搞懂 Java HashMap 源码 - 掘金<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.im/post/5ac4d8abf265da23a4050ae3" target="_blank" rel="noopener noreferrer">搞懂 Java equals 和 hashCode 方法 - 掘金<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="concurrenthashmap"><a href="#concurrenthashmap" class="header-anchor">#</a> ConcurrentHashMap</h2> <h3 id="_1-概述"><a href="#_1-概述" class="header-anchor">#</a> 1. 概述</h3> <p>众所周知，哈希表是中非常高效，复杂度为 O(1) 的数据结构，在 Java 开发中，我们最常见到最频繁使用的就是 HashMap 和 Hashtable，但是在线程竞争激烈的并发场景中使用都不够合理。</p> <p><strong>HashMap</strong> ：先说 HashMap，HashMap 是<strong>线程不安全</strong>的，在并发环境下，可能会形成<strong>环状链表</strong>（扩容时可能造成），导致 get 操作时，cpu 空转，所以，在并发环境中使 用HashMap 是非常危险的。</p> <p><strong>Hashtable</strong> ： Hashtable 和 HashMap的实现原理几乎一样，差别无非是：（1）Hashtable不允许key和value为null；（2）Hashtable是线程安全的。</p> <p>但是 Hashtable 线程安全的策略实现代价却太大了，简单粗暴，get/put 所有相关操作都是 synchronized 的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。</p> <div align="center"><img src="assets/hashtable-ds.png" width="600"></div> <p>Hashtable 性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap 所采用的 &quot;<strong>分段锁</strong>&quot; 思想。</p> <div align="center"><img src="assets/hashmap-ds.png" width="600"></div><br> <h3 id="_2-存储结构"><a href="#_2-存储结构" class="header-anchor">#</a> 2. 存储结构</h3> <p>ConcurrentHashMap 采用了非常精妙的&quot;分段锁&quot;策略，ConcurrentHashMap 的主干是个 Segment 数组。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code> <span class="token keyword">final</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> segments<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Segment 继承了 ReentrantLock，所以它就是一种可重入锁（ReentrantLock)。在 ConcurrentHashMap，一个 Segment 就是一个子哈希表，Segment 里维护了一个 HashEntry 数组，并发环境下，对于不同 Segment 的数据进行操作是不用考虑锁竞争的。（就按默认的 ConcurrentLeve 为16来讲，理论上就允许 16 个线程并发执行，有木有很酷）</p> <p><strong>所以，对于同一个 Segment 的操作才需考虑线程同步，不同的 Segment 则无需考虑。</strong></p> <p>Segment 类似于 HashMap，一个 Segment 维护着一个 HashEntry 数组</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>HashEntry 是目前我们提到的最小的逻辑处理单元了。一个 ConcurrentHashMap 维护一个 Segment 数组，一个 Segment 维护一个 HashEntry 数组。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> <span class="token class-name">V</span> value<span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p> <p>Segment 继承自 <strong>ReentrantLock</strong>。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">2249069246763182397L</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_SCAN_RETRIES <span class="token operator">=</span>
        <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">64</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>

    <span class="token keyword">transient</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>

    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>

    <span class="token keyword">transient</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>

    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> segments<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CONCURRENCY_LEVEL <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_2-size-操作"><a href="#_2-size-操作" class="header-anchor">#</a> 2. size 操作</h3> <p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * The number of elements. Accessed only either within locks
 * or among other volatile reads that maintain visibility.
 */</span>
<span class="token keyword">transient</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p> <p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p> <p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p> <p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * Number of unsynchronized retries in size and containsValue
 * methods before resorting to locking. This is used to avoid
 * unbounded retries if tables undergo continuous modification
 * which would make it impossible to obtain an accurate result.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RETRIES_BEFORE_LOCK <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Try a few times to get accurate count. On failure due to</span>
    <span class="token comment">// continuous async changes in table, resort to locking.</span>
    <span class="token keyword">final</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> segments <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>segments<span class="token punctuation">;</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> overflow<span class="token punctuation">;</span> <span class="token comment">// true if size overflows 32 bits</span>
    <span class="token keyword">long</span> sum<span class="token punctuation">;</span>         <span class="token comment">// sum of modCounts</span>
    <span class="token keyword">long</span> last <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>   <span class="token comment">// previous sum</span>
    <span class="token keyword">int</span> retries <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// first iteration isn't retry</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 超过尝试次数，则对每个 Segment 加锁</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>retries<span class="token operator">++</span> <span class="token operator">==</span> RETRIES_BEFORE_LOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
                    <span class="token function">ensureSegment</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// force creation</span>
            <span class="token punctuation">}</span>
            sum <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>
            size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            overflow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> seg <span class="token operator">=</span> <span class="token function">segmentAt</span><span class="token punctuation">(</span>segments<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>seg <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    sum <span class="token operator">+=</span> seg<span class="token punctuation">.</span>modCount<span class="token punctuation">;</span>
                    <span class="token keyword">int</span> c <span class="token operator">=</span> seg<span class="token punctuation">.</span>count<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>size <span class="token operator">+=</span> c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                        overflow <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> last<span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            last <span class="token operator">=</span> sum<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>retries <span class="token operator">&gt;</span> RETRIES_BEFORE_LOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
                <span class="token function">segmentAt</span><span class="token punctuation">(</span>segments<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> overflow <span class="token operator">?</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span> size<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br></div></div><h3 id="_3-同步方式"><a href="#_3-同步方式" class="header-anchor">#</a> 3. 同步方式</h3> <p>Segment 继承自 ReentrantLock，所以我们可以很方便的对每一个 Segment 上锁。</p> <p>对于读操作，获取 Key 所在的 Segment 时，需要保证可见性。具体实现上可以使用 volatile 关键字，也可使用锁。但使用锁开销太大，而使用 volatile 时每次写操作都会让所有 CPU 内缓存无效，也有一定开销。ConcurrentHashMap 使用如下方法保证可见性，取得最新的 Segment。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>UNSAFE<span class="token punctuation">.</span><span class="token function">getObjectVolatile</span><span class="token punctuation">(</span>segments<span class="token punctuation">,</span> u<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>获取 Segment 中的 HashEntry 时也使用了类似方法</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> UNSAFE<span class="token punctuation">.</span>getObjectVolatile
  <span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> TSHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> TBASE<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>对于写操作，并不要求同时获取所有 Segment 的锁，因为那样相当于锁住了整个 Map。它会先获取该 Key-Value 对所在的 Segment 的锁，获取成功后就可以像操作一个普通的 HashMap 一样操作该 Segment，并保证该Segment 的安全性。
同时由于其它 Segment 的锁并未被获取，因此理论上可支持 concurrencyLevel（等于 Segment 的个数）个线程安全的并发读写。</p> <p>获取锁时，并不直接使用 lock 来获取，因为该方法获取锁失败时会挂起。事实上，它使用了自旋锁，如果 tryLock 获取锁失败，说明锁被其它线程占用，此时通过循环再次以 tryLock 的方式申请锁。如果在循环过程中该 Key 所对应的链表头被修改，则重置 retry 次数。如果 retry 次数超过一定值，则使用 lock 方法申请锁。</p> <p>这里使用自旋锁是因为自旋锁的效率比较高，但是它消耗 CPU 资源比较多，因此在自旋次数超过阈值时切换为互斥锁。</p> <h3 id="_4-jdk-1-8-的改动"><a href="#_4-jdk-1-8-的改动" class="header-anchor">#</a> 4. JDK 1.8 的改动</h3> <ul><li><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发程度与 Segment 数量相等。</p></li> <li><p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p></li> <li><p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p></li></ul> <p>参考资料：</p> <ul><li><p><a href="http://www.jasongj.com/java/concurrenthashmap/" target="_blank" rel="noopener noreferrer">ConcurrentHashMap演进从Java7到Java8<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener noreferrer">ConcurrentHashMap实现原理及源码分析 - dreamcatcher-cx - 博客园<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul> <h2 id="hashset"><a href="#hashset" class="header-anchor">#</a> HashSet</h2> <p>前面已经说过 HashSet 是对 HashMap 的简单包装，对 HashSet 的函数调用都会转换成合适的 HashMap 方法，因此 HashSet 的实现非常简单，只有不到 300 行代码（适配器模式）。这里不再赘述。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//HashSet是对HashMap的简单包装</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span><span class="token comment">//HashSet里面有一个HashMap</span>
    <span class="token comment">// Dummy value to associate with an Object in the backing Map</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//简单的方法转换</span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="_1-成员变量"><a href="#_1-成员变量" class="header-anchor">#</a> 1. 成员变量</h3> <p>首先了解下 <code>HashSet</code> 的成员变量:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span>

    <span class="token comment">// Dummy value to associate with an Object in the backing Map</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>发现主要就两个变量:</p> <ul><li><code>map</code> ：用于存放最终数据的。</li> <li><code>PRESENT</code> ：是所有写入 map 的 <code>value</code> 值。</li></ul> <h3 id="_2-构造函数"><a href="#_2-构造函数" class="header-anchor">#</a> 2. 构造函数</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>构造函数很简单，利用了 <code>HashMap</code> 初始化了 <code>map</code> 。</p> <h3 id="_3-add"><a href="#_3-add" class="header-anchor">#</a> 3. add()</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>比较关键的就是这个 <code>add()</code> 方法。 可以看出它是将存放的对象当做了 <code>HashMap</code> 的健，<code>value</code> 都是相同的 <code>PRESENT</code> 。由于 <code>HashMap</code> 的 <code>key</code> 是不能重复的，所以每当有重复的值写入到 <code>HashSet</code> 时，<code>value</code> 会被覆盖，但 <code>key</code> 不会收到影响，这样就保证了 <code>HashSet</code> 中只能存放不重复的元素。</p> <h3 id="_4-总结"><a href="#_4-总结" class="header-anchor">#</a> 4. 总结</h3> <p><code>HashSet</code> 的原理比较简单，几乎全部借助于 <code>HashMap</code> 来实现的。</p> <p>所以 <code>HashMap</code> 会出现的问题 <code>HashSet</code> 依然不能避免。</p> <h2 id="linkedhashset-and-linkedhashmap"><a href="#linkedhashset-and-linkedhashmap" class="header-anchor">#</a> LinkedHashSet and LinkedHashMap</h2> <h3 id="_1-概览-3"><a href="#_1-概览-3" class="header-anchor">#</a> 1. 概览</h3> <p>如果你已看过前面关于 HashSet 和 HashMap，的讲解，一定能够想到本文将要讲解的 LinkedHashSet 和 LinkedHashMap 其实也是一回事。 LinkedHashSet 和 LinkedHashMap 在 Java 里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说 LinkedHashSet 里面有一个 LinkedHashMap（<strong>适配器模式</strong>）。因此本文将重点分析 LinkedHashMap。</p> <p>LinkedHashMap 实现了 Map 接口，即允许放入 key 为 null 的元素，也允许插入 value 为 null 的元素。从名字上可以看出该容器是 LinkedList 和 HashMap 的混合体，也就是说它同时满足 HashMap 和 LinkedList 的某些特性。<strong>可将 LinkedHashMap 看作采用 LinkedList 增强的 HashMap。</strong></p> <div align="center"><img src="assets/LinkedHashMap_base.png" width="650"></div><br> <p>事实上 LinkedHashMap 是 HashMap 的直接子类，<strong>二者唯一的区别是 LinkedHashMap 在 HashMap 的基础上，采用双向链表（doubly-linked list）的形式将所有 entry 连接起来，这样是为保证元素的迭代顺序跟插入顺序相同</strong>。上图给出了 LinkedHashMap 的结构图，主体部分跟 HashMap 完全一样，多了 <code>header</code> 指向双向链表的头部（是一个哑元），<strong>该双向链表的迭代顺序就是 entry 的插入顺序</strong>。</p> <p>除了可以保迭代历顺序，这种结构还有一个好处：<strong>迭代 LinkedHashMap 时不需要像 HashMap 那样遍历整个table，而只需要直接遍历 header 指向的双向链表即可</strong>，也就是说 LinkedHashMap 的迭代时间就只跟<code>entry</code>的个数相关，而跟<code>table</code>的大小无关。</p> <p>有两个参数可以影响 LinkedHashMap 的性能：<strong>初始容量</strong>（inital capacity）和<strong>负载系数</strong>（load factor）。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p> <p>将对象放入到 LinkedHashMap 或 LinkedHashSet 中时，有两个方法需要特别关心：<code>hashCode()</code> 和 <code>equals()</code>。<strong>hashCode() 方法决定了对象会被放到哪个 bucket 里，当多个对象的哈希值冲突时，equals() 方法决定了这些对象是否是“同一个对象”</strong>。所以，如果要将自定义的对象放入到 <code>LinkedHashMap</code> 或 <code>LinkedHashSet</code> 中，需要 <em>@Override</em><code>hashCode()</code> 和 <code>equals()</code> 方法。</p> <p>通过如下方式可以得到一个跟源 Map 迭代顺序 一样的 LinkedHashMap：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token class-name">Map</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Map</span> copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>出于性能原因，LinkedHashMap 是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将 LinkedHashMap 包装成（wrapped）同步的：</p> <p><code>Map m = Collections.synchronizedMap(new LinkedHashMap(...));</code></p> <h3 id="_2-get"><a href="#_2-get" class="header-anchor">#</a> 2. get()</h3> <p><code>get(Object key)</code> 方法根据指定的 <code>key</code> 值返回对应的 <code>value</code>。该方法跟<code>HashMap.get()</code>方法的流程几乎完全一样，读者可自行<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md#get" target="_blank" rel="noopener noreferrer">参考前文<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，这里不再赘述。</p> <h3 id="_3-put"><a href="#_3-put" class="header-anchor">#</a> 3. put()</h3> <p><code>put(K key, V value)</code> 方法是将指定的 <code>key, value</code> 对添加到 <code>map</code> 里。该方法首先会对 <code>map</code> 做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；如果没有找到，则会通过 <code>addEntry(int hash, K key, V value, int bucketIndex)</code> 方法插入新的 <code>entry</code>。</p> <p>注意，这里的<strong>插入有两重含义</strong>：</p> <blockquote><ol><li>从 table 的角度看，新的 entry 需要插入到对应的 bucket 里，当有哈希冲突时，采用头插法将新的 entry 插入到冲突链表的头部。</li> <li>从 header 的角度看，新的 entry 需要插入到双向链表的尾部。</li></ol></blockquote> <div align="center"><img src="assets/LinkedHashMap_addEntry.png" width="650"></div> <p><code>addEntry()</code>代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// LinkedHashMap.addEntry()</span>
<span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 自动扩容，并重新哈希</span>
        hash <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
        bucketIndex <span class="token operator">=</span> hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// hash%table.length</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 1.在冲突链表头部插入新的entry</span>
    <span class="token class-name">HashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> old <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> old<span class="token punctuation">)</span><span class="token punctuation">;</span>
    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token comment">// 2.在双向链表的尾部插入新的entry</span>
    e<span class="token punctuation">.</span><span class="token function">addBefore</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>
    size<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>上述代码中用到了 <code>addBefore()</code>方 法将新 <code>entry e</code> 插入到双向链表头引用 <code>header</code> 的前面，这样 <code>e</code> 就成为双向链表中的最后一个元素。<code>addBefore()</code> 的代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addBefore</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> existingEntry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    after  <span class="token operator">=</span> existingEntry<span class="token punctuation">;</span>
    before <span class="token operator">=</span> existingEntry<span class="token punctuation">.</span>before<span class="token punctuation">;</span>
    before<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    after<span class="token punctuation">.</span>before <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>上述代码只是简单修改相关 <code>entry</code> 的引用而已。</p> <h3 id="_4-remove"><a href="#_4-remove" class="header-anchor">#</a> 4. remove()</h3> <p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>（修改链表的相应引用）。查找过程跟<code>get()</code>方法类似。</p> <p>注意，这里的<strong>删除也有两重含义</strong>：</p> <blockquote><ol><li>从<code>table</code>的角度看，需要将该<code>entry</code>从对应的<code>bucket</code>里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</li> <li>从<code>header</code>的角度来看，需要将该<code>entry</code>从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</li></ol></blockquote> <div align="center"><img src="assets/LinkedList_remove.png" width="700"></div><br> <p><code>removeEntryForKey()</code> 对应的代码如下：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// LinkedHashMap.removeEntryForKey()，删除key值对应的entry</span>
final Entry<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span><span class="token constant">V</span><span class="token operator">&gt;</span> <span class="token function">removeEntryForKey</span><span class="token punctuation">(</span><span class="token parameter">Object key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token operator">...</span><span class="token operator">...</span>
	int hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    int i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// hash&amp;(table.length-1)</span>
    Entry<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span><span class="token constant">V</span><span class="token operator">&gt;</span> prev <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 得到冲突链表</span>
    Entry<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span><span class="token constant">V</span><span class="token operator">&gt;</span> e <span class="token operator">=</span> prev<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 遍历冲突链表</span>
        Entry<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span><span class="token constant">V</span><span class="token operator">&gt;</span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        Object k<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 找到要删除的entry</span>
            modCount<span class="token operator">++</span><span class="token punctuation">;</span> size<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token comment">// 1. 将e从对应bucket的冲突链表中删除</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> e<span class="token punctuation">)</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> next<span class="token punctuation">;</span>
            <span class="token keyword">else</span> prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
            <span class="token comment">// 2. 将e从双向链表中删除</span>
            e<span class="token punctuation">.</span>before<span class="token punctuation">.</span>after <span class="token operator">=</span> e<span class="token punctuation">.</span>after<span class="token punctuation">;</span>
            e<span class="token punctuation">.</span>after<span class="token punctuation">.</span>before <span class="token operator">=</span> e<span class="token punctuation">.</span>before<span class="token punctuation">;</span>
            <span class="token keyword">return</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        prev <span class="token operator">=</span> e<span class="token punctuation">;</span> e <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> e<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h3 id="_5-linkedhashset"><a href="#_5-linkedhashset" class="header-anchor">#</a> 5. LinkedHashSet</h3> <p>前面已经说过<em>LinkedHashSet</em>是对<em>LinkedHashMap</em>的简单包装，对<em>LinkedHashSet</em>的函数调用都会转换成合适的<em>LinkedHashMap</em>方法，因此<em>LinkedHashSet</em>的实现非常简单，这里不再赘述。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">extends</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// LinkedHashSet里面有一个LinkedHashMap</span>
    <span class="token keyword">public</span> <span class="token class-name">LinkedHashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//简单的方法转换</span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_6-linkedhashmap经典用法"><a href="#_6-linkedhashmap经典用法" class="header-anchor">#</a> 6. LinkedHashMap经典用法</h3> <p>LinkedHashMap 除了可以保证迭代顺序外，还有一个非常有用的用法：可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap 有一个子类方法 <code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>，该方法的作用是告诉 Map 是否要删除“最老”的 Entry，所谓最老就是当前 Map 中最早插入的 Entry，如果该方法返回 true，最老的那个元素就会被删除。在每次插入新元素的之后 LinkedHashMap 会自动询问 removeEldestEntry() 是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让 removeEldestEntry() 返回 true，就能够实现一个固定大小的 FIFO 策略的缓存。示例代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/** 一个固定大小的FIFO替换策略的缓存 */</span>
<span class="token keyword">class</span> <span class="token class-name">FIFOCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> cacheSize<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">FIFOCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> cacheSize<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>cacheSize <span class="token operator">=</span> cacheSize<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 当Entry个数超过cacheSize时，删除最老的Entry</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> cacheSize<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h1 id="三、容器中的设计模式"><a href="#三、容器中的设计模式" class="header-anchor">#</a> 三、容器中的设计模式</h1> <h2 id="迭代器模式"><a href="#迭代器模式" class="header-anchor">#</a> 迭代器模式</h2> <div align="center"><img src="assets/Iterator-1.jpg" width=""></div><br> <p>Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p> <p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> item <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="适配器模式"><a href="#适配器模式" class="header-anchor">#</a> 适配器模式</h2> <p>java.util.Arrays.asList() 可以把数组类型转换为 List 类型。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@SafeVarargs</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">asList</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果要将数组类型转换为 List 类型，应该注意的是 asList() 的参数为泛型的变长参数，因此不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>也可以使用以下方式生成 List。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h1 id="四、面试指南"><a href="#四、面试指南" class="header-anchor">#</a> 四、面试指南</h1> <h2 id="_1-arraylist和linkedlist区别"><a href="#_1-arraylist和linkedlist区别" class="header-anchor">#</a> 1. ArrayList和LinkedList区别</h2> <ul><li><p>ArrayList 和 LinkedList 可想从名字分析，它们一个是 Array (动态数组) 的数据结构，一个是 Link (链表) 的数据结构，此外，它们两个都是对 List 接口的实现。前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列；</p></li> <li><p><strong>当随机访问 List 时</strong>（get和set操作），ArrayList 比 LinkedList的效率更高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找；</p></li> <li><p><strong>当对数据进行增加和删除的操作时</strong>（add 和 remove 操作），LinkedList 比 ArrayList 的效率更高，因为 ArrayList 是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动；</p></li> <li><p><strong>从利用效率来看</strong>，ArrayList 自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而 LinkedList 自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用；</p></li> <li><p>ArrayList 主要空间开销在于需要在 List 列表预留一定空间；而 LinkList 主要控件开销在于需要存储结点信息以及结点指针信息。</p></li> <li><p><strong>ArrayList、LinkedList 和 Vector如何选择？</strong></p> <ul><li>当对数据的主要操作为索引或只在集合的末端增加、删除元素时，使用 ArrayList 或 Vector 效率比较高；</li> <li>当对数据的操作主要为指定位置的插入或删除操作时，使用 LinkedList 效率比较高；</li> <li>当在多线程中使用容器时（即多个线程会同时访问该容器），选用 Vector 较为安全；</li></ul></li></ul> <h2 id="_2-hashmap和hashtable区别-hashmap的key类型"><a href="#_2-hashmap和hashtable区别-hashmap的key类型" class="header-anchor">#</a> 2. HashMap和Hashtable区别，HashMap的key类型</h2> <ul><li><p><strong>HashMap和Hashtable的区别</strong></p> <ul><li><p>Hashtable 的方法是同步的，HashMap 非同步，所以在多线程场合要手动同步。</p></li> <li><p>Hashtable 不允许 null 值 (key 和 value 都不可以)，HashMap 允许 null 值( key 和 value 都可以)。</p></li> <li><p>两者的遍历方式大同小异，Hashtable 仅仅比 HashMap 多一个 elements 方法。</p></li> <li><p>Hashtable 和 HashMap 都能通过 values() 方法返回一个 Collection ，然后进行遍历处理。</p></li> <li><p>两者也都可以通过 entrySet() 方法返回一个 Set ， 然后进行遍历处理。</p></li> <li><p>Hashtable 使用 Enumeration，HashMap 使用 Iterator。</p></li> <li><p>哈希值的使用不同，Hashtable 直接使用对象的 hashCode。而 HashMap 重新计算hash值，而且用于代替求模。</p></li> <li><p>Hashtable 中 hash 数组默认大小是11，增加的方式是 old*2+1。HashMap 中 hash 数组的默认大小是16，而且一定是 2 的指数。</p></li> <li><p>Hashtable 基于 Dictionary 类，而 HashMap 基于 AbstractMap 类</p></li></ul></li> <li><p><strong>HashMap中的key可以是任何对象或数据类型吗</strong></p> <ul><li>可以为null，但不能是可变对象，如果是可变对象的话，对象中的属性改变，则对象 HashCode 也进行相应的改变，导致下次无法查找到已存在Map中的数据。</li> <li>如果可变对象在 HashMap 中被用作键，那就要小心在改变对象状态的时候，不要改变它的哈希值了。我们只需要保证成员变量的改变能保证该对象的哈希值不变即可。</li></ul></li> <li><p><strong>Hashtable是线程安全的么</strong></p> <ul><li>Hashtable 是线程安全的，其实现是在对应的方法上添加了 synchronized 关键字进行修饰，由于在执行此方法的时候需要获得对象锁，则执行起来比较慢。所以现在如果为了保证线程安全的话，使用 CurrentHashMap。</li></ul></li></ul> <h2 id="_3-hashmap和concurrenthashmap"><a href="#_3-hashmap和concurrenthashmap" class="header-anchor">#</a> 3. HashMap和ConcurrentHashMap</h2> <ul><li><strong>HashMap和Concurrent HashMap区别？</strong> <ul><li>HashMap 是非线程安全的，CurrentHashMap 是线程安全的。</li> <li>ConcurrentHashMap 将整个 Hash 桶进行了分段 segment，也就是将这个大的数组分成了几个小的片段segment，而且每个小的片段 segment 上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段 segment，然后再在这个片段上面进行插入，而且这里还需要获取 segment 锁。</li> <li>ConcurrentHashMap 让锁的粒度更精细一些，并发性能更好。</li></ul></li> <li><strong>ConcurrentHashMap 线程安全吗， ConcurrentHashMap如何保证 线程安全？</strong> <ul><li>Hashtable 容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问 Hashtable 的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是 ConcurrentHashMap 所使用的<strong>分段锁</strong>，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li> <li>get 操作的高效之处在于整个 get 过程不需要加锁，除非读到的值是空的才会加锁重读。<strong>get 方法里将要使用的共享变量都定义成 volatile</strong>，如用于统计当前 Segement 大小的 count 字段和用于存储值的 HashEntry 的 value。定义成 volatile 的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在 get 操作里只需要读不需要写共享变量 count 和 value，所以可以不用加锁。</li> <li>put 方法首先定位到 Segment，然后在 Segment 里进行插入操作。
<ul><li>插入操作需要经历两个步骤：（1）判断是否需要对 Segment 里的 HashEntry 数组进行扩容；（2）定位添加元素的位置然后放在HashEntry数组里。</li></ul></li></ul></li></ul> <h2 id="_4-hashtable的原理"><a href="#_4-hashtable的原理" class="header-anchor">#</a> 4. Hashtable的原理</h2> <p><strong>Hashtable 使用链地址法进行元素存储，通过一个实际的例子来演示一下插入元素的过程：</strong></p> <p>假设我们现在 Hashtable 的容量为 5，已经存在了 (5,5)，(13,13)，(16,16)，(17,17)，(21,21) 这 5 个键值对，目前他们在 Hashtable 中的位置如下：</p> <div align="center"><img src="assets/hashtable1.png" width=""></div><br> <p>现在，我们插入一个新的键值对，put(16,22)，假设 key=16 的索引为 1.但现在索引 1 的位置有两个 Entry 了，所以程序会对链表进行迭代。迭代的过程中，发现其中有一个 Entry 的 key 和我们要插入的键值对的 key 相同，所以现在会做的工作就是将 newValue=22 替换 oldValue=16，然后返回 oldValue = 16.</p> <div align="center"><img src="assets/hashtable2.png" width=""></div><br> <p>然后我们现在再插入一个，put(33,33)，key=33 的索引为 3，并且在链表中也不存在 key=33 的 Entry，所以将该节点插入链表的第一个位置。</p> <div align="center"><img src="assets/hashtable3.png" width=""></div><br> <p><strong>Hashtable 与 HashMap 的简单比较</strong></p> <ol><li>Hashtable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap。Dictionary 是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作。</li> <li>HashMap 的 key 和 value 都允许为 null，而 Hashtable 的 key 和 value 都不允许为 null。HashMap 遇到 key 为 null 的时候，调用 putForNullKey 方法进行处理，而对 value 没有处理；Hashtable遇到 null，直接返回 NullPointerException。</li> <li><strong>Hashtable 方法是同步，而HashMap则不是</strong>。我们可以看一下源码，Hashtable 中的几乎所有的 public 的方法都是 synchronized 的，而有些方法也是在内部通过 synchronized 代码块来实现。所以有人一般都建议如果是涉及到多线程同步时采用 Hashtable，没有涉及就采用 HashMap，但是在 Collections 类中存在一个静态方法：<strong>synchronizedMap()</strong>，该方法创建了一个线程安全的 Map 对象，并把它作为一个封装的对象来返回。</li></ol> <p><strong>参考资料：</strong></p> <ul><li><a href="http://wiki.jikexueyuan.com/project/java-collection/hashtable.html" target="_blank" rel="noopener noreferrer">Hashtable 的实现原理 - Java 集合学习指南 - 极客学院Wiki<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="_5-hash冲突的解决办法"><a href="#_5-hash冲突的解决办法" class="header-anchor">#</a> 5. Hash冲突的解决办法</h2> <ul><li>链地址法</li> <li>开放地址法（向后一位）
<ul><li>线性探测</li> <li>平方探测</li> <li>二次哈希</li></ul></li> <li>再哈希法</li></ul> <h2 id="_6-什么是迭代器"><a href="#_6-什么是迭代器" class="header-anchor">#</a> 6. 什么是迭代器</h2> <p>Java 集合框架的集合类，我们有时候称之为容器。容器的种类有很多种，比如 ArrayList、LinkedList、HashSet...，每种容器都有自己的特点，ArrayList 底层维护的是一个数组；LinkedList 是链表结构的；HashSet 依赖的是哈希表，每种容器都有自己特有的数据结构。</p> <p>因为容器的内部结构不同，很多时候可能不知道该怎样去遍历一个容器中的元素。所以为了使对容器内元素的操作更为简单，Java 引入了迭代器模式！</p> <p>把访问逻辑从不同类型的集合类中抽取出来，从而避免向外部暴露集合的内部结构。</p> <p><strong>迭代器模式</strong>：就是提供一种方法对一个容器对象中的各个元素进行访问，而又不暴露该对象容器的内部细。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用迭代器遍历ArrayList集合</span>
    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> listIt <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>listIt<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>listIt<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 使用迭代器遍历Set集合</span>
    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> setIt <span class="token operator">=</span> set<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>setIt<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>listIt<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 使用迭代器遍历LinkedList集合</span>
    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> linkIt <span class="token operator">=</span> linkList<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>linkIt<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>listIt<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>参考资料：</p> <ul><li><a href="https://www.cnblogs.com/zyuze/p/7726582.html" target="_blank" rel="noopener noreferrer">深入理解Java中的迭代器 - Mr·Dragon - 博客园<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="_7-构造相同hash的字符串进行攻击-这种情况应该怎么处理-jdk7如何处理"><a href="#_7-构造相同hash的字符串进行攻击-这种情况应该怎么处理-jdk7如何处理" class="header-anchor">#</a> 7. 构造相同hash的字符串进行攻击，这种情况应该怎么处理？JDK7如何处理</h2> <p><strong>攻击原理：</strong></p> <p>当客户端发送一个请求到服务器，如果该请求中带有参数，服务器端会将 参数名-参数值 作为 key-value 保存在 HashMap 中。如果有人恶意构造请求，在请求中加入大量相同 hash 值的 String 参数名（key），那么在服务器端用于存储这些 key-value 对的 HashMap 会被强行退化成链表，如图：</p> <div align="center"><img src="assets/hash-to-badlink.png" width=""></div> <p>如果数据量足够大，那么在查找，插入时会占用大量 CPU，达到拒绝服务攻击的目的。</p> <p><strong>怎么处理</strong></p> <ol><li>限制 POST 和 GET 请求的参数个数</li> <li>限制 POST 请求的请求体大小</li> <li>Web Application FireWall（WAF）</li></ol> <p><strong>JDK7如何处理</strong></p> <p>HashMap 会动态的使用一个专门 TreeMap 实现来替换掉它。</p> <h2 id="_8-hashmap为什么大小是2的幂次"><a href="#_8-hashmap为什么大小是2的幂次" class="header-anchor">#</a> 8. HashMap为什么大小是2的幂次</h2> <p>首先来看一下 HashMap 的 put 方法的源码</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                
        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将空key的Entry加入到table[0]中</span>
    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//计算key.hashcode()的hash值，hash函数由HashMap自己实现</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//获取将要存放的数组下标</span>
    <span class="token comment">/*
     * for中的代码用于：当hash值相同且key相同的情况下，使用新值覆盖旧值（其实就是修改功能）
     */</span>
    <span class="token comment">//注意：for循环在第一次执行时就会先判断条件</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Object</span> k<span class="token punctuation">;</span>
        <span class="token comment">//hash值相同且key相同的情况下，使用新值覆盖旧值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token comment">//e.recordAccess(this);</span>
            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token comment">//返回旧值</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//增加一个新的Entry到table[i]</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//如果没有与传入的key相等的Entry，就返回null</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * &quot;按位与&quot;来获取数组下标
 */</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>HashMap 始终将自己的桶保持在2<sup>n</sup>，这是为什么？indexFor这个方法解释了这个问题</strong></p> <p>大家都知道计算机里面位运算是基本运算，位运算的效率是远远高于取余 % 运算的</p> <p>举个例子：2<sup>n</sup> 转换成二进制就是 1+n 个 0，减 1 之后就是 0+n个1，如16 -&gt; 10000，15 -&gt; 01111</p> <p>那么根据 &amp; 位运算的规则，都为 1 (真)时，才为 1，那 0≤运算后的结果≤15，假设 h &lt;= 15，那么运算后的结果就是 h 本身，h &gt;15，运算后的结果就是最后四位二进制做 &amp; 运算后的值，最终，就是 % 运算后的余数。</p> <p>当容量一定是 2<sup>n</sup> 时，h &amp; (length - 1) == h % length</p> <h1 id="更新日志"><a href="#更新日志" class="header-anchor">#</a> 更新日志</h1> <ul><li>2018/8/3 v2.5 基础版</li> <li>2018/9/1 v3.0 初稿版</li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/txxs/mark/edit/master/docs/java/collection/Java集合框架更多细节.md" target="_blank" rel="noopener noreferrer">帮助我们改善此页面！</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022-01-04 17:14:56</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/mark/java/collection/hashmap的死循环详解.html" class="prev">
        /java/collection/hashmap的死循环详解.html
      </a></span> <span class="next"><a href="/mark/java/collection/jdk5-10.html">
        /java/collection/jdk5-10.html
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/mark/assets/js/app.92e1a2e3.js" defer></script><script src="/mark/assets/js/2.9796e7dc.js" defer></script><script src="/mark/assets/js/148.a4173523.js" defer></script><script src="/mark/assets/js/4.70c6b853.js" defer></script>
  </body>
</html>
